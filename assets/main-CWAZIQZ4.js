(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))s(a);new MutationObserver(a=>{for(const i of a)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(a){const i={};return a.integrity&&(i.integrity=a.integrity),a.referrerPolicy&&(i.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?i.credentials="include":a.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(a){if(a.ep)return;a.ep=!0;const i=t(a);fetch(a.href,i)}})();const F={ja:{gameTitle:"ターミナル・ディセント",gameSubtitle:"ディストピア・ローグライク v1.0",controls:"WASDで移動 | Fで調べる | Iでインベントリ | Cでステータス | Lで言語切替 | ESCでメニュー",welcome:"ターミナル・ディセントへようこそ。WASDで移動してください。",cannotMoveThere:"そこには移動できません。",pickedUpItem:"を手に入れた。",nothingToInteract:"調べるものがありません。",enemyAttacks:"グレムリンが攻撃してきた！",youDied:"あなたは死亡しました。",gameOver:"ゲームオーバー。",levelCleared:"フロアクリア！勝利です！",gamePaused:"ゲームを一時停止しました。ESCで再開。",gameResumed:"ゲームを再開しました。",menuNotImplemented:"メニューは未実装です。",searchingForExit:"ターミナル・ディセントを開始。出口を探索中...",languageSwitched:"言語が切り替わりました。",playerAttacks:"を攻撃した！",enemyDefeated:"を倒した！",attackModeOn:"攻撃モード：方向キーで攻撃方向を選択",attackModeOff:"移動モード",noEnemyThere:"そこには敵がいません。",attackMissed:"{{enemy}}への攻撃が外れた！",criticalHit:"クリティカルヒット！ {{enemy}}に{{damage}}ダメージ！ HP: {{health}}/{{maxHealth}}",normalHit:"{{enemy}}に{{damage}}ダメージ！ HP: {{health}}/{{maxHealth}}",experienceGained:"経験値 +{{exp}}",levelUp:"レベルアップ！ Lv.{{level}}",enemyAttackWithDefense:"{{enemy}}の攻撃！ {{damage}}ダメージ！(防御力-{{defense}}) HP: {{health}}/{{maxHealth}}",enemyAttackNormal:"{{enemy}}の攻撃！ {{damage}}ダメージ！ HP: {{health}}/{{maxHealth}}",level:"レベル",health:"HP",energy:"エネルギー",accessLevel:"アクセス権",turn:"ターン",inventoryFull:"インベントリが満杯です。",inventoryEmpty:"インベントリは空です。",useItem:"を使用した。",pickedUpItemWithName:"{{item}}を拾った",cannotInteract:"そこには何もなかった",invalidItem:"無効なアイテムです。",noItemInSlot:"スロット{{slot}}にアイテムがありません。",ironSword:"鉄の剣",battleAxe:"バトルアックス",hunterBow:"ハンターボウ",magicStaff:"マジックスタッフ",steelDagger:"スチールダガー",ironHelmet:"鉄のヘルメット",steelChestplate:"スチール胸当て",leatherLeggings:"レザーレギンス",combatBoots:"コンバットブーツ",towerShield:"タワーシールド",healthPotion:"ヘルスポーション",energyBar:"エネルギーバー",mysteryScroll:"謎の巻物",healingHerb:"回復薬",energyCore:"エネルギーコア",ironSwordDesc:"標準的な鉄製の剣",battleAxeDesc:"強力な戦闘用斧",hunterBowDesc:"狩猟用の弓",magicStaffDesc:"魔法を増幅する杖",steelDaggerDesc:"軽量で素早い短剣",ironHelmetDesc:"鉄製の頭部防具",steelChestplateDesc:"スチール製の胸部防具",leatherLeggingsDesc:"レザー製の脚部防具",combatBootsDesc:"戦闘用ブーツ",towerShieldDesc:"大型の防御用盾",healthPotionDesc:"HP+30回復",energyBarDesc:"エネルギー+20回復",tutorialHealthPotion:"チュートリアル ポーション",tutorialHealthPotionDesc:"チュートリアル用の回復アイテム（HP+10回復）",tutorialSword:"チュートリアル ソード",tutorialSwordDesc:"チュートリアル用の練習剣（攻撃力+3）",mysteryScrollDesc:"ランダム効果",healingHerbDesc:"HP+15回復",energyCoreDesc:"エネルギー+50回復",weaponDescriptionFormat:"{{description}} (攻撃力: {{damage}})",armorDescriptionFormat:"{{description}} (防御力: {{defense}})",inventoryHeader:"=== インベントリ ===",currentEquipmentHeader:"=== 現在の装備 ===",usageInstructionsHeader:"=== 使用方法 ===",itemUsageInstructions:"数字キー(1-9)でアイテム使用/装備",itemUsageExample:"例: 1キー = [1]番目のアイテム",effectLabel:"効果",attackPowerEffect:"攻撃力+{{damage}}, 命中率+{{accuracy}}%",defenseEffect:"防御力+{{defense}}",totalDefense:"総防御力: {{total}}",rightHand:"右手",head:"頭",chest:"胸",legs:"脚",feet:"足",leftHand:"左手",noEquipment:"(装備なし)",pauseMenuTitle:"ポーズメニュー",continueGame:"ゲームを続ける",saveGame:"セーブ",loadGame:"ロード",languageSwitch:"言語切り替え",returnToTitle:"タイトルに戻る",descendingToFloor:"階層{{floor}}へ降りる...",cannotGoUp:"これ以上上には行けません。",returningToFloor:"階層{{floor}}へ戻る...",arrivedAtFloor:"階層{{floor}}に到着しました。",healthRestored:"HP+{{amount}}回復！",energyRestored:"エネルギー+{{amount}}回復！",itemCannotBeUsed:"{{item}}は使用できません。",weaponEquipped:"{{weapon}}を装備しました。",armorEquipped:"{{armor}}を装備しました。",cannotEquipWeapon:"武器を装備できませんでした。",cannotEquipArmor:"防具を装備できませんでした。",noEnemyInThatDirection:"そこには敵がいません。",movementMode:"移動モード",stairsAppeared:"次のフロアへの階段が現れました！ (Fキーで移動)",allFloorsCleared:"全フロアクリア！おめでとうございます！",welcomeToFacility:"ナイトシティ地下施設へようこそ。脱出を目指してください。",tutorialStarted:"チュートリアルを開始します。",tutorialComplete:"🎉 チュートリアル完了！ゲーム開始です！",settingsUnderDevelopment:"設定メニューは開発中です。",mysteryScrollHealth:"HP回復効果が発動！",mysteryScrollEnergy:"エネルギー回復効果が発動！",mysteryScrollScore:"スコアボーナス+50！",mysteryScrollMap:"マップ探索効果が発動！",tutorialWelcome:"ターミナル・ディセントへようこそ！WASDキーで移動してみましょう。",tutorialMovement:"よくできました！WASDで自由に移動できます。もう少し探索してみましょう。",tutorialCombat:"Spaceキーで攻撃モードに切り替えられます。試してみてください！",tutorialInventory:"Iキーでインベントリを開いて、アイテムを確認しましょう。",tutorialEquipment:"数字キー(1-9)でアイテムを使用できます。アイテムを使ってみましょう！",tutorialCompleted:"チュートリアル完了！すべての機能を覚えました。",tutorialProgressMovement:"✓ 移動をマスターしました！",tutorialProgressCombat:"✓ 次は戦闘システムを学びましょう。",tutorialProgressCombatComplete:"✓ 戦闘の基本を理解しました！",tutorialProgressInventory:"✓ インベントリの使い方を覚えました！",tutorialProgressEquipment:"✓ 装備システムも完璧です！",attackPowerLabel:"攻撃力",defenseLabel:"防御力",experienceLabel:"経験値",closeInstruction:"数字キー(1-9)でアイテム使用 | Iキーで閉じる",statusHeader:"=== ステータス ===",statusCloseInstruction:"Sキーで閉じる",equipmentHeader:"=== 装備 ===",equipmentStatsHeader:"=== 装備統計 ===",totalDefenseLabel:"総防御力",welcomeTitle:"ターミナル・ディセント",welcomeSubtitle:"ナイトシティ地下施設からの脱出劇",menuInstructions:"↑↓ または WS: 選択    Enter または F: 決定",prologueLines:["年は2087年。ナイトシティの地下研究施設で","あなたは目を覚ました。","","警備システムが暴走し、施設は封鎖された。","生き残るには地上への脱出しかない。","","装備を集め、敵を避け、10階層の地下から","脱出せよ。","","[Enterキーで開始]"],menuOptions:["[スタート] ゲームを開始","[チュートリアル] 操作を学ぶ","[設定] オプション設定"],emptyInventoryMessage:"インベントリが空です",weaponSlot:"武器",headSlot:"頭",chestSlot:"胸",legsSlot:"脚",feetSlot:"足",shieldSlot:"盾",noItem:"なし",gremlin:"グレムリン",goblin:"ゴブリン",orc:"オーク",troll:"トロル",takeoffHeader:"=== 装備を外す ===",takeoffInstruction:"外したい装備を選んでください",takeoffControls:"↑↓キー: 選択 | Enterキー: 外す | Tキー: 閉じる",noEquipmentToRemove:"外せる装備がありません。",weaponUnequipped:"{{weapon}}を外しました。",armorUnequipped:"{{armor}}を外しました。"},en:{gameTitle:"TERMINAL DESCENT",gameSubtitle:"DYSTOPIAN ROGUELIKE v1.0",controls:"Use WASD to move | Press F to interact | I for inventory | C for character | L for language | ESC for menu",welcome:"Welcome to Terminal Descent. Use WASD to move.",cannotMoveThere:"You cannot move there.",pickedUpItem:"You picked up ",nothingToInteract:"There is nothing here to interact with.",enemyAttacks:"The gremlin attacks you!",youDied:"You have died.",gameOver:"Game Over.",levelCleared:"Level cleared! You win!",gamePaused:"Game paused. Press ESC to resume.",gameResumed:"Game resumed.",menuNotImplemented:"Menu not implemented yet.",searchingForExit:"Terminal Descent initiated. Searching for exit...",languageSwitched:"Language switched.",playerAttacks:"You attack ",enemyDefeated:"You defeated ",attackModeOn:"Attack mode: Use arrow keys to select attack direction",attackModeOff:"Movement mode",noEnemyThere:"There is no enemy there.",attackMissed:"Your attack on {{enemy}} missed!",criticalHit:"Critical hit! {{enemy}} takes {{damage}} damage! HP: {{health}}/{{maxHealth}}",normalHit:"{{enemy}} takes {{damage}} damage! HP: {{health}}/{{maxHealth}}",experienceGained:"Experience +{{exp}}",levelUp:"Level up! Lv.{{level}}",enemyAttackWithDefense:"{{enemy}} attacks! {{damage}} damage! (Defense -{{defense}}) HP: {{health}}/{{maxHealth}}",enemyAttackNormal:"{{enemy}} attacks! {{damage}} damage! HP: {{health}}/{{maxHealth}}",level:"Level",health:"Health",energy:"Energy",accessLevel:"Access",turn:"Turn",inventoryFull:"Inventory is full.",inventoryEmpty:"Your inventory is empty.",useItem:"You used ",pickedUpItemWithName:"You picked up {{item}}",cannotInteract:"There is nothing to interact with",invalidItem:"Invalid item.",noItemInSlot:"No item in slot {{slot}}.",ironSword:"Iron Sword",battleAxe:"Battle Axe",hunterBow:"Hunter Bow",magicStaff:"Magic Staff",steelDagger:"Steel Dagger",ironHelmet:"Iron Helmet",steelChestplate:"Steel Chestplate",leatherLeggings:"Leather Leggings",combatBoots:"Combat Boots",towerShield:"Tower Shield",healthPotion:"Health Potion",energyBar:"Energy Bar",mysteryScroll:"Mystery Scroll",healingHerb:"Healing Herb",energyCore:"Energy Core",ironSwordDesc:"A standard iron sword",battleAxeDesc:"A powerful battle axe",hunterBowDesc:"A bow for hunting",magicStaffDesc:"A staff that amplifies magic",steelDaggerDesc:"A light and fast dagger",ironHelmetDesc:"Iron head protection",steelChestplateDesc:"Steel chest protection",leatherLeggingsDesc:"Leather leg protection",combatBootsDesc:"Combat boots",towerShieldDesc:"Large defensive shield",healthPotionDesc:"Restores 30 HP",energyBarDesc:"Restores 20 energy",tutorialHealthPotion:"Tutorial Potion",tutorialHealthPotionDesc:"Tutorial healing item (Restores 10 HP)",tutorialSword:"Tutorial Sword",tutorialSwordDesc:"Tutorial practice sword (Attack +3)",mysteryScrollDesc:"Random effect",healingHerbDesc:"Restores 15 HP",energyCoreDesc:"Restores 50 energy",weaponDescriptionFormat:"{{description}} (Damage: {{damage}})",armorDescriptionFormat:"{{description}} (Defense: {{defense}})",inventoryHeader:"=== INVENTORY ===",currentEquipmentHeader:"=== CURRENT EQUIPMENT ===",usageInstructionsHeader:"=== USAGE ===",itemUsageInstructions:"Press number keys (1-9) to use/equip items",itemUsageExample:"Example: Key 1 = Item [1]",effectLabel:"Effect",attackPowerEffect:"Attack +{{damage}}, Accuracy +{{accuracy}}%",defenseEffect:"Defense +{{defense}}",totalDefense:"Total Defense: {{total}}",rightHand:"Right Hand",head:"Head",chest:"Chest",legs:"Legs",feet:"Feet",leftHand:"Left Hand",noEquipment:"(No equipment)",pauseMenuTitle:"Pause Menu",continueGame:"Continue",saveGame:"Save",loadGame:"Load",languageSwitch:"Language",returnToTitle:"Return to Title",descendingToFloor:"Descending to floor {{floor}}...",cannotGoUp:"Cannot go up any further.",returningToFloor:"Returning to floor {{floor}}...",arrivedAtFloor:"Arrived at floor {{floor}}.",healthRestored:"HP+{{amount}} restored!",energyRestored:"Energy+{{amount}} restored!",itemCannotBeUsed:"{{item}} cannot be used.",weaponEquipped:"{{weapon}} equipped.",armorEquipped:"{{armor}} equipped.",cannotEquipWeapon:"Cannot equip weapon.",cannotEquipArmor:"Cannot equip armor.",noEnemyInThatDirection:"No enemy there.",movementMode:"Movement mode",stairsAppeared:"Stairs to next floor appeared! (Press F to move)",allFloorsCleared:"All floors cleared! Congratulations!",welcomeToFacility:"Welcome to Night City underground facility. Aim for escape.",tutorialStarted:"Tutorial started.",tutorialComplete:"🎉 Tutorial complete! Game start!",settingsUnderDevelopment:"Settings menu is under development.",mysteryScrollHealth:"HP recovery effect activated!",mysteryScrollEnergy:"Energy recovery effect activated!",mysteryScrollScore:"Score bonus +50!",mysteryScrollMap:"Map exploration effect activated!",tutorialWelcome:"Welcome to Terminal Descent! Use WASD keys to move.",tutorialMovement:"Well done! You can move freely with WASD. Try exploring a bit more.",tutorialCombat:"You can switch to attack mode with Space key. Try it!",tutorialInventory:"Press I key to open inventory and check items.",tutorialEquipment:"Use number keys (1-9) to use items. Try using an item!",tutorialCompleted:"Tutorial complete! You have learned all functions.",tutorialProgressMovement:"✓ Movement mastered!",tutorialProgressCombat:"✓ Next, let's learn the combat system.",tutorialProgressCombatComplete:"✓ Combat basics understood!",tutorialProgressInventory:"✓ Inventory usage learned!",tutorialProgressEquipment:"✓ Equipment system perfect!",attackPowerLabel:"Attack Power",defenseLabel:"Defense",experienceLabel:"Experience",closeInstruction:"Press number keys (1-9) to use items | Press I to close",statusHeader:"=== STATUS ===",statusCloseInstruction:"Press S to close",equipmentHeader:"=== EQUIPMENT ===",equipmentStatsHeader:"=== EQUIPMENT STATS ===",totalDefenseLabel:"Total Defense",welcomeTitle:"TERMINAL DESCENT",welcomeSubtitle:"Escape from Night City underground facility",menuInstructions:"↑↓ or WS: Select    Enter or F: Confirm",prologueLines:["The year is 2087. In an underground research facility","in Night City, you wake up.","","Security systems have gone haywire, and the facility is sealed.","To survive, you must escape to the surface.","","Gather equipment, avoid enemies, and escape from","10 underground levels.","","[Press Enter to start]"],menuOptions:["[Start] Begin game","[Tutorial] Learn controls","[Settings] Options"],emptyInventoryMessage:"Inventory is empty",weaponSlot:"Weapon",headSlot:"Head",chestSlot:"Chest",legsSlot:"Legs",feetSlot:"Feet",shieldSlot:"Shield",noItem:"None",gremlin:"Gremlin",goblin:"Goblin",orc:"Orc",troll:"Troll",takeoffHeader:"=== Remove Equipment ===",takeoffInstruction:"Select equipment to remove",takeoffControls:"↑↓ keys: Select | Enter: Remove | T key: Close",noEquipmentToRemove:"No equipment to remove.",weaponUnequipped:"{{weapon}} unequipped.",armorUnequipped:"{{armor}} unequipped."}};class Y{currentLanguage="ja";setLanguage(e){this.currentLanguage=e}getCurrentLanguage(){return this.currentLanguage}getMessage(e){return F[this.currentLanguage][e]}getMessages(){return F[this.currentLanguage]}}const b=new Y,r=l=>{const e=b.getMessage(l);return Array.isArray(e)?e.join(`
`):e},N=l=>{const e=b.getMessage(l);return Array.isArray(e)?e:[e]};function d(l){return l.nameKey?r(l.nameKey):l.name}function z(l){if(l.descriptionKey){const e=r(l.descriptionKey);return l.itemType==="weapon"&&l.descriptionParams?.damage!==void 0?r("weaponDescriptionFormat").replace("{{description}}",e).replace("{{damage}}",String(l.descriptionParams.damage)):l.itemType==="armor"&&l.descriptionParams?.defense!==void 0?r("armorDescriptionFormat").replace("{{description}}",e).replace("{{defense}}",String(l.descriptionParams.defense)):e}return l.description}function X(l){const e=l.equipment;console.log("=== formatEquipmentSlots DEBUG ==="),console.log("Player equipment object:",e),console.log("MainHand:",e.mainHand),console.log("Head:",e.head),console.log("Chest:",e.chest),console.log("Legs:",e.legs),console.log("Feet:",e.feet),console.log("OffHand:",e.offHand);const t={weapon:e.mainHand?d(e.mainHand):r("noItem"),head:e.head?d(e.head):r("noItem"),chest:e.chest?d(e.chest):r("noItem"),legs:e.legs?d(e.legs):r("noItem"),feet:e.feet?d(e.feet):r("noItem"),shield:e.offHand?d(e.offHand):r("noItem")};return console.log("Formatted equipment slots:",t),console.log("=== formatEquipmentSlots END ==="),t}function j(l){let e=0;return["head","chest","legs","feet","offHand"].forEach(s=>{const a=l.equipment[s];a&&"defense"in a&&(e+=a.defense)}),e}function J(l){const t=l.equipment.mainHand;return 10+(t&&"damage"in t?t.damage:0)}function L(l){const e=j(l),t=J(l),s=Object.values(l.equipment).filter(a=>a!==void 0).length;return{totalDefense:e,attackPower:t,equipmentCount:s}}function Q(l){return"key"in l}function Z(l){if(typeof l=="string")return l;if(Q(l)){let e=r(l.key);return l.params&&Object.entries(l.params).forEach(([t,s])=>{const a=`{{${t}}}`;e=e.replace(a,String(s))}),e}else return l.text}function g(l,e){const t={key:l,timestamp:Date.now()};return e&&(t.params=e),t}function $(l){return{text:l,timestamp:Date.now()}}function k(){return Math.random().toString(36).substring(2)+Date.now().toString(36)}function x(l,e){return l.x>=0&&l.x<e.width&&l.y>=0&&l.y<e.height}function ee(l){switch(l){case"north":return{x:0,y:-1};case"south":return{x:0,y:1};case"east":return{x:1,y:0};case"west":return{x:-1,y:0}}}function te(l,e){return{x:l.x+e.x,y:l.y+e.y}}function M(l,e){return Math.floor(Math.random()*(e-l+1))+l}function C(l){return l[Math.floor(Math.random()*l.length)]}function q(l){const t={g:"gremlin",G:"goblin",o:"orc",T:"troll"}[l.char];return t?r(t):l.char}class se{player;constructor(e){this.player=this.createPlayer(e)}createPlayer(e){return{id:k(),position:{...e},char:"@",color:"#00ff00",type:"player",blocking:!0,visible:!0,level:1,experience:0,experienceToNext:100,health:100,maxHealth:100,energy:100,maxEnergy:100,accessLevel:1,inventory:[],equipment:{}}}getPlayer(){return{...this.player}}getPlayerDirect(){return this.player}getPosition(){return{...this.player.position}}setPosition(e){this.player.position={...e}}move(e){const t=ee(e);return te(this.player.position,t)}confirmMove(e){this.player.position={...e}}takeDamage(e){this.player.health=Math.max(0,this.player.health-e)}heal(e){this.player.health=Math.min(this.player.maxHealth,this.player.health+e)}useEnergy(e){return this.player.energy>=e?(this.player.energy-=e,!0):!1}restoreEnergy(e){this.player.energy=Math.min(this.player.maxEnergy,this.player.energy+e)}isAlive(){return this.player.health>0}isDead(){return this.player.health<=0}addItem(e){if(e.stackable){const t=this.player.inventory.find(s=>s.name===e.name&&s.itemType===e.itemType);if(t)return t.quantity+=e.quantity,!0}return this.player.inventory.length<20?(this.player.inventory.push({...e}),!0):!1}removeItem(e,t=1){const s=this.player.inventory.findIndex(i=>i.id===e);if(s===-1)return null;const a=this.player.inventory[s];return a.quantity<=t?(this.player.inventory.splice(s,1),a):(a.quantity-=t,{...a,id:k(),quantity:t})}getInventory(){return[...this.player.inventory]}findItem(e){return this.player.inventory.find(s=>s.id===e)||null}hasItem(e){return this.player.inventory.some(t=>t.id===e)}calculateExperienceToNext(e){return Math.floor(100*Math.pow(1.5,e-1))}addExperience(e){this.player.experience+=e;let t=!1;for(;this.player.experience>=this.player.experienceToNext;)this.player.experience-=this.player.experienceToNext,this.levelUp(),t=!0;return t}levelUp(){this.player.level++,this.player.experienceToNext=this.calculateExperienceToNext(this.player.level),this.player.maxHealth+=10,this.player.maxEnergy+=5,this.player.health=this.player.maxHealth,this.player.energy=this.player.maxEnergy}increaseAccessLevel(){this.player.accessLevel++}getStats(){return{level:this.player.level,experience:this.player.experience,experienceToNext:this.player.experienceToNext,experienceProgress:Math.floor(this.player.experience/this.player.experienceToNext*100),health:this.player.health,maxHealth:this.player.maxHealth,energy:this.player.energy,maxEnergy:this.player.maxEnergy,accessLevel:this.player.accessLevel,inventoryCount:this.player.inventory.length}}serialize(){return JSON.stringify(this.player)}deserialize(e){try{const t=JSON.parse(e);if(typeof t.level=="number"&&typeof t.health=="number"&&typeof t.maxHealth=="number"&&typeof t.position=="object"&&typeof t.position.x=="number"&&typeof t.position.y=="number")this.player={...t};else throw new Error("Invalid player data format")}catch(t){console.error("Failed to deserialize player data:",t),this.player=this.createPlayer({x:0,y:0})}}reset(e){this.player=this.createPlayer(e)}equipWeapon(e){return console.log("=== PlayerController.equipWeapon START ==="),console.log("Weapon to equip:",e),console.log("Current equipment before:",this.player.equipment),this.player.equipment.mainHand&&(console.log("Previous weapon exists, returning to inventory:",this.player.equipment.mainHand),this.addItem(this.player.equipment.mainHand)),this.player.equipment.mainHand=e,console.log("Weapon equipped to mainHand"),console.log("Current equipment after:",this.player.equipment),console.log("=== PlayerController.equipWeapon END ==="),!0}unequipWeapon(){const e=this.player.equipment.mainHand;return e?(delete this.player.equipment.mainHand,e):null}getEquippedWeapon(){return this.player.equipment.mainHand||null}equipArmor(e){const t=e.slot;if(t==="mainHand"||t==="accessory")return!1;const s=this.player.equipment[t];return s&&this.addItem(s),this.player.equipment[t]=e,!0}unequipArmor(e){if(e==="mainHand"||e==="accessory")return null;const t=this.player.equipment[e];return t?(delete this.player.equipment[e],t):null}getEquippedArmor(e){return e==="mainHand"||e==="accessory"?null:this.player.equipment[e]||null}getTotalDefense(){let e=0;const t=["offHand","head","chest","legs","feet"];for(const s of t){const a=this.getEquippedArmor(s);a&&(e+=a.defense)}return e}getAttackDamage(){const e=this.player.equipment.mainHand,t=10;return e?t+e.damage:t}getAttackAccuracy(){const e=this.player.equipment.mainHand,t=80;return e?Math.min(95,t+e.accuracy):t}getCriticalChance(){const e=this.player.equipment.mainHand,t=5;return e?Math.min(50,t+e.criticalChance):t}rollAttackHit(){const e=this.getAttackAccuracy();return Math.random()*100<e}rollCriticalHit(){const e=this.getCriticalChance();return Math.random()*100<e}rollDamage(){const e=this.getAttackDamage(),t=this.rollCriticalHit();return{damage:t?Math.floor(e*1.5):e,isCritical:t}}}class w{dimensions;level;constructor(e,t=1){this.dimensions=e,this.level=t}generate(e){const t=this.createEmptyTiles(),s=this.generateRooms();if(s.forEach(i=>this.carveRoom(t,i)),this.connectRooms(t,s),s.length>0){const i=s[0];e.position={x:i.position.x+Math.floor(i.dimensions.width/2),y:i.position.y+Math.floor(i.dimensions.height/2)},console.log(`Player placed at (${e.position.x},${e.position.y}) in room at (${i.position.x},${i.position.y})`),console.log(`Generated ${s.length} rooms`)}else console.error("No rooms generated! Player will be stuck in walls.");const a=this.generateEntities(s,e.position);return a.push(e),{level:this.level,dimensions:this.dimensions,tiles:t,rooms:s,entities:a,player:e}}createEmptyTiles(){const e=[];for(let t=0;t<this.dimensions.height;t++){e[t]=[];for(let s=0;s<this.dimensions.width;s++)e[t][s]=this.createWallTile({x:s,y:t})}return e}createWallTile(e){return{position:{...e},type:"wall",char:"#",color:"#444444",backgroundColor:"#000000",blocking:!0,explored:!1,visible:!1}}createFloorTile(e){return{position:{...e},type:"floor",char:".",color:"#666666",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1}}generateRooms(){const e=[];for(let o=0;o<50&&e.length<8;o++){const n=M(4,10),c=M(4,10),h=M(1,this.dimensions.width-n-1),p=M(1,this.dimensions.height-c-1),u={position:{x:h,y:p},dimensions:{width:n,height:c},tiles:[],connected:!1};e.some(f=>this.roomsOverlap(u,f))||e.push(u)}return e}roomsOverlap(e,t){return!(e.position.x+e.dimensions.width+1<t.position.x||t.position.x+t.dimensions.width+1<e.position.x||e.position.y+e.dimensions.height+1<t.position.y||t.position.y+t.dimensions.height+1<e.position.y)}carveRoom(e,t){for(let s=t.position.y;s<t.position.y+t.dimensions.height;s++)for(let a=t.position.x;a<t.position.x+t.dimensions.width;a++)x({x:a,y:s},this.dimensions)&&(e[s][a]=this.createFloorTile({x:a,y:s}))}connectRooms(e,t){if(t.length<2)return;for(let a=0;a<t.length-1;a++){const i=t[a],o=t[a+1];this.createCorridor(e,i,o),i.connected=!0,o.connected=!0}const s=Math.floor(t.length/3);for(let a=0;a<s;a++){const i=C(t),o=C(t);i!==o&&this.createCorridor(e,i,o)}}createCorridor(e,t,s){const a={x:t.position.x+Math.floor(t.dimensions.width/2),y:t.position.y+Math.floor(t.dimensions.height/2)},i={x:s.position.x+Math.floor(s.dimensions.width/2),y:s.position.y+Math.floor(s.dimensions.height/2)};M(0,1)===0?(this.carveHorizontalCorridor(e,a.x,i.x,a.y),this.carveVerticalCorridor(e,i.x,a.y,i.y)):(this.carveVerticalCorridor(e,a.x,a.y,i.y),this.carveHorizontalCorridor(e,a.x,i.x,i.y))}carveHorizontalCorridor(e,t,s,a){const i=Math.min(t,s),o=Math.max(t,s);for(let n=i;n<=o;n++)x({x:n,y:a},this.dimensions)&&(e[a][n]=this.createFloorTile({x:n,y:a}))}carveVerticalCorridor(e,t,s,a){const i=Math.min(s,a),o=Math.max(s,a);for(let n=i;n<=o;n++)x({x:t,y:n},this.dimensions)&&(e[n][t]=this.createFloorTile({x:t,y:n}))}generateEntities(e,t){const s=[],a=e.slice(1);a.forEach(h=>{const p=Math.min(.3+this.level*.05,.7);if(Math.random()<p){const m=this.createEnemy(h);s.push(m)}const u=Math.min(.2+this.level*.02,.4);if(Math.random()<u){const m=this.createItem(h);s.push(m)}});const i=s.filter(h=>h.type==="enemy").length,o=Math.max(1,Math.floor(a.length/3));if(i<o){const h=a.filter(u=>!s.some(m=>m.type==="enemy"&&m.position.x>=u.position.x&&m.position.x<u.position.x+u.dimensions.width&&m.position.y>=u.position.y&&m.position.y<u.position.y+u.dimensions.height)),p=o-i;for(let u=0;u<p&&u<h.length;u++){const m=h[u],f=this.createEnemy(m);s.push(f)}}const n=s.filter(h=>h.type==="item").length,c=Math.max(1,Math.floor(a.length/4));if(n<c){const h=a.filter(u=>!s.some(m=>m.type==="item"&&m.position.x>=u.position.x&&m.position.x<u.position.x+u.dimensions.width&&m.position.y>=u.position.y&&m.position.y<u.position.y+u.dimensions.height)),p=c-n;for(let u=0;u<p&&u<h.length;u++){const m=h[u],f=this.createItem(m);s.push(f)}}return s}createEnemy(e){const t=M(e.position.x+1,e.position.x+e.dimensions.width-2),s=M(e.position.y+1,e.position.y+e.dimensions.height-2),a=20,i=5,o=Math.floor(this.level*1.5),n=Math.floor(this.level*.8),c=a+o,h=i+n,p=this.getEnemyTypes(),u=C(p);return{id:`enemy_${Date.now()}_${Math.random()}`,position:{x:t,y:s},char:u.char,color:u.color,type:"enemy",blocking:!0,visible:!0,health:c,maxHealth:c,damage:h,aiType:"aggressive"}}getEnemyTypes(){const e=[{char:"G",color:"#ff4444",name:"Gremlin"},{char:"R",color:"#8b4513",name:"Rat"},{char:"S",color:"#32cd32",name:"Slime"}],t=[{char:"O",color:"#ff6600",name:"Orc"},{char:"T",color:"#daa520",name:"Troll"},{char:"W",color:"#483d8b",name:"Wraith"}],s=[{char:"D",color:"#dc143c",name:"Dragon"},{char:"L",color:"#8b008b",name:"Lich"},{char:"M",color:"#ff1493",name:"Minotaur"}];return this.level<=3?e:this.level<=6?[...e,...t]:[...e,...t,...s]}createItem(e){const t=M(e.position.x+1,e.position.x+e.dimensions.width-2),s=M(e.position.y+1,e.position.y+e.dimensions.height-2),a=Math.random();return a<.25?this.createWeapon(t,s):a<.45?this.createArmor(t,s):this.createConsumable(t,s)}createWeapon(e,t){const s=[{char:")",color:"#cccccc",nameKey:"ironSword",descKey:"ironSwordDesc",weaponType:"sword",damage:8+Math.floor(this.level*1.2),accuracy:10,criticalChance:5,range:1},{char:"/",color:"#8b4513",nameKey:"battleAxe",descKey:"battleAxeDesc",weaponType:"axe",damage:12+Math.floor(this.level*1.5),accuracy:5,criticalChance:8,range:1},{char:"}",color:"#654321",nameKey:"hunterBow",descKey:"hunterBowDesc",weaponType:"bow",damage:6+Math.floor(this.level*1),accuracy:15,criticalChance:10,range:3},{char:"\\",color:"#4b0082",nameKey:"magicStaff",descKey:"magicStaffDesc",weaponType:"staff",damage:5+Math.floor(this.level*.8),accuracy:12,criticalChance:3,range:2},{char:"-",color:"#a9a9a9",nameKey:"steelDagger",descKey:"steelDaggerDesc",weaponType:"dagger",damage:4+Math.floor(this.level*.7),accuracy:20,criticalChance:15,range:1}],a=C(s);let i;return this.level>=3&&Math.random()<.3&&(i={type:C(["fire","ice","poison","stun","vampire"]),chance:15+Math.floor(this.level*2),value:Math.floor(this.level*1.5)}),{id:k(),position:{x:e,y:t},char:a.char,color:a.color,type:"item",blocking:!1,visible:!0,name:r(a.nameKey),nameKey:a.nameKey,description:`${r(a.descKey)} (攻撃力: ${a.damage})`,descriptionKey:a.descKey,descriptionParams:{damage:a.damage},stackable:!1,quantity:1,itemType:"weapon",weaponType:a.weaponType,damage:a.damage,accuracy:a.accuracy,criticalChance:a.criticalChance,range:a.range,...i&&{special:i}}}createArmor(e,t){const s=[{char:"[",color:"#8b4513",nameKey:"ironHelmet",descKey:"ironHelmetDesc",armorType:"helmet",slot:"head",defense:3+Math.floor(this.level*.8)},{char:"]",color:"#c0c0c0",nameKey:"steelChestplate",descKey:"steelChestplateDesc",armorType:"chestplate",slot:"chest",defense:5+Math.floor(this.level*1.2)},{char:"{",color:"#a0522d",nameKey:"leatherLeggings",descKey:"leatherLeggingsDesc",armorType:"leggings",slot:"legs",defense:4+Math.floor(this.level*1)},{char:"(",color:"#654321",nameKey:"combatBoots",descKey:"combatBootsDesc",armorType:"boots",slot:"feet",defense:2+Math.floor(this.level*.6)},{char:"&",color:"#8b7355",nameKey:"towerShield",descKey:"towerShieldDesc",armorType:"shield",slot:"offHand",defense:6+Math.floor(this.level*1.5)}],a=C(s),i=50+Math.floor(this.level*10);return{id:k(),position:{x:e,y:t},char:a.char,color:a.color,type:"item",blocking:!1,visible:!0,name:r(a.nameKey),nameKey:a.nameKey,description:`${r(a.descKey)} (防御力: ${a.defense})`,descriptionKey:a.descKey,descriptionParams:{defense:a.defense},stackable:!1,quantity:1,itemType:"armor",armorType:a.armorType,defense:a.defense,durability:i,maxDurability:i,slot:a.slot}}createConsumable(e,t){const a=C([{char:"!",color:"#ffff00",nameKey:"healthPotion",descKey:"healthPotionDesc"},{char:"%",color:"#ff8800",nameKey:"energyBar",descKey:"energyBarDesc"},{char:"?",color:"#8800ff",nameKey:"mysteryScroll",descKey:"mysteryScrollDesc"},{char:"+",color:"#00ffff",nameKey:"healingHerb",descKey:"healingHerbDesc"},{char:"*",color:"#ff00ff",nameKey:"energyCore",descKey:"energyCoreDesc"}]);return{id:k(),position:{x:e,y:t},char:a.char,color:a.color,type:"item",blocking:!1,visible:!0,name:r(a.nameKey),nameKey:a.nameKey,description:r(a.descKey),descriptionKey:a.descKey,stackable:!0,quantity:1,itemType:"consumable"}}static updateFieldOfView(e,t,s=8){for(let a=0;a<e.dimensions.height;a++)for(let i=0;i<e.dimensions.width;i++)e.tiles[a][i].visible=!1;for(let a=-s;a<=s;a++)for(let i=-s;i<=s;i++){const o=t.x+i,n=t.y+a;if(x({x:o,y:n},e.dimensions)&&Math.sqrt(i*i+a*a)<=s){const h=e.tiles[n][o];h.visible=!0,h.explored=!0}}}}const P={MAP_DIMENSIONS:{width:72,height:30},ROOM_DIMENSIONS:{width:8,height:6,spacing:12},getWelcomeRoomPosition(){return{x:2,y:Math.floor(this.MAP_DIMENSIONS.height/2)-Math.floor(this.ROOM_DIMENSIONS.height/2)}},getMovementTargetPosition(){const l=this.getWelcomeRoomPosition();return{x:l.x+Math.floor(this.ROOM_DIMENSIONS.width/2),y:l.y+Math.floor(this.ROOM_DIMENSIONS.height/2)}},getPlayerStartPosition(){const l=this.getWelcomeRoomPosition();return{x:l.x+2,y:l.y+2}}};var S=(l=>(l.NOT_STARTED="not_started",l.IN_PROGRESS="in_progress",l.COMPLETED="completed",l.SKIPPED="skipped",l))(S||{}),E=(l=>(l.PENDING="pending",l.ACTIVE="active",l.COMPLETED="completed",l.BLOCKED="blocked",l))(E||{});class A{constructor(e,t,s,a,i,o,n=[]){this.id=e,this.title=t,this.description=s,this.blockedActions=n,this.hint=a||"",this.targetAction=i||"",o&&(this.targetPosition=o)}state=E.PENDING;hint;targetAction;targetPosition;isActionAllowed(e){return!this.blockedActions.includes(e)}}class ae extends A{constructor(){super("step_movement","移動の練習","WASDキーを使って、マーカーの位置まで移動してください。","W:上, A:左, S:下, D:右","movement",P.getMovementTargetPosition(),["inventory","equipment","status"])}checkCompletion(e){const t=e.gameState.player,s=this.targetPosition;return s?t.position.x===s.x&&t.position.y===s.y:!1}}class ie extends A{itemsUsedCount=0;requiredItemCount=2;constructor(){super("step_item_pickup","アイテムの使用","Fキーでアイテムを拾い、Iキーでインベントリを開いて使用してください。","ポーションを使うと体力が回復します","item_use",void 0,["equipment"])}checkCompletion(e){return this.itemsUsedCount>=this.requiredItemCount}markItemUsed(){this.itemsUsedCount++,console.log(`[Tutorial] Item used: ${this.itemsUsedCount}/${this.requiredItemCount}`),this.itemsUsedCount===1?this.description="よくできました！もう1つのポーションも使ってみましょう。":this.itemsUsedCount>=this.requiredItemCount&&(this.description="素晴らしい！アイテムの使い方をマスターしました。")}}class oe extends A{currentSequenceIndex=0;sequence=[{id:"pickup",completed:!1},{id:"open_equipment",completed:!1},{id:"open_takeoff",completed:!1},{id:"unequip",completed:!1}];constructor(){super("step_equipment","装備の管理","武器を拾って装備し、その後外してみましょう。","F:拾う, E:装備画面, T:着脱画面","equipment",void 0,[])}checkCompletion(e){return this.sequence.every(t=>t.completed)}advanceSequence(e){const t=this.sequence[this.currentSequenceIndex];if(t)switch(e){case"pickup":t.id==="pickup"&&(t.completed=!0,this.currentSequenceIndex++);break;case"open_equipment":t.id==="open_equipment"&&(t.completed=!0,this.currentSequenceIndex++);break;case"open_takeoff":t.id==="open_takeoff"&&(t.completed=!0,this.currentSequenceIndex++);break;case"unequip":t.id==="unequip"&&(t.completed=!0,this.currentSequenceIndex++);break}}getCurrentAction(){const e=this.sequence[this.currentSequenceIndex];return e&&{pickup:"Fキーで武器を拾ってください",open_equipment:"Eキーで装備画面を開いてください",open_takeoff:"Tキーで着脱画面を開いてください",unequip:"装備を外してください"}[e.id]||""}}class ne extends A{combatCompleted=!1;constructor(){super("step_combat","戦闘の基本","Spaceキーで攻撃モードに切り替え、敵を倒してください。","攻撃モード中は移動で攻撃します","combat",void 0,[])}checkCompletion(e){return this.combatCompleted}markCombatCompleted(){this.combatCompleted=!0}}class re extends A{statusViewed=!1;constructor(){super("step_character_status","ステータスの確認","Cキーを押してキャラクターのステータスを確認してください。","ステータス画面で詳細な情報を見ることができます","status",void 0,[])}checkCompletion(e){return this.statusViewed}markStatusViewed(){this.statusViewed=!0}}class y{static movementStep=null;static itemPickupStep=null;static equipmentStep=null;static combatStep=null;static statusStep=null;createMovementStep(){return y.movementStep||(y.movementStep=new ae),y.movementStep}createItemPickupStep(){return y.itemPickupStep||(y.itemPickupStep=new ie),y.itemPickupStep}createEquipmentStep(){return y.equipmentStep||(y.equipmentStep=new oe),y.equipmentStep}createCombatStep(){return y.combatStep||(y.combatStep=new ne),y.combatStep}createStatusStep(){return y.statusStep||(y.statusStep=new re),y.statusStep}createAllSteps(){return[this.createMovementStep(),this.createItemPickupStep(),this.createEquipmentStep(),this.createCombatStep(),this.createStatusStep()]}static notifyAction(e,t){switch(e){case"step_item_pickup":t==="item_use"&&this.itemPickupStep&&this.itemPickupStep.markItemUsed();break;case"step_equipment":this.equipmentStep&&this.equipmentStep.advanceSequence(t);break;case"step_combat":t==="combat_complete"&&this.combatStep&&this.combatStep.markCombatCompleted();break;case"step_character_status":t==="status_view"&&this.statusStep&&this.statusStep.markStatusViewed();break}}}class U{enableHints=!0;hintDelay=1e4;autoAdvance=!1;debugMode=!1;steps;get totalSteps(){return this.steps.length}constructor(){const e=new y;this.steps=e.createAllSteps()}getStepIndex(e){return this.steps.findIndex(t=>t.id===e)}getStep(e){return this.steps.find(t=>t.id===e)||null}getTotalSteps(){return this.steps.length}setDebugMode(e){this.debugMode=e}updateHintSettings(e,t){this.enableHints=e,t!==void 0&&(this.hintDelay=t)}}class le{dimensions;constructor(e=P.MAP_DIMENSIONS){this.dimensions=e}getRoomConfigForStep(e){return{step_movement:{type:"movement"},step_item_pickup:{type:"items"},step_equipment:{type:"equipment"},step_combat:{type:"combat"},step_character_status:{type:"status"}}[e]||{type:"movement"}}generate(e){const t=this.createEmptyTiles(),s=this.generateTutorialRooms();if(s.forEach(i=>this.carveRoom(t,i)),this.connectRoomsLinear(t,s),s.length>0){const i=P.getPlayerStartPosition();e.position={...i},console.log(`Player positioned at (${i.x}, ${i.y}) using TUTORIAL_CONSTANTS`)}const a=this.generateTutorialEntities(s);return a.push(e),{level:0,dimensions:this.dimensions,tiles:t,rooms:s,entities:a,player:e}}createEmptyTiles(){const e=[];for(let t=0;t<this.dimensions.height;t++){e[t]=[];for(let s=0;s<this.dimensions.width;s++)e[t][s]=this.createWallTile({x:s,y:t})}return e}createWallTile(e){return{position:{...e},type:"wall",char:"#",color:"#444444",backgroundColor:"#000000",blocking:!0,explored:!1,visible:!1}}createFloorTile(e){return{position:{...e},type:"floor",char:".",color:"#666666",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1}}createDoorTile(e,t=!1){return{position:{...e},type:"door",char:t?" ":"|",color:t?"#666666":"#ff8800",backgroundColor:"#000000",blocking:!t,explored:!1,visible:!1}}generateTutorialRooms(){const e=[],{width:t,height:s,spacing:a}=P.ROOM_DIMENSIONS;return new U().steps.map((n,c)=>({stepType:n.id,roomConfig:this.getRoomConfigForStep(n.id)})).forEach((n,c)=>{let h,p;if(c===0){const m=P.getWelcomeRoomPosition();h=m.x,p=m.y,console.log(`Welcome room positioned at (${h}, ${p}) using TUTORIAL_CONSTANTS`)}else{const m=P.getWelcomeRoomPosition();h=m.x+c*a,p=m.y,console.log(`Room ${c} positioned at (${h}, ${p}) relative to welcome room`)}const u={position:{x:h,y:p},dimensions:{width:t,height:s},tiles:[],connected:!1,tutorialStep:{id:n.stepType,type:n.roomConfig.type,required:!0}};e.push(u)}),e}carveRoom(e,t){for(let s=t.position.y;s<t.position.y+t.dimensions.height;s++)for(let a=t.position.x;a<t.position.x+t.dimensions.width;a++)x({x:a,y:s},this.dimensions)&&(e[s][a]=this.createFloorTile({x:a,y:s}))}connectRoomsLinear(e,t){for(let s=0;s<t.length-1;s++){const a=t[s],i=t[s+1],o=a.position.x+a.dimensions.width,n=i.position.x,c=a.position.y+Math.floor(a.dimensions.height/2);for(let u=o;u<n;u++)x({x:u,y:c},this.dimensions)&&(e[c][u]=this.createFloorTile({x:u,y:c}));const h=i.position.x-1,p=c;x({x:h,y:p},this.dimensions)&&(e[p][h]=this.createDoorTile({x:h,y:p},!1)),a.connected=!0}t.length>0&&(t[t.length-1].connected=!0)}generateTutorialEntities(e){const t=[];return e.forEach((s,a)=>{if(!s.tutorialStep)return;const i=s.tutorialStep;switch(i.type||i){case"movement":break;case"items":const n=this.createTutorialItem(s,"health-potion"),c=this.createTutorialItem(s,"health-potion");c.position.x+=2,t.push(n,c);break;case"combat":t.push(this.createTutorialEnemy(s));break;case"equipment":t.push(this.createTutorialItem(s,"weapon"));break}}),t}createTutorialEnemy(e){const t=e.position.x+Math.floor(e.dimensions.width/2),s=e.position.y+Math.floor(e.dimensions.height/2);return{id:k(),position:{x:t,y:s},char:"g",color:"#ff4444",type:"enemy",blocking:!0,visible:!0,health:25,maxHealth:25,damage:2,aiType:"passive"}}createTutorialItem(e,t){const s=e.position.x+Math.floor(e.dimensions.width/2),a=e.position.y+Math.floor(e.dimensions.height/2),i={id:k(),position:{x:s,y:a},type:"item",blocking:!1,visible:!0,stackable:!0,quantity:1,itemType:"consumable"};switch(t){case"health-potion":return{...i,char:"!",color:"#ff0000",name:"チュートリアル回復薬",description:"HP回復の練習用",stackable:!0,quantity:1,itemType:"consumable"};case"weapon":return{...i,char:"/",color:"#ffff00",name:"トレーニング剣",description:"装備練習用の木剣",stackable:!1,quantity:1,itemType:"weapon",weaponType:"sword",damage:3,accuracy:10,criticalChance:5,range:1};default:return{...i,char:"?",color:"#ffffff",name:"チュートリアルアイテム",description:"練習用アイテム"}}}getRoomByStep(e,t){return e.find(s=>s.tutorialStep===t)}openDoorToNextRoom(e,t,s){const a=s.position.x-1,i=t.position.y+Math.floor(t.dimensions.height/2);x({x:a,y:i},this.dimensions)&&(e[i][a]=this.createDoorTile({x:a,y:i},!0))}}class ce{data;generator;tutorialGenerator;constructor(){this.data={floors:new Map,currentFloor:1,maxFloor:1},this.generator=new w({width:80,height:50},1),this.tutorialGenerator=new le}getDungeonData(){return{floors:new Map(this.data.floors),currentFloor:this.data.currentFloor,maxFloor:this.data.maxFloor}}getCurrentDungeon(){return this.data.floors.get(this.data.currentFloor)}generateTutorialDungeon(e){const t=this.tutorialGenerator.generate(e);return this.data.floors.set(0,t),this.data.currentFloor=0,t}generateInitialFloor(e){this.generator=new w({width:80,height:50},1);const t=this.generator.generate(e);if(t.rooms.length>0){const s=t.rooms[t.rooms.length-1];t.stairsDown={x:s.position.x+Math.floor(s.dimensions.width/2),y:s.position.y+Math.floor(s.dimensions.height/2)};const a=t.stairsDown;t.tiles[a.y]&&t.tiles[a.y][a.x]&&(t.tiles[a.y][a.x]={position:{...a},type:"stairs",char:">",color:"#ffff00",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1})}return this.data.floors.set(1,t),this.data.currentFloor=1,this.data.maxFloor=1,t}moveToFloor(e,t){if(!this.data.floors.has(e)){this.generator=new w({width:80,height:50},e);const i=this.generator.generate(t);if(e>1&&i.rooms.length>0){const o=i.rooms[0];i.stairsUp={x:o.position.x+Math.floor(o.dimensions.width/2),y:o.position.y+Math.floor(o.dimensions.height/2)};const n=i.stairsUp;i.tiles[n.y]&&i.tiles[n.y][n.x]&&(i.tiles[n.y][n.x]={position:{...n},type:"stairs",char:"<",color:"#ffff00",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1})}if(e<10&&i.rooms.length>0){const o=i.rooms[i.rooms.length-1];i.stairsDown={x:o.position.x+Math.floor(o.dimensions.width/2),y:o.position.y+Math.floor(o.dimensions.height/2)};const n=i.stairsDown;i.tiles[n.y]&&i.tiles[n.y][n.x]&&(i.tiles[n.y][n.x]={position:{...n},type:"stairs",char:">",color:"#ffff00",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1})}this.data.floors.set(e,i),e>this.data.maxFloor&&(this.data.maxFloor=e)}const s=this.data.floors.get(e),a=this.data.currentFloor;if(this.data.currentFloor=e,e>a&&s.stairsUp?t.position={...s.stairsUp}:e<a&&s.stairsDown&&(t.position={...s.stairsDown}),t.position){const i=s.tiles[t.position.y]?.[t.position.x];(!i||i.blocking)&&(t.position=this.findNearestValidPosition(s,t.position))}return s}findNearestValidPosition(e,t){for(let s=1;s<=5;s++)for(let a=-s;a<=s;a++)for(let i=-s;i<=s;i++){if(Math.abs(a)!==s&&Math.abs(i)!==s)continue;const o={x:t.x+a,y:t.y+i};if(o.x<0||o.x>=e.dimensions.width||o.y<0||o.y>=e.dimensions.height)continue;const n=e.tiles[o.y]?.[o.x];if(n&&!n.blocking)return o}return t}hasStairsAt(e){const t=this.getCurrentDungeon();return t?t.stairsUp&&t.stairsUp.x===e.x&&t.stairsUp.y===e.y?"up":t.stairsDown&&t.stairsDown.x===e.x&&t.stairsDown.y===e.y?"down":null:null}getCurrentFloor(){return this.data.currentFloor}getMaxFloor(){return this.data.maxFloor}saveDungeonState(e){this.data.floors.set(this.data.currentFloor,{...e})}}class v{constructor(e,t,s,a,i,o,n,c,h){this.gameState=e,this.playerController=t,this.addMessage=s,this.processTurn=a,this.updateTutorialProgress=i,this.equipItem=o,this.getCurrentEquipmentDisplay=n,this.addMessages=c,this.notifyEquipmentToggle=h}static ITEM_EFFECTS={HEALTH_POTION:30,HEALING_HERB:15,ENERGY_BAR:20,ENERGY_CORE:50,MYSTERY_SCROLL_HEALTH:20,MYSTERY_SCROLL_ENERGY:30,MYSTERY_SCROLL_SCORE:50};showInventory(){if(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")return;const e=this.playerController.getPlayer().inventory,t=[];t.push(r("inventoryHeader")),e.length===0?t.push(r("inventoryEmpty")):e.forEach((s,a)=>{const i=d(s),o=z(s);if(t.push(`[${a+1}] ${s.char} ${i} x${s.quantity}`),t.push(`     ${o}`),s.itemType==="weapon"){const n=s,c=r("attackPowerEffect").replace("{{damage}}",String(n.damage)).replace("{{accuracy}}",String(n.accuracy));t.push(`      ${r("effectLabel")}: ${c}`)}else if(s.itemType==="armor"){const n=s,c=r("defenseEffect").replace("{{defense}}",String(n.defense));t.push(`      ${r("effectLabel")}: ${c}`)}}),this.getCurrentEquipmentDisplay&&(t.push(""),t.push(r("currentEquipmentHeader")),this.getCurrentEquipmentDisplay().forEach(a=>{t.push(a)})),t.push(""),t.push(r("usageInstructionsHeader")),t.push(r("itemUsageInstructions")),t.push(r("itemUsageExample")),this.addMessages?this.addMessages(t):t.forEach(s=>this.addMessage(s)),this.gameState.status==="tutorial"&&this.updateTutorialProgress("inventory")}useItem(e){return console.log(`=== InventoryManager.useItem CALLED with index: ${e} ===`),this.useItemInternal(e,!0)}useItemInternal(e,t){if(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")return!1;const s=this.playerController.getPlayer().inventory;if(e<0||e>=s.length)return this.addMessage(g("noItemInSlot",{slot:(e+1).toString()})),!1;const a=s[e],i=this.applyItemEffect(a);return i&&(this.playerController.removeItem(a.id,1),t&&this.processTurn()),i}applyItemEffect(e){if(console.log("=== applyItemEffect START ==="),console.log("Item:",e),console.log("Item type:",e?.itemType),console.log("equipItem callback exists:",!!this.equipItem),!e)return console.log("Item is null/undefined"),this.addMessage(g("invalidItem")),!1;if(!e.char)return console.log("Item missing char property"),this.addMessage(g("itemCannotBeUsed",{item:d(e)})),!1;if(e.itemType==="weapon"||e.itemType==="armor")if(console.log("=== EQUIPMENT ITEM DETECTED ==="),console.log("Item type:",e.itemType),this.equipItem){console.log("Calling equipItem callback...");const t=this.equipItem(e);return console.log("Equipment result:",t),t&&this.gameState.status==="tutorial"&&(this.updateTutorialProgress("equipment"),this.notifyEquipmentToggle&&(console.log("Notifying equipment toggle for equip action"),this.notifyEquipmentToggle())),console.log("=== applyItemEffect END (Equipment) ==="),t}else return console.log("No equipItem callback available"),this.addMessage(g("itemCannotBeUsed",{item:d(e)})),!1;switch(e.char){case"!":return this.playerController.heal(v.ITEM_EFFECTS.HEALTH_POTION),this.gameState.player.health=this.playerController.getPlayer().health,this.gameState.currentDungeon.player.health=this.gameState.player.health,this.addMessage(`${d(e)}${r("useItem")} ${r("healthRestored").replace("{{amount}}",v.ITEM_EFFECTS.HEALTH_POTION.toString())}`),this.gameState.status==="tutorial"&&this.updateTutorialProgress("equipment"),!0;case"+":return this.playerController.heal(v.ITEM_EFFECTS.HEALING_HERB),this.gameState.player.health=this.playerController.getPlayer().health,this.gameState.currentDungeon.player.health=this.gameState.player.health,this.addMessage(`${d(e)}${r("useItem")} ${r("healthRestored").replace("{{amount}}",v.ITEM_EFFECTS.HEALING_HERB.toString())}`),!0;case"%":return this.playerController.restoreEnergy(v.ITEM_EFFECTS.ENERGY_BAR),this.gameState.player.energy=this.playerController.getPlayer().energy,this.gameState.currentDungeon.player.energy=this.gameState.player.energy,this.addMessage(`${d(e)}${r("useItem")} ${r("energyRestored").replace("{{amount}}",v.ITEM_EFFECTS.ENERGY_BAR.toString())}`),!0;case"*":return this.playerController.restoreEnergy(v.ITEM_EFFECTS.ENERGY_CORE),this.gameState.player.energy=this.playerController.getPlayer().energy,this.gameState.currentDungeon.player.energy=this.gameState.player.energy,this.addMessage(`${d(e)}${r("useItem")} ${r("energyRestored").replace("{{amount}}",v.ITEM_EFFECTS.ENERGY_CORE.toString())}`),!0;case"?":const t=[()=>(this.playerController.heal(v.ITEM_EFFECTS.MYSTERY_SCROLL_HEALTH),this.gameState.player.health=this.playerController.getPlayer().health,this.gameState.currentDungeon.player.health=this.gameState.player.health,r("mysteryScrollHealth")),()=>(this.playerController.restoreEnergy(v.ITEM_EFFECTS.MYSTERY_SCROLL_ENERGY),this.gameState.player.energy=this.playerController.getPlayer().energy,this.gameState.currentDungeon.player.energy=this.gameState.player.energy,r("mysteryScrollEnergy")),()=>(this.gameState.score+=v.ITEM_EFFECTS.MYSTERY_SCROLL_SCORE,r("mysteryScrollScore")),()=>{const i=this.gameState.currentDungeon;for(let o=0;o<i.dimensions.height;o++)for(let n=0;n<i.dimensions.width;n++)Math.random()<.3&&(i.tiles[o][n].explored=!0);return r("mysteryScrollMap")}],s=t[Math.floor(Math.random()*t.length)],a=s();return this.addMessage(`${d(e)}${r("useItem")} ${a}`),!0;default:return this.addMessage(g("itemCannotBeUsed",{item:d(e)})),!1}}addMessagesIndividually(e){e.forEach(t=>this.addMessage(t))}}class he{constructor(e,t,s,a,i){this.gameState=e,this.playerController=t,this.useItemCallback=s,this.removeEquipmentCallback=a,this.addMessage=i}toggleInventoryOverlay(){if(console.log("=== OverlayManager.toggleInventoryOverlay START ==="),console.log("Game status:",this.gameState.status),console.log("Current overlay:",this.gameState.overlay),this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"){console.log("Invalid game status, returning");return}this.gameState.overlay.type==="inventory"&&this.gameState.overlay.isVisible?(console.log("Hiding inventory overlay"),this.hideOverlay()):(console.log("Showing inventory overlay"),this.showInventoryOverlay()),console.log("Final overlay state:",this.gameState.overlay),console.log("=== OverlayManager.toggleInventoryOverlay END ===")}toggleStatusOverlay(){this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"||(console.log("=== STATUS OVERLAY TOGGLE ==="),console.log("Current game status:",this.gameState.status),console.log("Current overlay:",this.gameState.overlay),this.gameState.overlay.type==="character"&&this.gameState.overlay.isVisible?this.hideOverlay():this.showStatusOverlay())}toggleTakeoffOverlay(){this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"||(this.gameState.overlay.type==="takeoff"&&this.gameState.overlay.isVisible?this.hideOverlay():this.showTakeoffOverlay())}toggleEquipmentOverlay(){this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"||(this.gameState.overlay.type==="equipment"&&this.gameState.overlay.isVisible?this.hideOverlay():this.showEquipmentOverlay())}showInventoryOverlay(){this.gameState.overlay={type:"inventory",isVisible:!0,selectedIndex:0}}showStatusOverlay(){this.gameState.overlay={type:"character",isVisible:!0,selectedIndex:0}}showTakeoffOverlay(){const e=this.playerController.getPlayer(),t=[];if(e.equipment.mainHand&&t.push({slot:"weapon",item:e.equipment.mainHand}),e.equipment.head&&t.push({slot:"armor",item:e.equipment.head}),e.equipment.chest&&t.push({slot:"armor",item:e.equipment.chest}),e.equipment.legs&&t.push({slot:"armor",item:e.equipment.legs}),e.equipment.feet&&t.push({slot:"armor",item:e.equipment.feet}),e.equipment.offHand&&t.push({slot:"armor",item:e.equipment.offHand}),console.log("=== TAKEOFF OVERLAY CHECK ==="),console.log("Player equipment:",e.equipment),console.log("Equipped items found:",t.length),t.length===0){this.addMessage("外せる装備がありません。");return}this.gameState.overlay={type:"takeoff",isVisible:!0,selectedIndex:0}}showEquipmentOverlay(){this.gameState.overlay={type:"equipment",isVisible:!0,selectedIndex:0}}hideOverlay(){this.gameState.overlay={type:"none",isVisible:!1,selectedIndex:0}}handleNavigation(e){if(this.gameState.overlay.isVisible)switch(this.gameState.overlay.type){case"inventory":this.handleInventoryNavigation(e);break;case"character":break;case"takeoff":this.handleTakeoffNavigation(e);break}}handleInventoryNavigation(e){const t=this.playerController.getPlayer().inventory;if(t.length===0)return;const s=this.gameState.overlay.selectedIndex??0;let a=s;switch(e){case"north":a=Math.max(0,s-1);break;case"south":a=Math.min(t.length-1,s+1);break}this.gameState.overlay.selectedIndex=a}handleTakeoffNavigation(e){const t=this.playerController.getPlayer(),s=[];if(t.equipment.mainHand&&s.push({slot:"weapon",item:t.equipment.mainHand}),t.equipment.head&&s.push({slot:"armor",item:t.equipment.head,slotName:"head"}),t.equipment.chest&&s.push({slot:"armor",item:t.equipment.chest,slotName:"chest"}),t.equipment.legs&&s.push({slot:"armor",item:t.equipment.legs,slotName:"legs"}),t.equipment.feet&&s.push({slot:"armor",item:t.equipment.feet,slotName:"feet"}),t.equipment.offHand&&s.push({slot:"armor",item:t.equipment.offHand,slotName:"offHand"}),s.length===0)return;const a=this.gameState.overlay.selectedIndex||0;let i=a;switch(e){case"north":i=Math.max(0,a-1);break;case"south":i=Math.min(s.length-1,a+1);break}this.gameState.overlay.selectedIndex=i}handleInteraction(){if(console.log("=== OverlayManager.handleInteraction START ==="),console.log("Overlay visible:",this.gameState.overlay.isVisible),console.log("Overlay type:",this.gameState.overlay.type),!this.gameState.overlay.isVisible){console.log("Overlay not visible, returning");return}switch(this.gameState.overlay.type){case"inventory":console.log("Processing inventory interaction"),this.handleInventoryInteraction();break;case"character":console.log("Character overlay - no interaction needed");break;case"takeoff":console.log("Processing takeoff interaction"),this.handleTakeoffInteraction();break}console.log("=== OverlayManager.handleInteraction END ===")}handleInventoryInteraction(){console.log("=== OverlayManager.handleInventoryInteraction START ===");const e=this.playerController.getPlayer().inventory,t=this.gameState.overlay.selectedIndex??0;console.log("Inventory length:",e.length),console.log("Selected index:",t),console.log("Selected item:",e[t]),t<e.length?(console.log("Calling useItemCallback with index:",t),this.useItemCallback(t),this.hideOverlay()):console.log("Invalid index, no action taken"),console.log("=== OverlayManager.handleInventoryInteraction END ===")}handleTakeoffInteraction(){const e=this.playerController.getPlayer(),t=this.gameState.overlay.selectedIndex??0,s=[];if(e.equipment.mainHand&&s.push({slot:"weapon",item:e.equipment.mainHand}),e.equipment.head&&s.push({slot:"armor",item:e.equipment.head,slotName:"head"}),e.equipment.chest&&s.push({slot:"armor",item:e.equipment.chest,slotName:"chest"}),e.equipment.legs&&s.push({slot:"armor",item:e.equipment.legs,slotName:"legs"}),e.equipment.feet&&s.push({slot:"armor",item:e.equipment.feet,slotName:"feet"}),e.equipment.offHand&&s.push({slot:"armor",item:e.equipment.offHand,slotName:"offHand"}),console.log("=== TAKEOFF INTERACTION ==="),console.log("Selected index:",t),console.log("Available equipment:",s),t<s.length){const a=s[t];a.slot==="armor"&&a.slotName?(console.log(`Removing armor from slot: ${a.slotName}`),this.removeEquipmentCallback("armor")):(console.log(`Removing ${a.slot}`),this.removeEquipmentCallback(a.slot)),this.hideOverlay()}}useItemFromOverlay(e){const t=this.playerController.getPlayer().inventory;e>=t.length||(this.useItemCallback(e),e>=t.length-1&&(this.gameState.overlay.selectedIndex=Math.max(0,t.length-2)))}handlePauseOrClose(){return this.gameState.overlay.isVisible?(console.log("Closing overlay:",this.gameState.overlay),this.hideOverlay(),console.log("Overlay closed, returning early"),!0):!1}getOverlayState(){return this.gameState.overlay}isVisible(){return this.gameState.overlay.isVisible}isType(e){return this.gameState.overlay.type===e&&this.gameState.overlay.isVisible}}class _{constructor(e,t,s){this.configuration=e,this.eventBus=t,this.effectHandler=s,this.steps=e.steps}state=S.NOT_STARTED;steps;currentStepIndex=-1;completedStepIds=new Set;start(){if(this.state!==S.NOT_STARTED){console.warn("Tutorial already started");return}this.state=S.IN_PROGRESS,this.currentStepIndex=0,this.completedStepIds.clear(),this.steps.length>0&&(this.steps[0].state=E.ACTIVE,this.eventBus.emitTutorialStarted(),this.eventBus.emitStepStarted(this.steps[0].id),this.effectHandler.showStepStartMessage(this.steps[0]))}complete(){this.state===S.IN_PROGRESS&&(this.state=S.COMPLETED,this.eventBus.emitTutorialCompleted(),this.effectHandler.showTutorialCompletionMessage(),this.effectHandler.updateUI(this.state,null))}reset(){this.state=S.NOT_STARTED,this.currentStepIndex=-1,this.completedStepIds.clear(),this.steps.forEach(e=>{e.state=E.PENDING})}skip(){this.state===S.IN_PROGRESS&&(this.state=S.SKIPPED,this.eventBus.emitTutorialCompleted())}isActive(){return this.state===S.IN_PROGRESS}isCompleted(){return this.state===S.COMPLETED||this.state===S.SKIPPED}getCurrentStep(){return this.currentStepIndex<0||this.currentStepIndex>=this.steps.length?null:this.steps[this.currentStepIndex]}getStepById(e){return this.steps.find(t=>t.id===e)||null}moveToNextStep(){if(!this.isActive())return!1;const e=this.getCurrentStep();if(e&&(e.state=E.COMPLETED,this.completedStepIds.add(e.id),this.eventBus.emitStepCompleted(e.id),this.effectHandler.showStepCompletionMessage(e)),this.currentStepIndex++,this.currentStepIndex>=this.steps.length)return this.complete(),!1;const t=this.getCurrentStep();return t&&(t.state=E.ACTIVE,this.eventBus.emitStepStarted(t.id),this.effectHandler.showStepStartMessage(t),this.effectHandler.updateUI(this.state,t)),!0}isStepCompleted(e){return this.completedStepIds.has(e)}updateProgress(e){if(!this.isActive())return;const t=this.getCurrentStep();if(!t)return;const s={gameState:e,eventBus:this.eventBus,effectHandler:this.effectHandler};t.checkCompletion(s)&&(console.log(`[Tutorial] Step ${t.id} completed, advancing to next step`),this.effectHandler.openDoorForStep(t.id,e),this.eventBus.emitDoorOpened(t.id),this.moveToNextStep())}checkCompletionConditions(){const e=this.getCurrentStep();return e?e.state===E.COMPLETED:!1}isActionAllowed(e){if(!this.isActive())return!0;const t=this.getCurrentStep();if(!t)return!0;const s=t.isActionAllowed(e);return s||(this.eventBus.emitActionBlocked(e,"このアクションは現在のチュートリアルステップでは実行できません"),this.effectHandler.showActionBlockedMessage(e,`${t.title}を完了してください`)),s}getState(){return{isActive:this.state===S.IN_PROGRESS,currentStepId:this.currentStepIndex>=0&&this.currentStepIndex<this.steps.length?this.steps[this.currentStepIndex].id:null,currentStepIndex:this.currentStepIndex,completedSteps:this.completedStepIds.size,isCompleted:this.state===S.COMPLETED}}getCompletedStepIds(){return Array.from(this.completedStepIds)}}class ue{listeners=new Map;onceListeners=new Map;on(e,t){this.listeners.has(e)||this.listeners.set(e,new Set),this.listeners.get(e).add(t)}off(e,t){const s=this.listeners.get(e);s&&(s.delete(t),s.size===0&&this.listeners.delete(e));const a=this.onceListeners.get(e);a&&(a.delete(t),a.size===0&&this.onceListeners.delete(e))}once(e,t){this.onceListeners.has(e)||this.onceListeners.set(e,new Set),this.onceListeners.get(e).add(t)}emit(e,t){const s={type:e,timestamp:Date.now(),data:t},a=this.listeners.get(e);a&&a.forEach(o=>{try{o(s)}catch(n){console.error(`Error in event handler for ${e}:`,n)}});const i=this.onceListeners.get(e);i&&(i.forEach(o=>{try{o(s)}catch(n){console.error(`Error in once handler for ${e}:`,n)}}),this.onceListeners.delete(e))}emitTutorialStarted(){this.emit("tutorial:started",{})}emitTutorialCompleted(){this.emit("tutorial:completed",{})}emitStepStarted(e){this.emit("tutorial:step:started",{stepId:e})}emitStepCompleted(e){this.emit("tutorial:step:completed",{stepId:e})}emitActionBlocked(e,t){this.emit("tutorial:action:blocked",{action:e,reason:t})}emitDoorOpened(e){this.emit("tutorial:door:opened",{stepId:e})}clear(){this.listeners.clear(),this.onceListeners.clear()}}class K{constructor(e,t,s){this.addMessage=e,this.updateTiles=t,this.setGameStatus=s}openedDoors=new Set;openDoorForStep(e,t){if(this.openedDoors.has(e))return;const s=t.currentDungeon?.tiles,a=t.currentDungeon?.rooms||[];if(!s||a.length===0){console.warn("Cannot open door: tiles or rooms not available");return}const i=this.getStepIndexFromId(e);if(i<0||i>=a.length-1)return;const o=a[i],n=a[i+1],c=this.calculateDoorPosition(o,n);c&&(this.openDoorAt(s,c),this.openedDoors.add(e),this.updateTiles&&this.updateTiles(s))}isDoorOpenForStep(e){return this.openedDoors.has(e)}calculateDoorPosition(e,t){const s=t.position.x-1,a=e.position.y+Math.floor(e.dimensions.height/2);return{x:s,y:a}}openDoorAt(e,t){e[t.y]&&e[t.y][t.x]&&(e[t.y][t.x]={...e[t.y][t.x],type:"floor",char:".",blocking:!1},console.log(`Door opened at (${t.x}, ${t.y})`))}getStepIndexFromId(e){return{step_movement:0,step_item_pickup:1,step_equipment:2,step_combat:3,step_character_status:4}[e]??-1}showStepStartMessage(e){this.addMessage(`=== ${e.title} ===`),this.addMessage(e.description),e.hint&&this.addMessage(`ヒント: ${e.hint}`)}showStepCompletionMessage(e){const s={step_movement:"移動チュートリアル完了！扉が開きました。",step_item_pickup:"アイテム使用完了！扉が開きました。",step_equipment:"装備着脱完了！扉が開きました。",step_combat:"戦闘チュートリアル完了！扉が開きました。",step_character_status:"ステータス確認完了！これで全ての基本操作を学びました。"}[e.id]||`${e.title}を完了しました！`;this.addMessage(s)}showHintMessage(e){e.hint&&this.addMessage(`💡 ヒント: ${e.hint}`)}showActionBlockedMessage(e,t){this.addMessage(`⚠️ ${t}`)}showTutorialCompletionMessage(){this.addMessage(""),this.addMessage("★━━━━━━━━━━━━━━━━━━━━━━★"),this.addMessage("   チュートリアル完了！"),this.addMessage("★━━━━━━━━━━━━━━━━━━━━━━★"),this.addMessage(""),this.addMessage("おめでとうございます！全ての基本操作をマスターしました。"),this.addMessage(""),this.addMessage("ESCキーでメニューを開き、「タイトルに戻る」を選択してください。"),this.addMessage("本編でお会いしましょう！"),this.addMessage("")}updateUI(e,t){this.setGameStatus&&(e===S.IN_PROGRESS?this.setGameStatus("tutorial"):(e===S.COMPLETED||e===S.SKIPPED)&&this.setGameStatus("tutorial"))}placeItemForStep(e,t){const a={step_item_pickup:{type:"health_potion",position:{x:15,y:10}},step_equipment:{type:"sword",position:{x:25,y:10}}}[e.id];if(a&&t.currentDungeon){const i={id:`tutorial_${a.type}`,type:"item",char:a.type==="potion"?"!":"S",name:a.type,itemType:a.type==="potion"?"consumable":"weapon",position:a.position};t.currentDungeon.entities||(t.currentDungeon.entities=[]),t.currentDungeon.entities.push(i)}}}class pe{steps=[{id:"pickup",action:"F",description:"武器を拾う",completed:!1},{id:"open_equipment",action:"E",description:"装備画面を開く",completed:!1},{id:"open_takeoff",action:"T",description:"着脱画面を開く",completed:!1},{id:"unequip",action:"Click",description:"装備を外す",completed:!1}];currentStepIndex=0;advanceStep(){const e=this.getCurrentStep();e&&!e.completed&&(e.completed=!0),this.currentStepIndex<this.steps.length-1&&this.currentStepIndex++}getCurrentStep(){return this.steps[this.currentStepIndex]||null}isCompleted(){return this.steps.every(e=>e.completed)}reset(){this.currentStepIndex=0,this.steps.forEach(e=>{e.completed=!1})}handlePickup(){const e=this.steps.find(t=>t.id==="pickup");e&&this.currentStepIndex===0&&(e.completed=!0,this.currentStepIndex=1,console.log("Equipment picked up, moving to equipment view step"))}handleEquipmentOpen(){const e=this.steps.find(t=>t.id==="open_equipment");e&&this.currentStepIndex===1&&(e.completed=!0,this.currentStepIndex=2,console.log("Equipment view opened, moving to takeoff view step"))}handleTakeoffOpen(){const e=this.steps.find(t=>t.id==="open_takeoff");e&&this.currentStepIndex===2&&(e.completed=!0,this.currentStepIndex=3,console.log("Takeoff view opened, moving to unequip step"))}handleUnequip(){const e=this.steps.find(t=>t.id==="unequip");e&&this.currentStepIndex===3&&(e.completed=!0,console.log("Equipment unequipped, flow completed"))}getCurrentDescription(){const e=this.getCurrentStep();return e?`${e.description}（${e.action}キー）`:this.isCompleted()?"装備チュートリアル完了！":""}getProgress(){const e=this.steps.filter(s=>s.completed).length,t=this.steps.length;return{current:e,total:t,percentage:Math.round(e/t*100)}}isActionRequired(e){const t=this.getCurrentStep();return!t||t.completed?!1:{pickup:"F",open_equipment:"E",open_takeoff:"T",unequip:"Click"}[t.id]===e}}class me{orchestrator;eventBus;effectHandler;configuration;equipmentFlow;constructor(){this.configuration=new U,this.eventBus=new ue,this.effectHandler=new K(()=>{},void 0,void 0),this.orchestrator=new _(this.configuration,this.eventBus,this.effectHandler),this.equipmentFlow=new pe,this.setupEventListeners()}setCallbacks(e){this.effectHandler=new K(e.addMessage,e.updateTiles,e.setGameStatus),this.orchestrator=new _(this.configuration,this.eventBus,this.effectHandler)}start(){this.orchestrator.start()}complete(){this.orchestrator.complete()}reset(){this.orchestrator.reset(),this.equipmentFlow.reset(),this.eventBus.clear()}skip(){this.orchestrator.skip()}updateProgress(e){this.orchestrator.updateProgress(e)}isActionAllowed(e){return this.orchestrator.isActionAllowed(e)}isActive(){return this.orchestrator.isActive()}isCompleted(){return this.orchestrator.isCompleted()}getCurrentStep(){return this.orchestrator.getCurrentStep()}getCurrentStepId(){return this.orchestrator.getCurrentStep()?.id||""}getState(){return this.orchestrator.getState()}markItemUsed(){const e=this.orchestrator.getCurrentStep();console.log("[Tutorial] markItemUsed called, current step:",e?.id),e?.id==="step_item_pickup"?(console.log("[Tutorial] Notifying item use action"),y.notifyAction("step_item_pickup","item_use")):console.log("[Tutorial] Not in item pickup step, ignoring markItemUsed")}markCombatCompleted(){this.orchestrator.getCurrentStep()?.id==="step_combat"&&y.notifyAction("step_combat","combat_complete")}markStatusViewed(){this.orchestrator.getCurrentStep()?.id==="step_character_status"&&y.notifyAction("step_character_status","status_view")}markEquipmentPickedUp(){this.orchestrator.getCurrentStep()?.id==="step_equipment"&&(this.equipmentFlow.handlePickup(),y.notifyAction("step_equipment","pickup"))}markEquipmentViewOpened(){this.orchestrator.getCurrentStep()?.id==="step_equipment"&&(this.equipmentFlow.handleEquipmentOpen(),y.notifyAction("step_equipment","open_equipment"))}markTakeoffViewOpened(){this.orchestrator.getCurrentStep()?.id==="step_equipment"&&(this.equipmentFlow.handleTakeoffOpen(),y.notifyAction("step_equipment","open_takeoff"))}markEquipmentToggled(){this.orchestrator.getCurrentStep()?.id==="step_equipment"&&(this.equipmentFlow.handleUnequip(),y.notifyAction("step_equipment","unequip"))}getEquipmentTutorialMessage(){return this.orchestrator.getCurrentStep()?.id==="step_equipment"?this.equipmentFlow.getCurrentDescription():""}markActionCompleted(e){console.log(`Action completed: ${e}`)}getStepInfo(){const e=this.orchestrator.getCurrentStep();return e?{id:e.id,title:e.title,description:e.description,targetAction:e.targetAction,targetPosition:e.targetPosition}:null}getCurrentStepInfo(){return this.getStepInfo()}getProgress(){return{currentStep:this.orchestrator.getState().currentStepIndex,totalSteps:this.configuration.totalSteps}}getCompletedStepIds(){return this.orchestrator.getCompletedStepIds()}checkStepCompletion(e){return this.orchestrator.isStepCompleted(e)}get state(){const e=this.orchestrator.getState();return{isActive:e.isActive,currentStep:e.currentStepId,currentStepId:e.currentStepId,currentStepIndex:e.currentStepIndex,totalSteps:this.configuration.totalSteps,completedSteps:e.completedSteps,isCompleted:e.isCompleted,progress:{current:e.currentStepIndex,total:this.configuration.totalSteps}}}getCoordinateInfo(){const e=this.orchestrator.getCurrentStep();return{currentStep:e?.id,targetPosition:e?.targetPosition,welcomeRoomPosition:{x:2,y:12},playerStartPosition:{x:4,y:14},movementTargetPosition:{x:6,y:15},roomDimensions:{width:8,height:6}}}setupEventListeners(){this.eventBus.on("tutorial:step:started",e=>{console.log(`Tutorial step started: ${e.data.stepId}`)}),this.eventBus.on("tutorial:step:completed",e=>{console.log(`Tutorial step completed: ${e.data.stepId}`)}),this.eventBus.on("tutorial:completed",()=>{console.log("Tutorial completed!")}),this.eventBus.on("tutorial:action:blocked",e=>{console.log(`Action blocked: ${e.data.action} - ${e.data.reason}`)})}}class ge{constructor(e,t,s,a){this.gameState=e,this.addMessage=t,this.startGameCallback=s,this.startTutorialCallback=a}showMenu(){this.addMessage(r("menuNotImplemented"))}handleLanguageSwitch(){const t=b.getCurrentLanguage()==="ja"?"en":"ja";b.setLanguage(t),this.updateUITexts(),this.addMessage(r("languageSwitched"))}updateUITexts(){}showSettings(){this.addMessage(r("settingsUnderDevelopment"))}showPrologue(){this.gameState.welcome.showPrologue=!0}skipPrologue(){this.gameState.welcome.showPrologue=!1,this.gameState.welcome.selectedOption||(this.gameState.welcome.selectedOption="start")}handleWelcomeInteract(){if(this.gameState.status!=="welcome")return;if(this.gameState.welcome.showPrologue){this.skipPrologue();return}const e=this.gameState.welcome.selectedOption;if(e)switch(e){case"start":this.startGameCallback();break;case"tutorial":this.startTutorialCallback();break;case"settings":this.showSettings();break}}navigateWelcomeMenu(e){if(this.gameState.status!=="welcome"||this.gameState.welcome.showPrologue)return;const t=["start","tutorial","settings"],s=t.indexOf(this.gameState.welcome.selectedOption||"start");let a=s;e==="up"?a=Math.max(0,s-1):a=Math.min(t.length-1,s+1),this.gameState.welcome.selectedOption=t[a]}getCurrentLanguage(){return b.getCurrentLanguage()}setLanguage(e){b.setLanguage(e),this.updateUITexts()}showGameOver(e){this.addMessage(g("gameOver")),this.addMessage(g("finalScore",{score:e.toString()}))}showVictory(e){this.addMessage(g("victory")),this.addMessage(g("finalScore",{score:e.toString()}))}isUIElementVisible(e){switch(e){case"prologue":return this.gameState.welcome.showPrologue;case"menu":return this.gameState.status==="menu";case"settings":return!1;default:return!1}}}class de{keyMapping;pressedKeys;actionCallbacks;element;keyRepeatTimer;REPEAT_DELAY=300;REPEAT_RATE=100;constructor(e){this.element=e,this.pressedKeys=new Set,this.actionCallbacks=new Map,this.keyRepeatTimer=new Map,this.keyMapping={KeyW:"move_north",ArrowUp:"move_north",KeyS:"move_south",ArrowDown:"move_south",KeyA:"move_west",ArrowLeft:"move_west",KeyD:"move_east",ArrowRight:"move_east",KeyF:"interact",Enter:"interact",Space:"attack",KeyX:"attack",KeyI:"inventory",KeyE:"equipment",KeyC:"character",Comma:"pickup",KeyG:"pickup",KeyQ:"quaff",KeyR:"read",KeyT:"takeoff",Digit1:"use_item_1",Digit2:"use_item_2",Digit3:"use_item_3",Digit4:"use_item_4",Digit5:"use_item_5",Digit6:"use_item_6",Digit7:"use_item_7",Digit8:"use_item_8",Digit9:"use_item_9",Escape:"pause",KeyM:"menu",KeyL:"language_switch"},this.setupEventListeners()}setupEventListeners(){this.element.tabIndex<0&&(this.element.tabIndex=0),this.element.focus();const e=s=>{s.preventDefault();const a=s.code;if(!this.pressedKeys.has(a)){this.pressedKeys.add(a),this.handleKeyPress(a);const i=this.keyMapping[a];this.isMovementAction(i)&&this.setupKeyRepeat(a)}},t=s=>{s.preventDefault();const a=s.code;this.pressedKeys.delete(a),this.clearKeyRepeat(a)};this.element.addEventListener("keydown",e),this.element.addEventListener("keyup",t),this.element.addEventListener("blur",()=>{this.element.focus()}),this.element.addEventListener("click",()=>{this.element.focus()})}handleKeyPress(e){const t=this.keyMapping[e];if(t&&this.actionCallbacks.has(t)){const s=this.actionCallbacks.get(t);s&&s()}}onAction(e,t){this.actionCallbacks.set(e,t)}offAction(e){this.actionCallbacks.delete(e)}setKeyMapping(e){Object.assign(this.keyMapping,e)}getKeyMapping(){return{...this.keyMapping}}isKeyPressed(e){return this.pressedKeys.has(e)}isMovementKeyPressed(){return["KeyW","KeyS","KeyA","KeyD","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].some(t=>this.pressedKeys.has(t))}getPressedKeys(){return Array.from(this.pressedKeys)}isMovementAction(e){return e==="move_north"||e==="move_south"||e==="move_east"||e==="move_west"}setupKeyRepeat(e){this.clearKeyRepeat(e);const t=setTimeout(()=>{const s=setInterval(()=>{this.pressedKeys.has(e)?this.handleKeyPress(e):this.clearKeyRepeat(e)},this.REPEAT_RATE);this.keyRepeatTimer.set(e,s)},this.REPEAT_DELAY);this.keyRepeatTimer.set(e,t)}clearKeyRepeat(e){const t=this.keyRepeatTimer.get(e);t!==void 0&&(clearTimeout(t),clearInterval(t),this.keyRepeatTimer.delete(e))}clearPressedKeys(){this.pressedKeys.clear(),this.keyRepeatTimer.forEach(e=>{clearTimeout(e),clearInterval(e)}),this.keyRepeatTimer.clear()}disable(){this.clearPressedKeys()}focus(){this.element.focus()}getActionForKey(e){return this.keyMapping[e]}getKeyForAction(e){for(const[t,s]of Object.entries(this.keyMapping))if(s===e)return t}keyToDisplayString(e){return{KeyW:"W",KeyA:"A",KeyS:"S",KeyD:"D",KeyE:"E",KeyC:"C",KeyF:"F",KeyG:"G",KeyI:"I",KeyL:"L",KeyM:"M",KeyQ:"Q",KeyR:"R",KeyT:"T",KeyX:"X",Comma:",",Enter:"Enter",Digit1:"1",Digit2:"2",Digit3:"3",Digit4:"4",Digit5:"5",Digit6:"6",Digit7:"7",Digit8:"8",Digit9:"9",ArrowUp:"↑",ArrowDown:"↓",ArrowLeft:"←",ArrowRight:"→",Space:"Space",Escape:"Esc"}[e]||e}}class ye{constructor(e,t,s,a,i,o,n,c,h,p,u,m,f){this.gameState=t,this.handleDirectionalInputCallback=s,this.toggleAttackModeCallback=a,this.handleInteractCallback=i,this.toggleInventoryOverlayCallback=o,this.toggleStatusOverlayCallback=n,this.toggleTakeoffOverlayCallback=c,this.handleItemActionCallback=h,this.togglePauseCallback=p,this.showMenuCallback=u,this.handleLanguageSwitchCallback=m,this.handleEquipmentToggleCallback=f,this.inputHandler=new de(e),this.setupInputHandlers()}inputHandler;setupInputHandlers(){this.inputHandler.onAction("move_north",()=>this.handleDirectionalInputCallback("north")),this.inputHandler.onAction("move_south",()=>this.handleDirectionalInputCallback("south")),this.inputHandler.onAction("move_east",()=>this.handleDirectionalInputCallback("east")),this.inputHandler.onAction("move_west",()=>this.handleDirectionalInputCallback("west")),this.inputHandler.onAction("attack",()=>this.toggleAttackModeCallback()),this.inputHandler.onAction("interact",()=>this.handleInteractCallback()),this.inputHandler.onAction("inventory",()=>this.toggleInventoryOverlayCallback()),this.inputHandler.onAction("character",()=>this.toggleStatusOverlayCallback()),this.inputHandler.onAction("takeoff",()=>this.toggleTakeoffOverlayCallback()),this.inputHandler.onAction("equipment",()=>this.handleEquipmentToggleCallback());for(let e=1;e<=9;e++)this.inputHandler.onAction(`use_item_${e}`,()=>this.handleItemActionCallback(e-1));this.inputHandler.onAction("pause",()=>this.togglePauseCallback()),this.inputHandler.onAction("menu",()=>this.showMenuCallback()),this.inputHandler.onAction("language_switch",()=>this.handleLanguageSwitchCallback())}getInputHandler(){return this.inputHandler}disable(){this.inputHandler.disable()}clearPressedKeys(){this.inputHandler.clearPressedKeys()}focus(){this.inputHandler.focus()}setKeyMapping(e){this.inputHandler.setKeyMapping(e)}getKeyMapping(){return this.inputHandler.getKeyMapping()}isKeyPressed(e){return this.inputHandler.isKeyPressed(e)}isMovementKeyPressed(){return this.inputHandler.isMovementKeyPressed()}getPressedKeys(){return this.inputHandler.getPressedKeys()}getKeyForAction(e){return this.inputHandler.getKeyForAction(e)}getActionForKey(e){return this.inputHandler.getActionForKey(e)}keyToDisplayString(e){return this.inputHandler.keyToDisplayString(e)}}class fe{constructor(e,t){this.playerController=e,this.dungeonManager=t}createInitialGameState(){const e=this.playerController.getPlayer(),t=this.dungeonManager.generateInitialFloor(e);return this.playerController.setPosition(t.player.position),{status:"welcome",player:e,currentDungeon:t,dungeonData:this.dungeonManager.getDungeonData(),turn:0,score:0,messages:[],levelCleared:!1,tutorial:{isActive:!1,currentStep:"welcome",stepProgress:0,showHint:!1,hintText:""},welcome:{showPrologue:!0,selectedOption:"start"},overlay:{type:"none",isVisible:!1,selectedIndex:0}}}updateGameState(e,t){Object.assign(e,t)}updatePlayerState(e,t){Object.assign(e.player,t)}updateDungeonState(e,t){e.currentDungeon=t,e.dungeonData=this.dungeonManager.getDungeonData()}updateTutorialState(e,t){Object.assign(e.tutorial,t)}updateWelcomeState(e,t){Object.assign(e.welcome,t)}updateOverlayState(e,t){Object.assign(e.overlay,t)}incrementTurn(e){e.turn++}addMessage(e,t){e.messages.push(t),e.messages.length>100&&(e.messages=e.messages.slice(-100))}clearMessages(e){e.messages=[]}getGameStats(e){return{turnCount:e.turn,score:e.score}}calculateScore(e){const t=e.player;let s=0;return s+=t.level*100,s+=Math.max(0,1e3-e.turn),Math.max(0,s)}validateGameState(e){try{return!(!e.player||!e.currentDungeon||e.player.health<=0&&e.status!=="paused"||!e.currentDungeon.tiles||!e.currentDungeon.entities)}catch(t){return console.error("Game state validation error:",t),!1}}cloneGameState(e){return JSON.parse(JSON.stringify(e))}createSaveData(e){return{version:"1.0.0",timestamp:Date.now(),gameState:this.cloneGameState(e),playerStats:this.getGameStats(e),score:this.calculateScore(e)}}restoreFromSaveData(e){try{if(!e||!e.gameState)return null;const t=e.gameState;return this.validateGameState(t)?t:null}catch(t){return console.error("Failed to restore game state:",t),null}}resetGameState(){return this.createInitialGameState()}}class Se{constructor(e,t,s,a,i,o,n){this.gameState=e,this.playerController=t,this.addMessage=s,this.getEnemyAtCallback=a,this.processTurnCallback=i,this.updateTutorialProgressCallback=o,this.onCombatCompletedCallback=n}attackMode=!1;toggleAttackMode(){this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"||(this.attackMode=!this.attackMode,this.attackMode?this.addMessage(g("attackModeOn")):this.addMessage(g("movementMode")),this.updateTutorialProgressCallback&&this.gameState.status==="tutorial"&&this.updateTutorialProgressCallback("combat"))}isAttackMode(){return this.attackMode}disableAttackMode(){this.attackMode=!1}handleAttack(e){this.playerController.getPosition();const t=this.playerController.move(e),s=this.getEnemyAtCallback(t);s?(this.handleCombat(s),this.processTurnCallback()):this.addMessage(g("noEnemyInThatDirection")),this.updateTutorialProgressCallback&&this.gameState.status==="tutorial"&&this.updateTutorialProgressCallback("combat"),this.attackMode=!1,this.addMessage(g("movementMode"))}handleCombat(e){if(!(this.gameState.status==="tutorial")&&!this.playerController.rollAttackHit()){this.addMessage(g("attackMissed",{enemy:q(e)}));return}const{damage:s,isCritical:a}=this.playerController.rollDamage();"health"in e&&"maxHealth"in e?this.applyDamageToEnemy(e,s,a):this.handleLegacyEnemyCombat(e,s,a)}applyDamageToEnemy(e,t,s){"health"in e&&typeof e.health=="number"&&(e.health-=t);const a=s?"criticalHit":"normalHit";this.addMessage(g(a,{enemy:q(e),damage:t.toString(),health:"health"in e&&typeof e.health=="number"?Math.max(0,e.health).toString():"0",maxHealth:"maxHealth"in e&&typeof e.maxHealth=="number"?e.maxHealth.toString():"100"})),"health"in e&&typeof e.health=="number"&&e.health<=0&&this.handleEnemyDefeat(e)}handleLegacyEnemyCombat(e,t,s){const a=s?"criticalHit":"normalHit";this.addMessage(g(a,{enemy:q(e),damage:t.toString(),health:"0",maxHealth:"100"})),this.handleEnemyDefeat(e)}handleEnemyDefeat(e){const t=this.gameState.currentDungeon.entities.findIndex(s=>s.id===e.id);if(t!==-1){this.gameState.currentDungeon.entities.splice(t,1),this.addMessage(g("enemyDefeated",{enemy:q(e)}));const s=this.calculateExperienceReward(e),a=this.playerController.addExperience(s);this.gameState.score+=10,this.addMessage(g("experienceGained",{exp:s.toString()})),this.gameState.player=this.playerController.getPlayer(),this.gameState.currentDungeon.player=this.gameState.player,a&&this.addMessage(g("levelUp",{level:this.gameState.player.level.toString()})),this.onCombatCompletedCallback&&this.onCombatCompletedCallback()}}calculateExperienceReward(e){const s={G:25,R:20,S:22,O:40,T:45,W:50,D:100,L:90,M:85}[e.char]||20,a="maxHealth"in e?Math.floor(e.maxHealth/10):0;return s+a}getCombatStats(){const e=this.playerController.getPlayer();return{attackMode:this.attackMode,playerLevel:e.level,playerHealth:e.health,playerMaxHealth:e.maxHealth}}canEngageCombat(){return this.playerController.getPlayer().health>0&&(this.gameState.status==="playing"||this.gameState.status==="tutorial")}getPlayerDamageCapability(){const e=this.playerController.getPlayer(),t=e.equipment.mainHand,s=t?t.damage:5,a=t?t.accuracy:70;return{minDamage:Math.max(1,s-2),maxDamage:s+e.level,accuracy:a,criticalChance:10+Math.floor(e.level/2)}}evaluateEnemyThreat(e){const t=this.playerController.getPlayer().level;return["D","L","M"].includes(e.char)?t<5?"extreme":"high":["O","T","W"].includes(e.char)?t<3?"high":"medium":t<2?"medium":"low"}}class ve{constructor(e,t,s){this.gameState=e,this.playerController=t,this.addMessage=s}equipItemFromInventory(e){if(console.log("=== equipItemFromInventory START ==="),console.log("Item to equip:",e),console.log("Item type:",e?.itemType),e.itemType==="weapon"){console.log("Processing weapon equipment...");const t=this.equipWeapon(e);return console.log("Weapon equipment result:",t),t}else if(e.itemType==="armor"){console.log("Processing armor equipment...");const t=this.equipArmor(e);return console.log("Armor equipment result:",t),t}return console.log("Item type not recognized as equipment"),console.log("=== equipItemFromInventory END ==="),!1}equipWeapon(e){return this.playerController.equipWeapon(e)?(this.addMessage(g("weaponEquipped",{weapon:d(e)})),this.syncPlayerData(),!0):(this.addMessage(g("cannotEquipWeapon")),!1)}equipArmor(e){return this.playerController.equipArmor(e)?(this.addMessage(g("armorEquipped",{armor:d(e)})),this.syncPlayerData(),!0):(this.addMessage(g("cannotEquipArmor")),!1)}removeEquipment(e){e==="weapon"?this.removeWeapon():e==="armor"&&this.removeArmor(),this.syncPlayerData()}removeWeapon(){console.log("=== REMOVE WEAPON START ===");const e=this.playerController.getPlayer();console.log("Player equipment before unequip:",e.equipment);const t=this.playerController.unequipWeapon();if(console.log("Weapon returned from unequipWeapon():",t),t){console.log("=== REMOVING WEAPON ==="),console.log("Weapon to be returned to inventory:",t),console.log("Player equipment after unequip:",e.equipment),console.log("MainHand slot cleared:",!e.equipment.mainHand);const s=this.playerController.addItem(t);console.log("Add item success:",s),s||console.error("Failed to add weapon back to inventory - inventory might be full"),this.addMessage(g("weaponUnequipped",{weapon:d(t)})),this.syncPlayerData(),console.log("Player data synced after weapon removal")}else console.log("No weapon to remove");console.log("=== REMOVE WEAPON END ===")}removeArmor(){console.log("=== REMOVE ARMOR START ===");const e=this.playerController.getPlayer();if(console.log("Player equipment before armor unequip:",e.equipment),console.log("Head armor exists:",!!e.equipment.head),e.equipment.head){const t=this.playerController.unequipArmor("head");if(console.log("Armor returned from unequipArmor():",t),t){console.log("=== REMOVING ARMOR ==="),console.log("Armor to be returned to inventory:",t),console.log("Player equipment after armor unequip:",e.equipment),console.log("Head slot cleared:",!e.equipment.head);const s=this.playerController.addItem(t);console.log("Add item success:",s),s||console.error("Failed to add armor back to inventory - inventory might be full"),this.addMessage(g("armorUnequipped",{armor:d(t)})),this.syncPlayerData(),console.log("Player data synced after armor removal")}}else console.log("No head armor to remove");console.log("=== REMOVE ARMOR END ===")}getCurrentEquipmentDisplay(){const t=this.playerController.getPlayer().equipment,s=[];if(t.mainHand){const n=t.mainHand,c=d(n);s.push(`${r("rightHand")}: ${n.char} ${c}`);const h=r("attackPowerEffect").replace("{{damage}}",String(n.damage)).replace("{{accuracy}}",String(n.accuracy));s.push(`      ${r("effectLabel")}: ${h}`)}else s.push(`${r("rightHand")}: ${r("noEquipment")}`);[{slot:"head",name:r("head")},{slot:"chest",name:r("chest")},{slot:"legs",name:r("legs")},{slot:"feet",name:r("feet")},{slot:"offHand",name:r("leftHand")}].forEach(n=>{const c=t[n.slot];if(c){const h=d(c);s.push(`${n.name}: ${c.char} ${h}`);const p=r("defenseEffect").replace("{{defense}}",String(c.defense));s.push(`      ${r("effectLabel")}: ${p}`)}else s.push(`${n.name}: ${r("noEquipment")}`)});const i=this.playerController.getTotalDefense(),o=r("totalDefense").replace("{{total}}",String(i));return s.push(o),s}canEquipItem(e){return!e||!e.itemType?!1:e.itemType==="weapon"?this.canEquipWeapon(e):e.itemType==="armor"?this.canEquipArmor(e):!1}canEquipWeapon(e){return e&&typeof e.damage=="number"&&typeof e.accuracy=="number"&&e.damage>0&&e.accuracy>0}canEquipArmor(e){return e&&typeof e.defense=="number"&&e.defense>0&&["head","chest","legs","feet","offHand"].includes(e.armorType)}getEquipmentStats(){const t=this.playerController.getPlayer().equipment,s=!!t.mainHand,a=t.mainHand?t.mainHand.damage:0,i=t.mainHand?t.mainHand.accuracy:0,o=this.playerController.getTotalDefense();let n=0;return t.head&&n++,t.chest&&n++,t.legs&&n++,t.feet&&n++,t.offHand&&n++,{weaponEquipped:s,weaponDamage:a,weaponAccuracy:i,totalDefense:o,armorPieces:n}}getEquipmentEffects(){const t=this.playerController.getPlayer().equipment;let s=0,a=0;const i=[];return t.mainHand&&(s+=t.mainHand.damage,t.mainHand.accuracy>90&&i.push("高精度")),[t.head,t.chest,t.legs,t.feet,t.offHand].filter(o=>o).forEach(o=>{o&&(a+=o.defense,o.defense>=10&&i.push("重装甲"))}),{attackBonus:s,defenseBonus:a,specialEffects:i}}syncPlayerData(){this.gameState.player=this.playerController.getPlayer(),this.gameState.currentDungeon.player=this.gameState.player}canUpgradeEquipment(e,t){return!e||!t?!0:e.itemType==="weapon"&&t.itemType==="weapon"?e.damage>t.damage:e.itemType==="armor"&&t.itemType==="armor"?e.defense>t.defense:!1}getEquipmentRecommendation(e){if(!this.canEquipItem(e))return null;const t=this.playerController.getPlayer();if(e.itemType==="weapon"){const s=t.equipment.mainHand;if(s){if(this.canUpgradeEquipment(e,s))return"武器をアップグレードすることを推奨します"}else return"武器を装備することを推奨します"}else if(e.itemType==="armor"){const s=t.equipment[e.armorType];if(s){if(this.canUpgradeEquipment(e,s))return"防具をアップグレードすることを推奨します"}else return"防具を装備することを推奨します"}return null}}class xe{constructor(e,t,s,a,i){this.gameState=e,this.playerController=t,this.addMessage=s,this.processTurnCallback=a,this.updateTutorialProgressCallback=i}handlePlayerMove(e){if(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")return;this.playerController.getPosition();const t=this.playerController.move(e);this.isValidMove(t)?this.executeMove(t):this.addMessage(g("cannotMoveThere"))}executeMove(e){this.playerController.confirmMove(e),this.gameState.player.position=e,console.log("MovementManager.executeMove:",{newPosition:e,gameStatus:this.gameState.status}),w.updateFieldOfView(this.gameState.currentDungeon,e),this.gameState.status==="tutorial"&&(console.log("Calling updateTutorialProgressCallback..."),this.updateTutorialProgressCallback("movement")),this.processTurnCallback()}isValidMove(e){const t=this.gameState.currentDungeon;return!x(e,t.dimensions)||t.tiles[e.y][e.x].blocking?!1:!t.entities.find(i=>i.position.x===e.x&&i.position.y===e.y&&i.blocking&&i.type!=="player"&&i.type!=="enemy")}getEnemyAt(e){return this.gameState.currentDungeon.entities.find(t=>t.position.x===e.x&&t.position.y===e.y&&t.type==="enemy")}getItemAt(e){return this.gameState.currentDungeon.entities.find(t=>t.position.x===e.x&&t.position.y===e.y&&t.type==="item")}getEntityAt(e,t){return this.gameState.currentDungeon.entities.find(s=>s.position.x===e.x&&s.position.y===e.y&&(t?s.type===t:!0))}getPlayerPosition(){return this.playerController.getPosition()}calculateNextPosition(e){return this.playerController.move(e)}evaluateMovementRisk(e){const t=this.gameState.currentDungeon,s=this.getNearbyEnemies(e,1);if(s.length>=3)return"danger";if(s.length>=1)return"caution";const a=t.tiles[e.y]?.[e.x];return a&&!a.explored?"caution":"safe"}getNearbyEnemies(e,t=1){const s=[];for(let a=-t;a<=t;a++)for(let i=-t;i<=t;i++){if(i===0&&a===0)continue;const o={x:e.x+i,y:e.y+a},n=this.getEnemyAt(o);n&&s.push(n)}return s}suggestMovement(e){const t=this.getPlayerPosition(),s=[],a=e.x-t.x,i=e.y-t.y;return a>0?s.push("east"):a<0&&s.push("west"),i>0?s.push("south"):i<0&&s.push("north"),s}getValidDirections(){return this.getPlayerPosition(),["north","south","east","west"].filter(t=>{const s=this.calculateNextPosition(t);return this.isValidMove(s)})}getMovementStats(){const e=this.getPlayerPosition(),t=this.getValidDirections(),s=this.getNearbyEnemies(e),a=this.getNearbyItems(e),i=this.evaluateMovementRisk(e);return{currentPosition:e,validDirections:t,nearbyEnemies:s.length,nearbyItems:a.length,movementRisk:i}}getNearbyItems(e,t=1){const s=[];for(let a=-t;a<=t;a++)for(let i=-t;i<=t;i++){const o={x:e.x+i,y:e.y+a},n=this.getItemAt(o);n&&s.push(n)}return s}preventWallCollision(e){const t=this.calculateNextPosition(e),s=this.gameState.currentDungeon;return x(t,s.dimensions)?!s.tiles[t.y][t.x].blocking:!1}forceMove(e){this.playerController.setPosition(e),this.gameState.player.position=e,w.updateFieldOfView(this.gameState.currentDungeon,e)}}class Te{constructor(e,t,s,a,i,o,n,c){this.gameState=e,this.playerController=t,this.dungeonManager=s,this.addMessage=a,this.processTurnCallback=i,this.getCombatAttackModeCallback=o,this.setCombatAttackModeCallback=n,this.updateTutorialProgressCallback=c}handleInteract(){if(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")return;const e=this.gameState.player.position,t=this.dungeonManager.hasStairsAt(e);if(t){this.handleStairsInteraction(t);return}this.handleItemPickup(e)}handleStairsInteraction(e){const t=this.dungeonManager.getCurrentFloor();let s;if(e==="down")s=t+1,this.addMessage(g("descendingToFloor",{floor:s.toString()}));else{if(s=t-1,s<1){this.addMessage(g("cannotGoUp"));return}this.addMessage(g("returningToFloor",{floor:s.toString()}))}this.moveToFloor(s)}moveToFloor(e){const t=this.getCombatAttackModeCallback();this.dungeonManager.saveDungeonState(this.gameState.currentDungeon);const s=this.playerController.getPlayer(),a=this.dungeonManager.moveToFloor(e,s);this.updateGameStateForNewFloor(a,s.position),t&&this.setCombatAttackModeCallback(),w.updateFieldOfView(a,s.position),this.addMessage(g("arrivedAtFloor",{floor:e.toString()}))}updateGameStateForNewFloor(e,t){this.gameState.currentDungeon=e,this.gameState.dungeonData=this.dungeonManager.getDungeonData(),this.gameState.player.position=t,this.gameState.currentDungeon.player=this.gameState.player,this.gameState.levelCleared=!1,this.playerController.setPosition(t)}handleItemPickup(e){const s=this.gameState.currentDungeon.entities.find(a=>a.position.x===e.x&&a.position.y===e.y&&a.type==="item");s?(console.log("FloorManager: Picking up item:",s),this.pickupItem(s)):(console.log("FloorManager: No item at player position"),this.addMessage(g("cannotInteract")))}pickupItem(e){if(this.playerController.addItem(e)){if(this.gameState.status==="tutorial"){const s=(globalThis.game||window.game)?.getTutorialSystem?.(),a=s?.getTutorialItemPickupMessage?.(e.itemType||e.name||"unknown");a?this.addMessage(a):this.addMessage(g("pickedUpItemWithName",{char:e.char,item:d(e)})),s?.getCurrentStepId?.()==="step_equipment"&&(e.itemType==="weapon"||e.itemType==="armor")&&(console.log("Equipment item picked up in tutorial:",e.itemType),console.log("tutorialSystem available:",!!s),console.log("markEquipmentPickedUp available:",!!s?.markEquipmentPickedUp),s.markEquipmentPickedUp&&s.markEquipmentPickedUp(),s.updateProgress&&s.updateProgress(this.gameState))}else this.addMessage(g("pickedUpItemWithName",{char:e.char,item:d(e)}));this.removeItemFromDungeon(e),this.gameState.status==="tutorial"&&this.updateTutorialProgressCallback&&this.updateTutorialProgressCallback("pickup"),this.processTurnCallback()}else this.addMessage(g("inventoryFull"))}removeItemFromDungeon(e){const t=this.gameState.currentDungeon,s=t.entities.findIndex(a=>a.id===e.id);s!==-1&&t.entities.splice(s,1)}getStairsAtPosition(e){return this.dungeonManager.hasStairsAt(e)}getItemAtPosition(e){return this.gameState.currentDungeon.entities.find(a=>a.position.x===e.x&&a.position.y===e.y&&a.type==="item")||null}getCurrentFloorInfo(){const e=this.dungeonManager.getCurrentFloor(),t=this.gameState.currentDungeon;let s=!1,a=!1,i=0,o=0;return t.entities.forEach(n=>{n.type==="item"&&i++,n.type==="enemy"&&o++}),s=e>1,a=!0,{currentFloor:e,hasUpStairs:s,hasDownStairs:a,itemsOnFloor:i,enemiesOnFloor:o}}checkFloorCompletion(){return this.gameState.currentDungeon.entities.filter(s=>s.type==="enemy").length===0}completeFloor(){this.checkFloorCompletion()&&(this.gameState.levelCleared=!0,this.addMessage(g("levelCleared")),this.gameState.score+=50,this.addMessage(g("floorBonus")))}emergencyExit(){this.moveToFloor(1),this.addMessage(g("emergencyExit"))}getFloorStats(){const e=this.dungeonManager.getCurrentFloor(),t=this.dungeonManager.getDungeonData();return{floorsVisited:Object.keys(t.floors).length,currentFloor:e,totalItems:0,totalEnemies:0,floorsCleared:0}}shouldPickupItem(e){return this.playerController.getPlayer().inventory.length>=10?{shouldPickup:!1,reason:"インベントリが満杯です"}:e.itemType==="consumable"?{shouldPickup:!0,reason:"消耗品は常に有用です"}:e.itemType==="weapon"||e.itemType==="armor"?{shouldPickup:!0,reason:"装備品はアップグレードの可能性があります"}:{shouldPickup:!0,reason:"アイテムを取得することを推奨します"}}getInteractableAtPosition(e){const t=this.getStairsAtPosition(e);if(t)return{type:"stairs",details:{direction:t}};const s=this.getItemAtPosition(e);return s?{type:"item",details:{item:s}}:{type:"none",details:null}}}class I{static SAVE_KEY="terminal-descent-save";static SAVE_VERSION="1.0.0";save(e){try{const t=this.createSaveData(e),s=JSON.stringify(t);return localStorage.setItem(I.SAVE_KEY,s),{success:!0,message:"ゲームを保存しました"}}catch(t){return{success:!1,message:"セーブに失敗しました",error:t instanceof Error?t.message:"Unknown error"}}}load(){try{const e=localStorage.getItem(I.SAVE_KEY);if(!e)return null;const t=JSON.parse(e);return this.isValidSaveData(t)?t:(console.warn("Invalid save data structure detected"),null)}catch(e){return console.error("Failed to load save data:",e),null}}hasSave(){return localStorage.getItem(I.SAVE_KEY)!==null}deleteSave(){try{return localStorage.removeItem(I.SAVE_KEY),{success:!0,message:"セーブデータを削除しました"}}catch(e){return{success:!1,message:"セーブデータの削除に失敗しました",error:e instanceof Error?e.message:"Unknown error"}}}createSaveData(e){return{version:I.SAVE_VERSION,timestamp:Date.now(),player:{position:{...e.player.position},hp:e.player.health,maxHp:e.player.maxHealth,energy:e.player.energy,maxEnergy:e.player.maxEnergy,level:e.player.level,exp:e.player.experience,inventory:[...e.player.inventory],equipment:{...e.player.equipment}},dungeon:{currentFloor:e.dungeonData.currentFloor,seed:0,exploredTiles:[]},gameStats:{turnCount:e.turn,score:e.score,enemiesDefeated:0},metadata:{playTime:0,lastSaveLocation:`floor_${e.dungeonData.currentFloor}_${e.player.position.x}_${e.player.position.y}`}}}isValidSaveData(e){return e&&typeof e.version=="string"&&typeof e.timestamp=="number"&&e.player&&typeof e.player.hp=="number"&&typeof e.player.level=="number"&&e.dungeon&&typeof e.dungeon.currentFloor=="number"&&e.gameStats&&typeof e.gameStats.turnCount=="number"}}class Me{canvas;ctx;config;camera;renderedTexts=[];constructor(e,t){this.canvas=e;const s=e.getContext("2d");if(!s)throw new Error("Failed to get 2D rendering context");this.ctx=s,this.config=t,this.camera={position:{x:0,y:0},viewport:t.viewport,target:{x:0,y:0}},this.setupCanvas()}trackableFillText(e,t,s){this.renderedTexts.push(e),this.ctx.fillText(e,t,s)}getRenderedTexts(){return[...this.renderedTexts]}clearRenderedTexts(){this.renderedTexts=[]}setupCanvas(){this.canvas.width=this.config.viewport.width,this.canvas.height=this.config.viewport.height,this.ctx.imageSmoothingEnabled=!1,this.ctx.font=`${this.config.fontSize}px ${this.config.fontFamily}`,this.ctx.textAlign="center",this.ctx.textBaseline="middle"}clear(){this.ctx.fillStyle=this.config.colors.background,this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)}updateCamera(e){this.camera.target=e;const t=Math.floor(this.config.viewport.width/this.config.tileSize),s=Math.floor(this.config.viewport.height/this.config.tileSize);this.camera.position={x:e.x-Math.floor(t/2),y:e.y-Math.floor(s/2)}}worldToScreen(e){return{x:(e.x-this.camera.position.x)*this.config.tileSize,y:(e.y-this.camera.position.y)*this.config.tileSize}}isVisible(e){const t=this.worldToScreen(e);return t.x>=-this.config.tileSize&&t.x<this.config.viewport.width&&t.y>=-this.config.tileSize&&t.y<this.config.viewport.height}renderCharacter(e,t,s,a){a&&(this.ctx.fillStyle=a,this.ctx.fillRect(t.x,t.y,this.config.tileSize,this.config.tileSize)),this.ctx.fillStyle=s,this.trackableFillText(e,t.x+this.config.tileSize/2,t.y+this.config.tileSize/2)}renderTile(e){if(!this.isVisible(e.position))return;const t=this.worldToScreen(e.position);if(!e.explored)return;const s=e.visible?e.color:this.config.colors.explored,a=e.visible?e.backgroundColor:void 0;this.renderCharacter(e.char,t,s,a)}renderEntity(e){if(!e.visible||!this.isVisible(e.position))return;const t=this.worldToScreen(e.position);this.renderCharacter(e.char,t,e.color,e.backgroundColor)}render(e){if(this.clear(),this.clearRenderedTexts(),this.ctx.filter="none",e.status==="welcome"){this.renderWelcomeScreen(e);return}const t=e.currentDungeon;this.updateCamera(t.player.position);for(let s=0;s<t.dimensions.height;s++)for(let a=0;a<t.dimensions.width;a++){const i=t.tiles[s][a];i&&this.renderTile(i)}e.status==="tutorial"&&this.renderTutorialHighlights(e),t.entities.filter(s=>s.type!=="player").forEach(s=>this.renderEntity(s)),this.renderEntity(t.player),this.renderUI(e),e.overlay.isVisible&&this.renderOverlay(e),this.updateTestElements(e)}renderUI(e){const t=e.player,s=10,a=20;this.ctx.save(),this.ctx.font=`14px ${this.config.fontFamily}`,this.ctx.textAlign="left",this.ctx.fillStyle=this.config.colors.text;const i=[`${r("level")}: ${t.level}`,`${r("health")}: ${t.health}/${t.maxHealth}`,`${r("energy")}: ${t.energy}/${t.maxEnergy}`,`${r("accessLevel")}: ${t.accessLevel}`,`${r("turn")}: ${e.turn}`];i.forEach((h,p)=>{this.ctx.fillText(h,s,s+p*a)}),e.status==="tutorial"&&this.renderTutorialInfo(e,s,s+i.length*a+20);const o=L(t),n=[`${r("attackPowerLabel")}: ${o.attackPower}`,`${r("defenseLabel")}: ${o.totalDefense}`,`${r("experienceLabel")}: ${t.experience}/${t.experienceToNext}`],c=this.canvas.width-200;if(n.forEach((h,p)=>{this.ctx.fillText(h,c,s+p*a)}),e.messages.length>0){const h=Math.floor(this.canvas.height*.3/a),p=e.messages.slice(-h);p.forEach((u,m)=>{const f=this.canvas.height-s-(p.length-m)*a,D=Z(u);this.ctx.fillText(D,s,f)})}this.ctx.restore()}getCameraPosition(){return{...this.camera.position}}screenToWorld(e){return{x:Math.floor(e.x/this.config.tileSize)+this.camera.position.x,y:Math.floor(e.y/this.config.tileSize)+this.camera.position.y}}renderOverlay(e){switch(this.ctx.save(),this.ctx.fillStyle="rgba(0, 0, 0, 0.7)",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),e.overlay.type){case"inventory":this.renderInventoryOverlay(e);break;case"character":this.renderStatusOverlay(e);break;case"takeoff":this.renderTakeoffOverlay(e);break;case"equipment":this.renderEquipmentOverlay(e);break;case"pauseMenu":this.renderPauseMenuOverlay(e);break}this.ctx.restore()}renderInventoryOverlay(e){const s=e.player.inventory,a=400,i=Math.min(500,s.length*30+100),o=(this.canvas.width-a)/2,n=(this.canvas.height-i)/2;this.ctx.fillStyle="#1a1a1a",this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.fillRect(o,n,a,i),this.ctx.strokeRect(o,n,a,i),this.ctx.font="16px Courier New, monospace",this.ctx.textAlign="left",this.ctx.fillStyle="#00ff00",this.trackableFillText(r("inventoryHeader"),o+20,n+30),this.ctx.font="12px Courier New, monospace",this.ctx.fillStyle="#888888",this.ctx.fillText(r("closeInstruction"),o+20,n+50),this.ctx.font="14px Courier New, monospace";const c=n+80;s.length===0?(this.ctx.fillStyle="#666666",this.ctx.fillText(r("emptyInventoryMessage"),o+20,c)):s.forEach((h,p)=>{const u=c+p*25;e.overlay.selectedIndex===p&&(this.ctx.fillStyle="rgba(0, 255, 0, 0.2)",this.ctx.fillRect(o+10,u-15,a-20,20)),this.ctx.fillStyle="#ffff00",this.ctx.fillText(`${p+1}.`,o+20,u),this.ctx.fillStyle=h.color,this.ctx.fillText(h.char,o+50,u),this.ctx.fillStyle="#00ff00",this.ctx.fillText(`${h.name} x${h.quantity}`,o+70,u),this.ctx.font="10px Courier New, monospace",this.ctx.fillStyle="#888888",this.ctx.fillText(h.description,o+70,u+12),this.ctx.font="14px Courier New, monospace"})}renderStatusOverlay(e){const t=e.player,s=400,a=500,i=(this.canvas.width-s)/2,o=(this.canvas.height-a)/2;this.ctx.fillStyle="#1a1a1a",this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.fillRect(i,o,s,a),this.ctx.strokeRect(i,o,s,a),this.ctx.font="16px Courier New, monospace",this.ctx.textAlign="left",this.ctx.fillStyle="#00ff00",this.trackableFillText(r("statusHeader"),i+20,o+30),this.ctx.font="12px Courier New, monospace",this.ctx.fillStyle="#888888",this.ctx.fillText(r("statusCloseInstruction"),i+20,o+50),this.ctx.font="14px Courier New, monospace",this.ctx.fillStyle="#00ff00";const n=[{label:r("level"),value:`${t.level}`,color:"#ffff00"},{label:"HP",value:`${t.health}/${t.maxHealth}`,color:t.health<t.maxHealth*.3?"#ff4444":"#00ff00"},{label:r("energy"),value:`${t.energy}/${t.maxEnergy}`,color:t.energy<t.maxEnergy*.3?"#ffaa00":"#00ff00"},{label:"EXP",value:`${t.experience}/${t.experienceToNext}`,color:"#88ff88"},{label:r("accessLevel"),value:`${t.accessLevel}`,color:"#00ffff"},{label:r("turn"),value:`${e.turn}`,color:"#888888"},{label:"SCORE",value:`${e.score}`,color:"#ffff00"}],c=o+80;n.forEach((h,p)=>{const u=c+p*25;this.ctx.fillStyle="#00ff00",this.trackableFillText(`${h.label}:`,i+20,u),this.ctx.fillStyle=h.color,this.trackableFillText(h.value,i+150,u)}),this.ctx.font="16px Courier New, monospace",this.ctx.fillStyle="#00ff00",this.trackableFillText(r("equipmentHeader"),i+20,o+260),this.renderEquipmentDetails(t,i+20,o+285)}renderEquipmentDetails(e,t,s){this.ctx.font="12px Courier New, monospace";const a=X(e),i=[{key:"weapon",label:r("weaponSlot")},{key:"head",label:r("headSlot")},{key:"chest",label:r("chestSlot")},{key:"legs",label:r("legsSlot")},{key:"feet",label:r("feetSlot")},{key:"shield",label:r("shieldSlot")}];let o=s;i.forEach(c=>{const h=a[c.key];this.ctx.fillStyle="#00ff00",this.trackableFillText(`${c.label}:`,t,o),this.ctx.fillStyle=h!==r("noItem")?"#ffff00":"#666666",this.trackableFillText(h,t+60,o),o+=15}),o+=10,this.ctx.fillStyle="#00ff00",this.trackableFillText(r("equipmentStatsHeader"),t,o),o+=20;const n=L(e);this.ctx.fillStyle="#88ff88",this.trackableFillText(`${r("totalDefenseLabel")}: ${n.totalDefense}`,t,o),o+=15,this.ctx.fillStyle="#ff8888",this.trackableFillText(`${r("attackPowerLabel")}: ${n.attackPower}`,t,o)}renderTakeoffOverlay(e){const t=e.player,s=["mainHand","head","chest","legs","feet","offHand"],a=[];if(s.forEach(u=>{const m=t.equipment[u];m&&a.push({slot:u,item:m,displayName:d(m)})}),a.length===0)return;const i=400,o=Math.min(400,a.length*30+150),n=(this.canvas.width-i)/2,c=(this.canvas.height-o)/2;this.ctx.fillStyle="#1a1a1a",this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.fillRect(n,c,i,o),this.ctx.strokeRect(n,c,i,o),this.ctx.font="16px Courier New, monospace",this.ctx.textAlign="left",this.ctx.fillStyle="#00ff00",this.ctx.fillText(r("takeoffHeader"),n+20,c+30),this.ctx.font="12px Courier New, monospace",this.ctx.fillStyle="#888888",this.ctx.fillText(r("takeoffInstruction"),n+20,c+50),this.ctx.font="14px Courier New, monospace";const h=e.overlay.selectedIndex||0;a.forEach((u,m)=>{const f=c+80+m*25,D=m===h;D&&(this.ctx.fillStyle="#333333",this.ctx.fillRect(n+15,f-12,i-30,20)),this.ctx.fillStyle="#00ff00";const T=this.getSlotDisplayName(u.slot);this.ctx.fillText(`${T}:`,n+20,f),this.ctx.fillStyle=D?"#ffff00":"#ffffff";const H=u.item.char||"?";this.ctx.fillText(`${H} ${u.displayName}`,n+100,f)}),this.ctx.font="12px Courier New, monospace",this.ctx.fillStyle="#888888";const p=c+o-30;this.ctx.fillText(r("takeoffControls"),n+20,p)}renderEquipmentOverlay(e){const t=e.player,s=[{slot:"mainHand",label:"武器",item:t.equipment.mainHand},{slot:"head",label:"頭",item:t.equipment.head},{slot:"chest",label:"胴",item:t.equipment.chest},{slot:"legs",label:"脚",item:t.equipment.legs},{slot:"feet",label:"足",item:t.equipment.feet},{slot:"offHand",label:"盾",item:t.equipment.offHand}],a=600,i=380,o=(this.canvas.width-a)/2,n=(this.canvas.height-i)/2;this.ctx.fillStyle="#1a1a1a",this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.fillRect(o,n,a,i),this.ctx.strokeRect(o,n,a,i),this.ctx.save(),this.ctx.font="bold 20px Courier New, monospace",this.ctx.textAlign="center",this.ctx.fillStyle="#00ff00";const c="装備一覧",h=o+a/2;this.trackableFillText(c,h,n+35),this.ctx.restore(),this.ctx.font="16px Courier New, monospace",this.ctx.textAlign="left",this.ctx.textBaseline="middle";let p=n+85;s.forEach(({label:D,item:T})=>{const H=o+40,G=60;this.ctx.fillStyle="#888888",this.ctx.textAlign="left",this.trackableFillText(`${D}:`,H,p);const R=H+G;if(T){this.ctx.fillStyle="#ffffff";const W=T.char||"?",V=d(T);let O="";"damage"in T?O=` (+${T.damage})`:"defense"in T&&(O=` (+${T.defense})`);const B=`${W} ${V}${O}`;this.ctx.textAlign="left",this.trackableFillText(B,R,p),p+=30}else this.ctx.fillStyle="#666666",this.ctx.textAlign="left",this.trackableFillText("なし",R,p),p+=30}),this.ctx.save(),this.ctx.font="12px Courier New, monospace",this.ctx.textAlign="center",this.ctx.fillStyle="#888888";const u="ESC: 閉じる, T: 装備を外す",m=o+a/2,f=n+i-20;this.trackableFillText(u,m,f),this.ctx.restore()}renderPauseMenuOverlay(e){this.applyGlassEffect();const t=300,s=250,a=(this.canvas.width-t)/2,i=(this.canvas.height-s)/2;this.ctx.fillStyle="#1a1a1a",this.ctx.fillRect(a,i,t,s),this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.strokeRect(a,i,t,s),this.ctx.font="bold 18px Courier New, monospace",this.ctx.fillStyle="#00ff00",this.ctx.textAlign="center",this.ctx.fillText(r("pauseMenuTitle"),a+t/2,i+40);const o=[{key:"continueGame",index:0},{key:"saveGame",index:1},{key:"loadGame",index:2},{key:"languageSwitch",index:3},{key:"returnToTitle",index:4}],n=i+80,c=30;this.ctx.font="14px Courier New, monospace",this.ctx.textAlign="left",o.forEach((p,u)=>{const m=n+u*c,f=e.overlay.selectedIndex===u;f&&(this.ctx.fillStyle="#003300",this.ctx.fillRect(a+10,m-18,t-20,22),this.ctx.fillStyle="#00ff00",this.ctx.fillText(">",a+20,m)),this.ctx.fillStyle=f?"#ffffff":"#cccccc",this.ctx.fillText(r(p.key),a+40,m)}),this.ctx.font="12px Courier New, monospace",this.ctx.fillStyle="#888888",this.ctx.textAlign="center";const h=i+s-20;this.ctx.fillText("↑↓: Select  Enter: Confirm  ESC: Close",a+t/2,h)}getSlotDisplayName(e){return{mainHand:r("weaponSlot"),head:r("headSlot"),chest:r("chestSlot"),legs:r("legsSlot"),feet:r("feetSlot"),offHand:r("shieldSlot")}[e]||e}resize(e){this.config.viewport=e,this.canvas.width=e.width,this.canvas.height=e.height,this.setupCanvas()}renderWelcomeScreen(e){const t=this.canvas.width/2,s=this.canvas.height/2;if(e.welcome.showPrologue){this.renderPrologue();return}this.ctx.fillStyle=this.config.colors.text,this.ctx.font=`${this.config.fontSize*2}px ${this.config.fontFamily}`,this.ctx.textAlign="center",this.ctx.fillText(r("welcomeTitle"),t,s-120),this.ctx.font=`${this.config.fontSize}px ${this.config.fontFamily}`,this.ctx.fillText(r("welcomeSubtitle"),t,s-50);const a=N("menuOptions");[{key:"start",text:a[0]},{key:"tutorial",text:a[1]},{key:"settings",text:a[2]}].forEach((o,n)=>{const c=s+n*30,h=e.welcome.selectedOption===o.key;if(this.ctx.fillStyle=h?this.config.colors.player:this.config.colors.text,h){const p=this.ctx.measureText(o.text).width,u=20;this.ctx.fillText(">",t-p/2-u,c),this.ctx.fillText("<",t+p/2+u,c)}this.ctx.fillText(o.text,t,c)}),this.ctx.fillStyle=this.config.colors.explored,this.ctx.fillText(r("menuInstructions"),t,s+120),e.welcome.selectedOption||(e.welcome.selectedOption="start"),this.updateTestElements(e)}renderPrologue(){const e=this.canvas.width/2,t=this.canvas.height/2;this.ctx.fillStyle=this.config.colors.text,this.ctx.font=`${this.config.fontSize}px ${this.config.fontFamily}`,this.ctx.textAlign="center",N("prologueLines").forEach((a,i)=>{this.ctx.fillText(a,e,t-100+i*25)})}renderTutorialHighlights(e){const t=e.interactiveTutorial;t&&t.isActive&&t.currentStep.targetPosition&&this.renderTargetHighlight(t.currentStep.targetPosition)}renderTutorialInfo(e,t,s){const a=e.interactiveTutorial;if(!a||!a.isActive)return;const i=20,o=[`チュートリアル: ${a.currentStep.title}`,a.currentStep.description,`ステップ: ${a.progress.currentStep}/${a.progress.totalSteps}`];this.ctx.fillStyle="#ffff00",this.ctx.font=`16px ${this.config.fontFamily}`,o.forEach((n,c)=>{this.ctx.fillText(n,t,s+c*i)})}renderTargetHighlight(e){const t=this.worldToScreen(e);this.ctx.fillStyle="rgba(0, 255, 0, 0.3)",this.ctx.fillRect(t.x,t.y,this.config.tileSize,this.config.tileSize),this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.strokeRect(t.x,t.y,this.config.tileSize,this.config.tileSize)}updateTestElements(e){try{const t=document.getElementById("test-game-status");t&&(t.textContent=e.status,t.setAttribute("data-game-status",e.status));const s=document.getElementById("test-tutorial-status");if(s){const c=e.tutorial.isActive?`active-${e.tutorial.currentStep}`:"inactive";s.textContent=c,s.setAttribute("data-tutorial-status",c)}const a=document.getElementById("test-start-button"),i=document.getElementById("test-tutorial-button"),o=document.getElementById("test-settings-button");a&&i&&o&&([a,i,o].forEach(c=>{c.removeAttribute("data-selected")}),e.welcome.selectedOption==="start"?a.setAttribute("data-selected","true"):e.welcome.selectedOption==="tutorial"?i.setAttribute("data-selected","true"):e.welcome.selectedOption==="settings"&&o.setAttribute("data-selected","true"));const n=document.getElementById("test-equipment-section");if(n){const c=e.overlay.type==="character"&&e.overlay.isVisible;if(n.setAttribute("data-visible",c.toString()),e.player?.equipment){const h=JSON.stringify({mainHand:e.player.equipment.mainHand?.nameKey||"none",head:e.player.equipment.head?.nameKey||"none",chest:e.player.equipment.chest?.nameKey||"none",legs:e.player.equipment.legs?.nameKey||"none",feet:e.player.equipment.feet?.nameKey||"none",offHand:e.player.equipment.offHand?.nameKey||"none"});n.setAttribute("data-equipment",h)}}}catch{console.debug("Test elements not found, skipping update")}}applyGlassEffect(){this.ctx.filter="blur(6px) brightness(0.6)";const e=this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height);this.ctx.putImageData(e,0,0),this.ctx.filter="none"}}class Ce{gameState;playerController;dungeonGenerator;dungeonManager;inventoryManager;overlayManager;tutorialSystem;uiManager;inputManager;gameStateManager;combatManager;equipmentManager;movementManager;floorManager;saveManager;renderer;lastUpdateTime;animationFrameId;constructor(e){this.playerController=new se({x:0,y:0}),this.dungeonGenerator=new w({width:80,height:50},1),this.dungeonManager=new ce,this.gameStateManager=new fe(this.playerController,this.dungeonManager),this.inventoryManager=null;const t={tileSize:16,fontSize:14,fontFamily:"Courier New, monospace",viewport:{width:e.width,height:e.height},colors:{background:"#000000",text:"#00ff00",player:"#00ff00",enemy:"#ff4444",wall:"#444444",floor:"#666666",explored:"#333333",visible:"#ffffff"}};this.renderer=new Me(e,t),this.gameState=this.gameStateManager.createInitialGameState(),this.inventoryManager=new v(this.gameState,this.playerController,s=>this.addMessage(s),()=>this.processTurn(),s=>this.handleTutorialProgress(s),s=>this.equipmentManager.equipItemFromInventory(s),()=>this.equipmentManager.getCurrentEquipmentDisplay(),s=>this.addMessages(s),()=>this.notifyEquipmentToggle()),this.overlayManager=new he(this.gameState,this.playerController,s=>this.useItem(s),s=>{this.equipmentManager.removeEquipment(s),this.gameState.status==="tutorial"&&this.notifyEquipmentToggle()},s=>this.addMessage(s)),this.tutorialSystem=new me,this.tutorialSystem.setCallbacks({addMessage:s=>this.addMessage(s),updatePlayerPosition:s=>this.playerController.setPosition(s),processTurn:()=>this.processTurn(),setGameStatus:s=>this.gameState.status=s,updateTiles:s=>this.gameState.currentDungeon.tiles=s}),this.uiManager=new ge(this.gameState,s=>this.addMessage(s),()=>this.startGame(),async()=>await this.startTutorial()),this.combatManager=new Se(this.gameState,this.playerController,s=>this.addMessage(s),s=>this.movementManager.getEnemyAt(s),()=>this.processTurn(),s=>this.handleTutorialProgress(s),()=>{this.gameState.status==="tutorial"&&(this.tutorialSystem.markCombatCompleted(),this.tutorialSystem.updateProgress(this.gameState))}),this.equipmentManager=new ve(this.gameState,this.playerController,s=>this.addMessage(s)),this.movementManager=new xe(this.gameState,this.playerController,s=>this.addMessage(s),()=>this.processTurn(),s=>this.handleTutorialProgress(s)),this.floorManager=new Te(this.gameState,this.playerController,this.dungeonManager,s=>this.addMessage(s),()=>this.processTurn(),()=>this.combatManager.isAttackMode(),()=>this.combatManager.toggleAttackMode(),s=>this.handleTutorialProgress(s)),this.saveManager=new I,this.inputManager=new ye(e,this.gameState,s=>this.handleDirectionalInput(s),()=>this.handleToggleAttackMode(),()=>this.handleInteract(),()=>this.handleToggleInventory(),()=>this.handleToggleStatus(),()=>this.handleToggleTakeoff(),s=>this.handleItemAction(s),()=>this.togglePause(),()=>this.uiManager.showMenu(),()=>this.uiManager.handleLanguageSwitch(),()=>this.handleEquipmentToggle()),this.lastUpdateTime=0}handleDirectionalInput(e){if(this.gameState.status==="welcome"){this.handleWelcomeNavigation(e);return}if(this.gameState.overlay.type==="pauseMenu"&&this.gameState.overlay.isVisible){this.handlePauseMenuNavigation(e);return}if(!(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")){if(this.overlayManager.isVisible()){this.overlayManager.handleNavigation(e);return}if(this.gameState.status==="tutorial"){if(this.combatManager.isAttackMode()&&!this.tutorialSystem.isActionAllowed("attack")){this.addMessage("このチュートリアルステップでは攻撃はできません。");return}if(!this.combatManager.isAttackMode()&&!this.tutorialSystem.isActionAllowed("move")){this.addMessage("このチュートリアルステップでは移動はできません。");return}}this.combatManager.isAttackMode()?this.combatManager.handleAttack(e):(this.movementManager.handlePlayerMove(e),this.gameState.status==="tutorial"&&this.tutorialSystem.updateProgress(this.gameState))}}handleInteract(){if(this.gameState.status==="welcome"){this.uiManager.handleWelcomeInteract();return}if(this.gameState.overlay.type==="pauseMenu"&&this.gameState.overlay.isVisible){this.handleMenuSelect();return}if(!(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")){if(this.overlayManager.isVisible()){this.overlayManager.handleInteraction();return}if(this.gameState.status==="tutorial"&&!this.tutorialSystem.isActionAllowed("pickup_item")){this.addMessage("このチュートリアルステップではアイテムの取得はできません。");return}this.floorManager.handleInteract(),this.gameState.status==="tutorial"&&this.tutorialSystem.updateProgress(this.gameState)}}handleTutorialProgress(e){this.gameState.status==="tutorial"&&(this.tutorialSystem.updateProgress(this.gameState),this.tutorialSystem.markActionCompleted(e),e==="movement"&&this.tutorialSystem.updateProgress(this.gameState))}showInventory(){this.inventoryManager.showInventory()}useItem(e){console.log("=== Game.useItem CALLED ==="),console.log(`Game.useItem called with index: ${e}, tutorial status: ${this.gameState.status}`);const t=this.inventoryManager.useItem(e);console.log(`Item use success: ${t}`),t&&this.gameState.status==="tutorial"&&(console.log("Marking item as used in tutorial system"),this.tutorialSystem.markItemUsed(),this.tutorialSystem.updateProgress(this.gameState))}processTurn(){this.gameState.turn++,this.processEnemies(),this.checkGameState(),this.gameState.status==="tutorial"&&this.tutorialSystem.updateProgress(this.gameState)}processEnemies(){const e=this.gameState.currentDungeon,t=this.gameState.player.position;e.entities.filter(s=>s.type==="enemy").forEach(s=>{const a=Math.abs(s.position.x-t.x)+Math.abs(s.position.y-t.y);if(a<=3)if(a===1){const i="damage"in s?s.damage:10,o=this.playerController.getTotalDefense(),n=Math.max(1,i-o);this.playerController.takeDamage(n),this.gameState.player.health=this.playerController.getPlayer().health,this.gameState.currentDungeon.player.health=this.gameState.player.health;const c=this.playerController.getPlayer().health,h=this.playerController.getPlayer().maxHealth;o>0?this.addMessage(r("enemyAttackWithDefense").replace("{{enemy}}",q(s)).replace("{{damage}}",n.toString()).replace("{{defense}}",o.toString()).replace("{{health}}",Math.max(0,c).toString()).replace("{{maxHealth}}",h.toString())):this.addMessage(r("enemyAttackNormal").replace("{{enemy}}",q(s)).replace("{{damage}}",n.toString()).replace("{{health}}",Math.max(0,c).toString()).replace("{{maxHealth}}",h.toString())),this.playerController.isDead()&&(this.gameState.status="gameOver",this.addMessage(`${r("youDied")} ${r("gameOver")}`))}else{const i=Math.sign(t.x-s.position.x),o=Math.sign(t.y-s.position.y),n={x:s.position.x+i,y:s.position.y+o};this.isValidEnemyMove(n)&&(s.position=n)}})}isValidEnemyMove(e){const t=this.gameState.currentDungeon;return!x(e,t.dimensions)||t.tiles[e.y][e.x].blocking?!1:!t.entities.find(i=>i.position.x===e.x&&i.position.y===e.y&&i.blocking&&i.type!=="player")}checkGameState(){if(this.playerController.isDead()){this.gameState.status="gameOver",this.addMessage(r("gameOver"));return}if(this.gameState.status!=="tutorial"&&this.gameState.currentDungeon.entities.filter(t=>t.type==="enemy").length===0&&!this.gameState.levelCleared){this.gameState.score+=100,this.gameState.levelCleared=!0,this.addMessage(r("levelCleared"));const t=this.gameState.dungeonData.currentFloor,s=this.gameState.dungeonData.maxFloor;t<s?(this.addExitStairs(),this.addMessage(r("stairsAppeared"))):this.addMessage(r("allFloorsCleared"))}}addExitStairs(){const e=this.gameState.currentDungeon,t=e.rooms;if(t.length===0)return;const s=t[t.length-1],a={x:s.position.x+Math.floor(s.dimensions.width/2),y:s.position.y+Math.floor(s.dimensions.height/2)};if(e.entities.find(n=>n.position.x===a.x&&n.position.y===a.y)){const n=[{x:a.x+1,y:a.y},{x:a.x-1,y:a.y},{x:a.x,y:a.y+1},{x:a.x,y:a.y-1}];for(const c of n)if(c.x>=s.position.x&&c.x<s.position.x+s.dimensions.width&&c.y>=s.position.y&&c.y<s.position.y+s.dimensions.height&&!e.entities.find(p=>p.position.x===c.x&&p.position.y===c.y)){a.x=c.x,a.y=c.y;break}}const o=e.tiles[a.y][a.x];o&&(o.type="stairs",o.char=">",o.color="#ffff00",o.backgroundColor="#000000",o.blocking=!1)}togglePause(){if(this.gameState.overlay.type==="pauseMenu"&&this.gameState.overlay.isVisible){this.gameState.overlay.isVisible=!1,this.gameState.overlay.type="none",this.gameState.pausedFromTutorial?(this.gameState.status="tutorial",delete this.gameState.pausedFromTutorial):this.gameState.status="playing";return}if(!this.overlayManager.handlePauseOrClose()&&(console.log("No overlay, proceeding with pause toggle"),this.gameState.status==="playing"||this.gameState.status==="tutorial")){const e=this.gameState.status;this.gameState.status="paused",this.gameState.overlay.type="pauseMenu",this.gameState.overlay.isVisible=!0,this.gameState.overlay.selectedIndex=0,e==="tutorial"&&(this.gameState.pausedFromTutorial=!0)}}handleMenuSelect(){if(this.gameState.overlay.type!=="pauseMenu"||!this.gameState.overlay.isVisible)return;switch(this.gameState.overlay.selectedIndex){case 0:this.togglePause();break;case 1:this.saveGame();break;case 2:this.loadGame();break;case 3:this.uiManager.handleLanguageSwitch();break;case 4:this.returnToTitle();break}}handlePauseMenuNavigation(e){const s=this.gameState.overlay.selectedIndex??0;e==="south"?this.gameState.overlay.selectedIndex=Math.min(s+1,4):e==="north"&&(this.gameState.overlay.selectedIndex=Math.max(s-1,0))}addMessage(e){const t=typeof e=="string"?$(e):e;this.gameState.messages.push(t),this.gameState.messages.length>5&&this.gameState.messages.shift()}addMessages(e){this.gameState.messages=[],e.forEach(t=>{const s=typeof t=="string"?$(t):t;this.gameState.messages.push(s)})}gameLoop=e=>{const t=e-this.lastUpdateTime;this.update(t),this.render(),this.lastUpdateTime=e,this.animationFrameId=requestAnimationFrame(this.gameLoop)};update(e){}render(){if(this.gameState.status==="tutorial"){const e=this.tutorialSystem.state,t=this.tutorialSystem.getCurrentStep();if(t&&e.isActive){const s={id:t.id,title:t.title,description:t.description};t.targetPosition&&(s.targetPosition=t.targetPosition),this.gameState.interactiveTutorial={currentStep:s,progress:{currentStep:e.currentStepIndex+1,totalSteps:e.totalSteps,percentage:Math.round((e.currentStepIndex+1)/e.totalSteps*100)},isActive:!0}}}else delete this.gameState.interactiveTutorial;this.renderer.render(this.gameState)}start(){this.addMessage(r("searchingForExit")),this.lastUpdateTime=performance.now(),this.animationFrameId=requestAnimationFrame(this.gameLoop)}stop(){this.animationFrameId!==void 0&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=void 0)}reset(){this.stop(),this.playerController.reset({x:0,y:0}),this.gameState=this.gameStateManager.createInitialGameState()}getGameState(){return{...this.gameState}}getPlayerStats(){return this.playerController.getStats()}get inputHandler(){return this.inputManager.getInputHandler()}getRenderer(){return this.renderer}pause(){this.gameState.status==="playing"&&(this.gameState.status="paused",this.addMessage(r("gamePaused")))}resume(){this.gameState.status==="paused"&&(this.gameState.status="playing",this.addMessage(r("gameResumed")))}movePlayer(e){this.movementManager.handlePlayerMove(e)}togglePauseTest(){this.togglePause()}setOverlayStateTest(e,t,s=0){this.gameState.overlay={type:e,isVisible:t,selectedIndex:s}}navigateInventoryTest(e){this.overlayManager.handleNavigation(e)}handleDirectionalInputTest(e){this.handleDirectionalInput(e)}handleOverlayInteractionTest(){this.overlayManager.handleInteraction()}toggleAttack(){this.combatManager.toggleAttackMode()}isAttackMode(){return this.combatManager.isAttackMode()}showInventoryTest(){this.showInventory()}useItemTest(e){this.useItem(e)}addItemToPlayer(e){return this.playerController.addItem(e)}attackEnemy(e){this.combatManager.handleAttack(e)}forceMissAttack(e){this.playerController.getPosition(),this.playerController.move(e),this.addMessage(g("noEnemyInThatDirection")),this.combatManager.disableAttackMode(),this.addMessage(g("movementMode"))}getPlayerController(){return this.playerController}toggleTakeoffOverlayTest(){this.overlayManager.toggleTakeoffOverlay()}handleTakeoffInteractionTest(){this.overlayManager.handleInteraction()}navigateTakeoffTest(e){this.overlayManager.handleNavigation(e)}testHandleInteract(){this.handleInteract()}testCastEntityToItem(e){return e}testShowInventory(){this.showInventory()}testUseItem(e){const t=this.playerController.getPlayer().inventory;if(e<0||e>=t.length){this.addMessage(g("noItemInSlot",{slot:(e+1).toString()}));return}const s=t[e];this.inventoryManager.applyItemEffect(s)&&(this.playerController.removeItem(s.id,1),this.gameState.status==="tutorial"&&(this.tutorialSystem.markItemUsed(),this.tutorialSystem.updateProgress(this.gameState)))}testApplyItemEffect(e){return this.inventoryManager.applyItemEffect(e)}testTakeDamage(e){this.playerController.takeDamage(e),this.gameState.player.health=this.playerController.getPlayer().health}handleWelcomeNavigation(e){const t=["start","tutorial","settings"],s=this.gameState.welcome.selectedOption?t.indexOf(this.gameState.welcome.selectedOption):0;let a=s;e==="north"?a=Math.max(0,s-1):e==="south"&&(a=Math.min(t.length-1,s+1)),this.gameState.welcome.selectedOption=t[a]}startGame(){this.gameState.status="playing",this.addMessage(r("welcomeToFacility"))}returnToTitle(){this.gameState.status="title",this.gameState.overlay.type="none",this.gameState.overlay.isVisible=!1,this.gameState.overlay.selectedIndex=0,this.gameState.messages=[]}async startTutorial(){console.log("startTutorial() called - setting up tutorial...");const e=this.playerController.getPlayerDirect(),t=this.dungeonManager.generateTutorialDungeon(e);this.gameState.currentDungeon=t,this.gameState.player.position={...t.player.position},this.playerController.setPosition(t.player.position),console.log(`Player position synced to (${t.player.position.x}, ${t.player.position.y})`),this.gameState.status="tutorial",this.gameState.tutorial.isActive=!0,console.log("Game status set to tutorial"),console.log("Starting unified tutorial system..."),this.tutorialSystem.start();const s=this.tutorialSystem.state;console.log("Unified tutorial system started:",{isActive:s.isActive,currentStepId:s.currentStepId,currentStepIndex:s.currentStepIndex});const a=this.tutorialSystem.getStepInfo();this.addMessage(`チュートリアル: ${a.title}`),this.addMessage(a.description),console.log("Tutorial setup complete:",{gameStatus:this.gameState.status,tutorialSystemActive:s.isActive,currentStep:a})}async startTutorialForTesting(){await this.startTutorial()}openPlayerSurroundingDoors(){const e=this.gameState.player.position,t=this.gameState.currentDungeon.tiles;console.log("openPlayerSurroundingDoors called, player at:",e);const s=[];for(let a=1;a<=10;a++){const i={x:e.x+a,y:e.y};if(t[i.y]&&t[i.y][i.x]){const o=t[i.y][i.x];console.log(`Checking tile at (${i.x}, ${i.y}): type=${o.type}, char="${o.char}", blocking=${o.blocking}`),o.blocking&&s.push(i)}}if(console.log(`Found ${s.length} blocked paths:`,s),s.length>0){const a=s[0];console.log(`Opening door at (${a.x}, ${a.y})`),t[a.y][a.x]={position:a,type:"floor",char:".",color:"#666666",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1},console.log(`Door opened at (${a.x}, ${a.y}) - movement tutorial complete`)}else console.log("No blocked paths found in front of player");console.log("Movement tutorial door opening complete")}openDoorAtStepIndex(e){console.log(`Opening door at step index: ${e}`);const t=this.gameState.currentDungeon.tiles;if(!t){console.log("No tiles available for door opening");return}const s=[{x:13,y:15},{x:25,y:15},{x:37,y:15},{x:49,y:15}];if(e<0||e>=s.length){console.log(`Invalid step index: ${e}`);return}const a=s[e];console.log(`Opening door at position (${a.x}, ${a.y}) for step index ${e}`),t[a.y][a.x]={position:a,type:"floor",char:".",color:"#666666",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1},console.log(`Door at step index ${e} opened successfully`)}skipTutorial(){this.gameState.status="welcome",this.gameState.tutorial.isActive=!1,this.tutorialSystem.reset()}skipTutorialAndStartGame(){this.skipTutorial(),this.startGame()}handleInteractTest(){this.handleInteract()}testGetPlayer(){return this.playerController.getPlayer()}testSetPlayerEnergy(e){this.playerController.getPlayerDirect().energy=e,this.gameState.player.energy=e}testSetPlayerHealth(e){this.playerController.getPlayerDirect().health=e,this.gameState.player.health=e,this.gameState.currentDungeon.player.health=e}testGetCombatManager(){return this.combatManager}testStartGame(){this.startGame()}getCurrentTutorialInfo(){return this.gameState.status!=="tutorial"?null:this.tutorialSystem.getCurrentStepInfo()}getTutorialProgress(){return this.gameState.status!=="tutorial"?null:this.tutorialSystem.getProgress()}isTutorialCompleted(){return this.tutorialSystem.state.isCompleted}debugItemUse(){console.log("=== DEBUG ITEM USE STATE ===");const e=this.tutorialSystem,t=e.state;console.log("Tutorial state:",{currentStepId:t.currentStepId,currentStepIndex:t.currentStepIndex,isActive:t.isActive,progress:t.progress}),this.gameState;const s=e.checkStepCompletion(t.currentStepId||"");console.log("Step completion check:",s);const a=this.playerController.getPlayer().inventory;console.log("Player inventory:",a);const i=this.overlayManager.getOverlayState();console.log("Overlay state:",i),console.log("================================")}getInteractiveTutorialManager(){return this.tutorialSystem}getTutorialSystem(){return this.tutorialSystem}handleToggleAttackMode(){if(this.gameState.status==="tutorial"&&!this.tutorialSystem.isActionAllowed("attack")){this.addMessage("このチュートリアルステップでは攻撃モードに入れません。");return}this.combatManager.toggleAttackMode()}handleToggleInventory(){if(console.log("=== Game.handleToggleInventory START ==="),console.log("Game status:",this.gameState.status),console.log("Tutorial status:",this.gameState.status==="tutorial"),this.gameState.status==="tutorial"){const e=this.tutorialSystem.isActionAllowed("inventory");if(console.log("Inventory allowed in tutorial:",e),!e){console.log("Inventory blocked by tutorial system"),this.addMessage("このチュートリアルステップではインベントリを開けません。");return}}console.log("Calling overlayManager.toggleInventoryOverlay()"),this.overlayManager.toggleInventoryOverlay(),this.gameState.status==="tutorial"&&this.tutorialSystem.updateProgress(this.gameState),console.log("=== Game.handleToggleInventory END ===")}handleToggleStatus(){if(this.gameState.status==="tutorial"&&!this.tutorialSystem.isActionAllowed("character_status")){this.addMessage("このチュートリアルステップではステータスを開けません。");return}this.overlayManager.toggleStatusOverlay(),this.gameState.status==="tutorial"&&(this.tutorialSystem.markStatusViewed(),this.tutorialSystem.updateProgress(this.gameState),this.tutorialSystem.markStatusViewed())}handleEquipmentToggle(){if(this.gameState.status==="tutorial"&&!this.tutorialSystem.isActionAllowed("equipment")){this.addMessage("このチュートリアルステップでは装備を確認できません。");return}this.overlayManager.toggleEquipmentOverlay(),this.gameState.overlay.isVisible&&this.gameState.overlay.type==="equipment"&&(this.addMessage("装備一覧を表示しています。ESCで閉じます。"),this.gameState.status==="tutorial"&&(this.tutorialSystem.markEquipmentViewOpened(),this.tutorialSystem.updateProgress(this.gameState)))}handleToggleTakeoff(){if(this.gameState.status==="tutorial"&&!this.tutorialSystem.isActionAllowed("takeoff")){this.addMessage("このチュートリアルステップでは装備外しを実行できません。");return}this.overlayManager.toggleTakeoffOverlay(),this.gameState.status==="tutorial"&&this.gameState.overlay.isVisible&&this.gameState.overlay.type==="takeoff"&&(this.tutorialSystem.markTakeoffViewOpened(),this.tutorialSystem.updateProgress(this.gameState))}notifyEquipmentToggle(){this.gameState.status==="tutorial"&&(console.log("=== notifyEquipmentToggle called ==="),this.tutorialSystem.markEquipmentToggled(),this.tutorialSystem.updateProgress(this.gameState))}handleItemAction(e){if(console.log(`Game.handleItemAction called with index: ${e}, status: ${this.gameState.status}, overlay: ${this.overlayManager.isType("inventory")}`),this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"){console.log(`Item action blocked: invalid game status (${this.gameState.status})`);return}if(this.gameState.status==="tutorial"&&!this.tutorialSystem.isActionAllowed("item_use")){console.log("Item use blocked by unified tutorial system"),this.addMessage("このチュートリアルステップではアイテムを使用できません。");return}this.overlayManager.isType("inventory")?(console.log("Using item from overlay"),this.overlayManager.useItemFromOverlay(e)):(console.log("Using item directly (no overlay)"),this.useItem(e)),this.gameState.status==="tutorial"&&(console.log("Updating tutorial progress after item action"),console.log("=== MARKING ITEM USED IN TUTORIAL ==="),this.tutorialSystem.markItemUsed(),this.tutorialSystem.updateProgress(this.gameState),console.log("=== TUTORIAL UPDATES COMPLETED ==="))}saveGame(){const e=this.saveManager.save(this.gameState);e.success?this.addMessage(e.message):this.addMessage(`セーブエラー: ${e.error}`)}loadGame(){const e=this.saveManager.load();if(!e){this.addMessage("セーブデータが見つかりません");return}try{this.gameState.player.position=e.player.position,this.gameState.player.health=e.player.hp,this.gameState.player.maxHealth=e.player.maxHp,this.gameState.player.energy=e.player.energy,this.gameState.player.maxEnergy=e.player.maxEnergy,this.gameState.player.level=e.player.level,this.gameState.player.experience=e.player.exp,this.gameState.player.inventory=e.player.inventory,this.gameState.player.equipment=e.player.equipment,this.gameState.dungeonData.currentFloor=e.dungeon.currentFloor,this.gameState.turn=e.gameStats.turnCount,this.gameState.score=e.gameStats.score;const t=this.dungeonGenerator.generate(this.gameState.player);t.player=this.gameState.player,this.gameState.currentDungeon=t,this.playerController.setPosition(e.player.position),this.addMessage("ゲームをロードしました")}catch(t){this.addMessage("ロードエラー: データが破損しています"),console.error("Load error:",t)}}hasSaveData(){return this.saveManager.hasSave()}deleteSaveData(){const e=this.saveManager.deleteSave();this.addMessage(e.message)}getPlayerPosition(){return{...this.gameState.player.position}}getInventoryItemCount(){return this.gameState.player.inventory.length}isPaused(){return this.gameState.status==="paused"}getCurrentOverlay(){return this.gameState.overlay.isVisible?this.gameState.overlay.type:null}getTutorialObservable(){return this.gameState.status!=="tutorial"?null:(this.tutorialSystem,{getTutorialState:()=>{const e=this.tutorialSystem.state;return{currentStepId:e.currentStepId,currentStepTitle:e.currentStep?.title||"",currentStepDescription:e.currentStep?.description||"",completedSteps:this.tutorialSystem.getCompletedStepIds(),isCompleted:e.isCompleted,isCurrentStepCompleted:e.currentStep?this.tutorialSystem.checkStepCompletion(e.currentStepId):!1}},isActionAllowed:e=>this.tutorialSystem.isActionAllowed(e),isPositionPassable:(e,t)=>{const s=this.gameState.currentDungeon.tiles,a={x:e,y:t},i={width:s[0]?.length||0,height:s.length};return x(a,i)?!s[t][e].blocking:!1}})}}document.addEventListener("DOMContentLoaded",()=>{(()=>{const s=document.getElementById("gameTitle"),a=document.getElementById("gameSubtitle"),i=document.getElementById("gameInfo");s&&(s.textContent=r("gameTitle")),a&&(a.textContent=r("gameSubtitle")),i&&(i.textContent=r("controls"))})();const e=document.getElementById("gameCanvas");if(!e){console.error("Could not find game canvas element");return}const t=new Ce(e);t.start(),window.game=t,window.gameState=()=>t.getGameState(),window.getTutorialSystem=()=>t.getTutorialSystem(),window.getTutorialCoordinates=()=>t.getTutorialSystem()?.getCoordinateInfo(),window.debugItemUse=()=>t.debugItemUse(),window.localization=b,window.renderer={getRenderedTexts:()=>{const s=t.getRenderer();return s?s.getRenderedTexts():[]}},document.addEventListener("keydown",s=>{s.ctrlKey&&s.key==="t"&&(s.preventDefault(),t.getGameState().status==="tutorial"&&(console.log("Skipping tutorial (Ctrl+T)"),t.skipTutorial()))}),console.log("Terminal Descent initialized successfully"),console.log("Use WASD keys to move, F to interact, ESC to pause"),console.log("Ctrl+T to skip tutorial during tutorial (or ESC -> pause menu -> return to title)")});
