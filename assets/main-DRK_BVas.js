(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const o of i)if(o.type==="childList")for(const r of o.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function t(i){const o={};return i.integrity&&(o.integrity=i.integrity),i.referrerPolicy&&(o.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?o.credentials="include":i.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(i){if(i.ep)return;i.ep=!0;const o=t(i);fetch(i.href,o)}})();const O={ja:{gameTitle:"ターミナル・ディセント",gameSubtitle:"ディストピア・ローグライク v1.0",controls:"WASDで移動 | Fで調べる | Iでインベントリ | Cでステータス | Lで言語切替 | ESCでメニュー",welcome:"ターミナル・ディセントへようこそ。WASDで移動してください。",cannotMoveThere:"そこには移動できません。",pickedUpItem:"を手に入れた。",nothingToInteract:"調べるものがありません。",enemyAttacks:"グレムリンが攻撃してきた！",youDied:"あなたは死亡しました。",gameOver:"ゲームオーバー。",levelCleared:"フロアクリア！勝利です！",gamePaused:"ゲームを一時停止しました。ESCで再開。",gameResumed:"ゲームを再開しました。",menuNotImplemented:"メニューは未実装です。",searchingForExit:"ターミナル・ディセントを開始。出口を探索中...",languageSwitched:"言語が切り替わりました。",playerAttacks:"を攻撃した！",enemyDefeated:"を倒した！",attackModeOn:"攻撃モード：方向キーで攻撃方向を選択",attackModeOff:"移動モード",noEnemyThere:"そこには敵がいません。",attackMissed:"{{enemy}}への攻撃が外れた！",criticalHit:"クリティカルヒット！ {{enemy}}に{{damage}}ダメージ！ HP: {{health}}/{{maxHealth}}",normalHit:"{{enemy}}に{{damage}}ダメージ！ HP: {{health}}/{{maxHealth}}",experienceGained:"経験値 +{{exp}}",levelUp:"レベルアップ！ Lv.{{level}}",enemyAttackWithDefense:"{{enemy}}の攻撃！ {{damage}}ダメージ！(防御力-{{defense}}) HP: {{health}}/{{maxHealth}}",enemyAttackNormal:"{{enemy}}の攻撃！ {{damage}}ダメージ！ HP: {{health}}/{{maxHealth}}",level:"レベル",health:"HP",energy:"エネルギー",accessLevel:"アクセス権",turn:"ターン",inventoryFull:"インベントリが満杯です。",inventoryEmpty:"インベントリは空です。",useItem:"を使用した。",pickedUpItemWithName:"{{item}}を拾った",cannotInteract:"相互作用できるものがない",invalidItem:"無効なアイテムです。",noItemInSlot:"スロット{{slot}}にアイテムがありません。",ironSword:"鉄の剣",battleAxe:"バトルアックス",hunterBow:"ハンターボウ",magicStaff:"マジックスタッフ",steelDagger:"スチールダガー",ironHelmet:"鉄のヘルメット",steelChestplate:"スチール胸当て",leatherLeggings:"レザーレギンス",combatBoots:"コンバットブーツ",towerShield:"タワーシールド",healthPotion:"ヘルスポーション",energyBar:"エネルギーバー",mysteryScroll:"謎の巻物",healingHerb:"回復薬",energyCore:"エネルギーコア",ironSwordDesc:"標準的な鉄製の剣",battleAxeDesc:"強力な戦闘用斧",hunterBowDesc:"狩猟用の弓",magicStaffDesc:"魔法を増幅する杖",steelDaggerDesc:"軽量で素早い短剣",ironHelmetDesc:"鉄製の頭部防具",steelChestplateDesc:"スチール製の胸部防具",leatherLeggingsDesc:"レザー製の脚部防具",combatBootsDesc:"戦闘用ブーツ",towerShieldDesc:"大型の防御用盾",healthPotionDesc:"HP+30回復",energyBarDesc:"エネルギー+20回復",tutorialHealthPotion:"チュートリアル ポーション",tutorialHealthPotionDesc:"チュートリアル用の回復アイテム（HP+10回復）",tutorialSword:"チュートリアル ソード",tutorialSwordDesc:"チュートリアル用の練習剣（攻撃力+3）",mysteryScrollDesc:"ランダム効果",healingHerbDesc:"HP+15回復",energyCoreDesc:"エネルギー+50回復",weaponDescriptionFormat:"{{description}} (攻撃力: {{damage}})",armorDescriptionFormat:"{{description}} (防御力: {{defense}})",inventoryHeader:"=== インベントリ ===",currentEquipmentHeader:"=== 現在の装備 ===",usageInstructionsHeader:"=== 使用方法 ===",itemUsageInstructions:"数字キー(1-9)でアイテム使用/装備",itemUsageExample:"例: 1キー = [1]番目のアイテム",effectLabel:"効果",attackPowerEffect:"攻撃力+{{damage}}, 命中率+{{accuracy}}%",defenseEffect:"防御力+{{defense}}",totalDefense:"総防御力: {{total}}",rightHand:"右手",head:"頭",chest:"胸",legs:"脚",feet:"足",leftHand:"左手",noEquipment:"(装備なし)",pauseMenuTitle:"ポーズメニュー",continueGame:"ゲームを続ける",saveGame:"セーブ",loadGame:"ロード",languageSwitch:"言語切り替え",returnToTitle:"タイトルに戻る",descendingToFloor:"階層{{floor}}へ降りる...",cannotGoUp:"これ以上上には行けません。",returningToFloor:"階層{{floor}}へ戻る...",arrivedAtFloor:"階層{{floor}}に到着しました。",healthRestored:"HP+{{amount}}回復！",energyRestored:"エネルギー+{{amount}}回復！",itemCannotBeUsed:"{{item}}は使用できません。",weaponEquipped:"{{weapon}}を装備しました。",armorEquipped:"{{armor}}を装備しました。",cannotEquipWeapon:"武器を装備できませんでした。",cannotEquipArmor:"防具を装備できませんでした。",noEnemyInThatDirection:"そこには敵がいません。",movementMode:"移動モード",stairsAppeared:"次のフロアへの階段が現れました！ (Fキーで移動)",allFloorsCleared:"全フロアクリア！おめでとうございます！",welcomeToFacility:"ナイトシティ地下施設へようこそ。脱出を目指してください。",tutorialStarted:"チュートリアルを開始します。",tutorialComplete:"🎉 チュートリアル完了！ゲーム開始です！",settingsUnderDevelopment:"設定メニューは開発中です。",mysteryScrollHealth:"HP回復効果が発動！",mysteryScrollEnergy:"エネルギー回復効果が発動！",mysteryScrollScore:"スコアボーナス+50！",mysteryScrollMap:"マップ探索効果が発動！",tutorialWelcome:"ターミナル・ディセントへようこそ！WASDキーで移動してみましょう。",tutorialMovement:"よくできました！WASDで自由に移動できます。もう少し探索してみましょう。",tutorialCombat:"Spaceキーで攻撃モードに切り替えられます。試してみてください！",tutorialInventory:"Iキーでインベントリを開いて、アイテムを確認しましょう。",tutorialEquipment:"数字キー(1-9)でアイテムを使用できます。アイテムを使ってみましょう！",tutorialCompleted:"チュートリアル完了！すべての機能を覚えました。",tutorialProgressMovement:"✓ 移動をマスターしました！",tutorialProgressCombat:"✓ 次は戦闘システムを学びましょう。",tutorialProgressCombatComplete:"✓ 戦闘の基本を理解しました！",tutorialProgressInventory:"✓ インベントリの使い方を覚えました！",tutorialProgressEquipment:"✓ 装備システムも完璧です！",attackPowerLabel:"攻撃力",defenseLabel:"防御力",experienceLabel:"経験値",closeInstruction:"数字キー(1-9)でアイテム使用 | Iキーで閉じる",statusHeader:"=== ステータス ===",statusCloseInstruction:"Sキーで閉じる",equipmentHeader:"=== 装備 ===",equipmentStatsHeader:"=== 装備統計 ===",totalDefenseLabel:"総防御力",welcomeTitle:"ターミナル・ディセント",welcomeSubtitle:"ナイトシティ地下施設からの脱出劇",menuInstructions:"↑↓ または WS: 選択    Enter または F: 決定",prologueLines:["年は2087年。ナイトシティの地下研究施設で","あなたは目を覚ました。","","警備システムが暴走し、施設は封鎖された。","生き残るには地上への脱出しかない。","","装備を集め、敵を避け、10階層の地下から","脱出せよ。","","[Enterキーで開始]"],menuOptions:["[スタート] ゲームを開始","[チュートリアル] 操作を学ぶ","[設定] オプション設定"],emptyInventoryMessage:"インベントリが空です",weaponSlot:"武器",headSlot:"頭",chestSlot:"胸",legsSlot:"脚",feetSlot:"足",shieldSlot:"盾",noItem:"なし",gremlin:"グレムリン",goblin:"ゴブリン",orc:"オーク",troll:"トロル",takeoffHeader:"=== 装備を外す ===",takeoffInstruction:"外したい装備を選んでください",takeoffControls:"↑↓キー: 選択 | Enterキー: 外す | Tキー: 閉じる",noEquipmentToRemove:"外せる装備がありません。",weaponUnequipped:"{{weapon}}を外しました。",armorUnequipped:"{{armor}}を外しました。"},en:{gameTitle:"TERMINAL DESCENT",gameSubtitle:"DYSTOPIAN ROGUELIKE v1.0",controls:"Use WASD to move | Press F to interact | I for inventory | C for character | L for language | ESC for menu",welcome:"Welcome to Terminal Descent. Use WASD to move.",cannotMoveThere:"You cannot move there.",pickedUpItem:"You picked up ",nothingToInteract:"There is nothing here to interact with.",enemyAttacks:"The gremlin attacks you!",youDied:"You have died.",gameOver:"Game Over.",levelCleared:"Level cleared! You win!",gamePaused:"Game paused. Press ESC to resume.",gameResumed:"Game resumed.",menuNotImplemented:"Menu not implemented yet.",searchingForExit:"Terminal Descent initiated. Searching for exit...",languageSwitched:"Language switched.",playerAttacks:"You attack ",enemyDefeated:"You defeated ",attackModeOn:"Attack mode: Use arrow keys to select attack direction",attackModeOff:"Movement mode",noEnemyThere:"There is no enemy there.",attackMissed:"Your attack on {{enemy}} missed!",criticalHit:"Critical hit! {{enemy}} takes {{damage}} damage! HP: {{health}}/{{maxHealth}}",normalHit:"{{enemy}} takes {{damage}} damage! HP: {{health}}/{{maxHealth}}",experienceGained:"Experience +{{exp}}",levelUp:"Level up! Lv.{{level}}",enemyAttackWithDefense:"{{enemy}} attacks! {{damage}} damage! (Defense -{{defense}}) HP: {{health}}/{{maxHealth}}",enemyAttackNormal:"{{enemy}} attacks! {{damage}} damage! HP: {{health}}/{{maxHealth}}",level:"Level",health:"Health",energy:"Energy",accessLevel:"Access",turn:"Turn",inventoryFull:"Inventory is full.",inventoryEmpty:"Your inventory is empty.",useItem:"You used ",pickedUpItemWithName:"You picked up {{item}}",cannotInteract:"There is nothing to interact with",invalidItem:"Invalid item.",noItemInSlot:"No item in slot {{slot}}.",ironSword:"Iron Sword",battleAxe:"Battle Axe",hunterBow:"Hunter Bow",magicStaff:"Magic Staff",steelDagger:"Steel Dagger",ironHelmet:"Iron Helmet",steelChestplate:"Steel Chestplate",leatherLeggings:"Leather Leggings",combatBoots:"Combat Boots",towerShield:"Tower Shield",healthPotion:"Health Potion",energyBar:"Energy Bar",mysteryScroll:"Mystery Scroll",healingHerb:"Healing Herb",energyCore:"Energy Core",ironSwordDesc:"A standard iron sword",battleAxeDesc:"A powerful battle axe",hunterBowDesc:"A bow for hunting",magicStaffDesc:"A staff that amplifies magic",steelDaggerDesc:"A light and fast dagger",ironHelmetDesc:"Iron head protection",steelChestplateDesc:"Steel chest protection",leatherLeggingsDesc:"Leather leg protection",combatBootsDesc:"Combat boots",towerShieldDesc:"Large defensive shield",healthPotionDesc:"Restores 30 HP",energyBarDesc:"Restores 20 energy",tutorialHealthPotion:"Tutorial Potion",tutorialHealthPotionDesc:"Tutorial healing item (Restores 10 HP)",tutorialSword:"Tutorial Sword",tutorialSwordDesc:"Tutorial practice sword (Attack +3)",mysteryScrollDesc:"Random effect",healingHerbDesc:"Restores 15 HP",energyCoreDesc:"Restores 50 energy",weaponDescriptionFormat:"{{description}} (Damage: {{damage}})",armorDescriptionFormat:"{{description}} (Defense: {{defense}})",inventoryHeader:"=== INVENTORY ===",currentEquipmentHeader:"=== CURRENT EQUIPMENT ===",usageInstructionsHeader:"=== USAGE ===",itemUsageInstructions:"Press number keys (1-9) to use/equip items",itemUsageExample:"Example: Key 1 = Item [1]",effectLabel:"Effect",attackPowerEffect:"Attack +{{damage}}, Accuracy +{{accuracy}}%",defenseEffect:"Defense +{{defense}}",totalDefense:"Total Defense: {{total}}",rightHand:"Right Hand",head:"Head",chest:"Chest",legs:"Legs",feet:"Feet",leftHand:"Left Hand",noEquipment:"(No equipment)",pauseMenuTitle:"Pause Menu",continueGame:"Continue",saveGame:"Save",loadGame:"Load",languageSwitch:"Language",returnToTitle:"Return to Title",descendingToFloor:"Descending to floor {{floor}}...",cannotGoUp:"Cannot go up any further.",returningToFloor:"Returning to floor {{floor}}...",arrivedAtFloor:"Arrived at floor {{floor}}.",healthRestored:"HP+{{amount}} restored!",energyRestored:"Energy+{{amount}} restored!",itemCannotBeUsed:"{{item}} cannot be used.",weaponEquipped:"{{weapon}} equipped.",armorEquipped:"{{armor}} equipped.",cannotEquipWeapon:"Cannot equip weapon.",cannotEquipArmor:"Cannot equip armor.",noEnemyInThatDirection:"No enemy there.",movementMode:"Movement mode",stairsAppeared:"Stairs to next floor appeared! (Press F to move)",allFloorsCleared:"All floors cleared! Congratulations!",welcomeToFacility:"Welcome to Night City underground facility. Aim for escape.",tutorialStarted:"Tutorial started.",tutorialComplete:"🎉 Tutorial complete! Game start!",settingsUnderDevelopment:"Settings menu is under development.",mysteryScrollHealth:"HP recovery effect activated!",mysteryScrollEnergy:"Energy recovery effect activated!",mysteryScrollScore:"Score bonus +50!",mysteryScrollMap:"Map exploration effect activated!",tutorialWelcome:"Welcome to Terminal Descent! Use WASD keys to move.",tutorialMovement:"Well done! You can move freely with WASD. Try exploring a bit more.",tutorialCombat:"You can switch to attack mode with Space key. Try it!",tutorialInventory:"Press I key to open inventory and check items.",tutorialEquipment:"Use number keys (1-9) to use items. Try using an item!",tutorialCompleted:"Tutorial complete! You have learned all functions.",tutorialProgressMovement:"✓ Movement mastered!",tutorialProgressCombat:"✓ Next, let's learn the combat system.",tutorialProgressCombatComplete:"✓ Combat basics understood!",tutorialProgressInventory:"✓ Inventory usage learned!",tutorialProgressEquipment:"✓ Equipment system perfect!",attackPowerLabel:"Attack Power",defenseLabel:"Defense",experienceLabel:"Experience",closeInstruction:"Press number keys (1-9) to use items | Press I to close",statusHeader:"=== STATUS ===",statusCloseInstruction:"Press S to close",equipmentHeader:"=== EQUIPMENT ===",equipmentStatsHeader:"=== EQUIPMENT STATS ===",totalDefenseLabel:"Total Defense",welcomeTitle:"TERMINAL DESCENT",welcomeSubtitle:"Escape from Night City underground facility",menuInstructions:"↑↓ or WS: Select    Enter or F: Confirm",prologueLines:["The year is 2087. In an underground research facility","in Night City, you wake up.","","Security systems have gone haywire, and the facility is sealed.","To survive, you must escape to the surface.","","Gather equipment, avoid enemies, and escape from","10 underground levels.","","[Press Enter to start]"],menuOptions:["[Start] Begin game","[Tutorial] Learn controls","[Settings] Options"],emptyInventoryMessage:"Inventory is empty",weaponSlot:"Weapon",headSlot:"Head",chestSlot:"Chest",legsSlot:"Legs",feetSlot:"Feet",shieldSlot:"Shield",noItem:"None",gremlin:"Gremlin",goblin:"Goblin",orc:"Orc",troll:"Troll",takeoffHeader:"=== Remove Equipment ===",takeoffInstruction:"Select equipment to remove",takeoffControls:"↑↓ keys: Select | Enter: Remove | T key: Close",noEquipmentToRemove:"No equipment to remove.",weaponUnequipped:"{{weapon}} unequipped.",armorUnequipped:"{{armor}} unequipped."}};class U{currentLanguage="ja";setLanguage(e){this.currentLanguage=e}getCurrentLanguage(){return this.currentLanguage}getMessage(e){return O[this.currentLanguage][e]}getMessages(){return O[this.currentLanguage]}}const I=new U,n=l=>{const e=I.getMessage(l);return Array.isArray(e)?e.join(`
`):e},R=l=>{const e=I.getMessage(l);return Array.isArray(e)?e:[e]};function m(l){return l.nameKey?n(l.nameKey):l.name}function G(l){if(l.descriptionKey){const e=n(l.descriptionKey);return l.itemType==="weapon"&&l.descriptionParams?.damage!==void 0?n("weaponDescriptionFormat").replace("{{description}}",e).replace("{{damage}}",String(l.descriptionParams.damage)):l.itemType==="armor"&&l.descriptionParams?.defense!==void 0?n("armorDescriptionFormat").replace("{{description}}",e).replace("{{defense}}",String(l.descriptionParams.defense)):e}return l.description}function K(l){const e=l.equipment;console.log("=== formatEquipmentSlots DEBUG ==="),console.log("Player equipment object:",e),console.log("MainHand:",e.mainHand),console.log("Head:",e.head),console.log("Chest:",e.chest),console.log("Legs:",e.legs),console.log("Feet:",e.feet),console.log("OffHand:",e.offHand);const t={weapon:e.mainHand?m(e.mainHand):n("noItem"),head:e.head?m(e.head):n("noItem"),chest:e.chest?m(e.chest):n("noItem"),legs:e.legs?m(e.legs):n("noItem"),feet:e.feet?m(e.feet):n("noItem"),shield:e.offHand?m(e.offHand):n("noItem")};return console.log("Formatted equipment slots:",t),console.log("=== formatEquipmentSlots END ==="),t}function z(l){let e=0;return["head","chest","legs","feet","offHand"].forEach(s=>{const i=l.equipment[s];i&&"defense"in i&&(e+=i.defense)}),e}function V(l){const t=l.equipment.mainHand;return 10+(t&&"damage"in t?t.damage:0)}function $(l){const e=z(l),t=V(l),s=Object.values(l.equipment).filter(i=>i!==void 0).length;return{totalDefense:e,attackPower:t,equipmentCount:s}}function W(l){return"key"in l}function Y(l){if(typeof l=="string")return l;if(W(l)){let e=n(l.key);return l.params&&Object.entries(l.params).forEach(([t,s])=>{const i=`{{${t}}}`;e=e.replace(i,String(s))}),e}else return l.text}function p(l,e){const t={key:l,timestamp:Date.now()};return e&&(t.params=e),t}function F(l){return{text:l,timestamp:Date.now()}}function w(){return Math.random().toString(36).substring(2)+Date.now().toString(36)}function f(l,e){return l.x>=0&&l.x<e.width&&l.y>=0&&l.y<e.height}function Q(l){switch(l){case"north":return{x:0,y:-1};case"south":return{x:0,y:1};case"east":return{x:1,y:0};case"west":return{x:-1,y:0}}}function j(l,e){return{x:l.x+e.x,y:l.y+e.y}}function C(l,e){return Math.floor(Math.random()*(e-l+1))+l}function b(l){return l[Math.floor(Math.random()*l.length)]}function E(l){const t={g:"gremlin",G:"goblin",o:"orc",T:"troll"}[l.char];return t?n(t):l.char}class X{player;constructor(e){this.player=this.createPlayer(e)}createPlayer(e){return{id:w(),position:{...e},char:"@",color:"#00ff00",type:"player",blocking:!0,visible:!0,level:1,experience:0,experienceToNext:100,health:100,maxHealth:100,energy:100,maxEnergy:100,accessLevel:1,inventory:[],equipment:{}}}getPlayer(){return{...this.player}}getPlayerDirect(){return this.player}getPosition(){return{...this.player.position}}setPosition(e){this.player.position={...e}}move(e){const t=Q(e);return j(this.player.position,t)}confirmMove(e){this.player.position={...e}}takeDamage(e){this.player.health=Math.max(0,this.player.health-e)}heal(e){this.player.health=Math.min(this.player.maxHealth,this.player.health+e)}useEnergy(e){return this.player.energy>=e?(this.player.energy-=e,!0):!1}restoreEnergy(e){this.player.energy=Math.min(this.player.maxEnergy,this.player.energy+e)}isAlive(){return this.player.health>0}isDead(){return this.player.health<=0}addItem(e){if(e.stackable){const t=this.player.inventory.find(s=>s.name===e.name&&s.itemType===e.itemType);if(t)return t.quantity+=e.quantity,!0}return this.player.inventory.length<20?(this.player.inventory.push({...e}),!0):!1}removeItem(e,t=1){const s=this.player.inventory.findIndex(o=>o.id===e);if(s===-1)return null;const i=this.player.inventory[s];return i.quantity<=t?(this.player.inventory.splice(s,1),i):(i.quantity-=t,{...i,id:w(),quantity:t})}getInventory(){return[...this.player.inventory]}findItem(e){return this.player.inventory.find(s=>s.id===e)||null}hasItem(e){return this.player.inventory.some(t=>t.id===e)}calculateExperienceToNext(e){return Math.floor(100*Math.pow(1.5,e-1))}addExperience(e){this.player.experience+=e;let t=!1;for(;this.player.experience>=this.player.experienceToNext;)this.player.experience-=this.player.experienceToNext,this.levelUp(),t=!0;return t}levelUp(){this.player.level++,this.player.experienceToNext=this.calculateExperienceToNext(this.player.level),this.player.maxHealth+=10,this.player.maxEnergy+=5,this.player.health=this.player.maxHealth,this.player.energy=this.player.maxEnergy}increaseAccessLevel(){this.player.accessLevel++}getStats(){return{level:this.player.level,experience:this.player.experience,experienceToNext:this.player.experienceToNext,experienceProgress:Math.floor(this.player.experience/this.player.experienceToNext*100),health:this.player.health,maxHealth:this.player.maxHealth,energy:this.player.energy,maxEnergy:this.player.maxEnergy,accessLevel:this.player.accessLevel,inventoryCount:this.player.inventory.length}}serialize(){return JSON.stringify(this.player)}deserialize(e){try{const t=JSON.parse(e);if(typeof t.level=="number"&&typeof t.health=="number"&&typeof t.maxHealth=="number"&&typeof t.position=="object"&&typeof t.position.x=="number"&&typeof t.position.y=="number")this.player={...t};else throw new Error("Invalid player data format")}catch(t){console.error("Failed to deserialize player data:",t),this.player=this.createPlayer({x:0,y:0})}}reset(e){this.player=this.createPlayer(e)}equipWeapon(e){return console.log("=== PlayerController.equipWeapon START ==="),console.log("Weapon to equip:",e),console.log("Current equipment before:",this.player.equipment),this.player.equipment.mainHand&&(console.log("Previous weapon exists, returning to inventory:",this.player.equipment.mainHand),this.addItem(this.player.equipment.mainHand)),this.player.equipment.mainHand=e,console.log("Weapon equipped to mainHand"),console.log("Current equipment after:",this.player.equipment),console.log("=== PlayerController.equipWeapon END ==="),!0}unequipWeapon(){const e=this.player.equipment.mainHand;return e?(delete this.player.equipment.mainHand,e):null}getEquippedWeapon(){return this.player.equipment.mainHand||null}equipArmor(e){const t=e.slot;if(t==="mainHand"||t==="accessory")return!1;const s=this.player.equipment[t];return s&&this.addItem(s),this.player.equipment[t]=e,!0}unequipArmor(e){if(e==="mainHand"||e==="accessory")return null;const t=this.player.equipment[e];return t?(delete this.player.equipment[e],t):null}getEquippedArmor(e){return e==="mainHand"||e==="accessory"?null:this.player.equipment[e]||null}getTotalDefense(){let e=0;const t=["offHand","head","chest","legs","feet"];for(const s of t){const i=this.getEquippedArmor(s);i&&(e+=i.defense)}return e}getAttackDamage(){const e=this.player.equipment.mainHand,t=10;return e?t+e.damage:t}getAttackAccuracy(){const e=this.player.equipment.mainHand,t=80;return e?Math.min(95,t+e.accuracy):t}getCriticalChance(){const e=this.player.equipment.mainHand,t=5;return e?Math.min(50,t+e.criticalChance):t}rollAttackHit(){const e=this.getAttackAccuracy();return Math.random()*100<e}rollCriticalHit(){const e=this.getCriticalChance();return Math.random()*100<e}rollDamage(){const e=this.getAttackDamage(),t=this.rollCriticalHit();return{damage:t?Math.floor(e*1.5):e,isCritical:t}}}class k{dimensions;level;constructor(e,t=1){this.dimensions=e,this.level=t}generate(e){const t=this.createEmptyTiles(),s=this.generateRooms();if(s.forEach(o=>this.carveRoom(t,o)),this.connectRooms(t,s),s.length>0){const o=s[0];e.position={x:o.position.x+Math.floor(o.dimensions.width/2),y:o.position.y+Math.floor(o.dimensions.height/2)},console.log(`Player placed at (${e.position.x},${e.position.y}) in room at (${o.position.x},${o.position.y})`),console.log(`Generated ${s.length} rooms`)}else console.error("No rooms generated! Player will be stuck in walls.");const i=this.generateEntities(s,e.position);return i.push(e),{level:this.level,dimensions:this.dimensions,tiles:t,rooms:s,entities:i,player:e}}createEmptyTiles(){const e=[];for(let t=0;t<this.dimensions.height;t++){e[t]=[];for(let s=0;s<this.dimensions.width;s++)e[t][s]=this.createWallTile({x:s,y:t})}return e}createWallTile(e){return{position:{...e},type:"wall",char:"#",color:"#444444",backgroundColor:"#000000",blocking:!0,explored:!1,visible:!1}}createFloorTile(e){return{position:{...e},type:"floor",char:".",color:"#666666",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1}}generateRooms(){const e=[];for(let r=0;r<50&&e.length<8;r++){const a=C(4,10),c=C(4,10),u=C(1,this.dimensions.width-a-1),g=C(1,this.dimensions.height-c-1),h={position:{x:u,y:g},dimensions:{width:a,height:c},tiles:[],connected:!1};e.some(y=>this.roomsOverlap(h,y))||e.push(h)}return e}roomsOverlap(e,t){return!(e.position.x+e.dimensions.width+1<t.position.x||t.position.x+t.dimensions.width+1<e.position.x||e.position.y+e.dimensions.height+1<t.position.y||t.position.y+t.dimensions.height+1<e.position.y)}carveRoom(e,t){for(let s=t.position.y;s<t.position.y+t.dimensions.height;s++)for(let i=t.position.x;i<t.position.x+t.dimensions.width;i++)f({x:i,y:s},this.dimensions)&&(e[s][i]=this.createFloorTile({x:i,y:s}))}connectRooms(e,t){if(t.length<2)return;for(let i=0;i<t.length-1;i++){const o=t[i],r=t[i+1];this.createCorridor(e,o,r),o.connected=!0,r.connected=!0}const s=Math.floor(t.length/3);for(let i=0;i<s;i++){const o=b(t),r=b(t);o!==r&&this.createCorridor(e,o,r)}}createCorridor(e,t,s){const i={x:t.position.x+Math.floor(t.dimensions.width/2),y:t.position.y+Math.floor(t.dimensions.height/2)},o={x:s.position.x+Math.floor(s.dimensions.width/2),y:s.position.y+Math.floor(s.dimensions.height/2)};C(0,1)===0?(this.carveHorizontalCorridor(e,i.x,o.x,i.y),this.carveVerticalCorridor(e,o.x,i.y,o.y)):(this.carveVerticalCorridor(e,i.x,i.y,o.y),this.carveHorizontalCorridor(e,i.x,o.x,o.y))}carveHorizontalCorridor(e,t,s,i){const o=Math.min(t,s),r=Math.max(t,s);for(let a=o;a<=r;a++)f({x:a,y:i},this.dimensions)&&(e[i][a]=this.createFloorTile({x:a,y:i}))}carveVerticalCorridor(e,t,s,i){const o=Math.min(s,i),r=Math.max(s,i);for(let a=o;a<=r;a++)f({x:t,y:a},this.dimensions)&&(e[a][t]=this.createFloorTile({x:t,y:a}))}generateEntities(e,t){const s=[],i=e.slice(1);i.forEach(u=>{const g=Math.min(.3+this.level*.05,.7);if(Math.random()<g){const d=this.createEnemy(u);s.push(d)}const h=Math.min(.2+this.level*.02,.4);if(Math.random()<h){const d=this.createItem(u);s.push(d)}});const o=s.filter(u=>u.type==="enemy").length,r=Math.max(1,Math.floor(i.length/3));if(o<r){const u=i.filter(h=>!s.some(d=>d.type==="enemy"&&d.position.x>=h.position.x&&d.position.x<h.position.x+h.dimensions.width&&d.position.y>=h.position.y&&d.position.y<h.position.y+h.dimensions.height)),g=r-o;for(let h=0;h<g&&h<u.length;h++){const d=u[h],y=this.createEnemy(d);s.push(y)}}const a=s.filter(u=>u.type==="item").length,c=Math.max(1,Math.floor(i.length/4));if(a<c){const u=i.filter(h=>!s.some(d=>d.type==="item"&&d.position.x>=h.position.x&&d.position.x<h.position.x+h.dimensions.width&&d.position.y>=h.position.y&&d.position.y<h.position.y+h.dimensions.height)),g=c-a;for(let h=0;h<g&&h<u.length;h++){const d=u[h],y=this.createItem(d);s.push(y)}}return s}createEnemy(e){const t=C(e.position.x+1,e.position.x+e.dimensions.width-2),s=C(e.position.y+1,e.position.y+e.dimensions.height-2),i=20,o=5,r=Math.floor(this.level*1.5),a=Math.floor(this.level*.8),c=i+r,u=o+a,g=this.getEnemyTypes(),h=b(g);return{id:`enemy_${Date.now()}_${Math.random()}`,position:{x:t,y:s},char:h.char,color:h.color,type:"enemy",blocking:!0,visible:!0,health:c,maxHealth:c,damage:u,aiType:"aggressive"}}getEnemyTypes(){const e=[{char:"G",color:"#ff4444",name:"Gremlin"},{char:"R",color:"#8b4513",name:"Rat"},{char:"S",color:"#32cd32",name:"Slime"}],t=[{char:"O",color:"#ff6600",name:"Orc"},{char:"T",color:"#daa520",name:"Troll"},{char:"W",color:"#483d8b",name:"Wraith"}],s=[{char:"D",color:"#dc143c",name:"Dragon"},{char:"L",color:"#8b008b",name:"Lich"},{char:"M",color:"#ff1493",name:"Minotaur"}];return this.level<=3?e:this.level<=6?[...e,...t]:[...e,...t,...s]}createItem(e){const t=C(e.position.x+1,e.position.x+e.dimensions.width-2),s=C(e.position.y+1,e.position.y+e.dimensions.height-2),i=Math.random();return i<.25?this.createWeapon(t,s):i<.45?this.createArmor(t,s):this.createConsumable(t,s)}createWeapon(e,t){const s=[{char:")",color:"#cccccc",nameKey:"ironSword",descKey:"ironSwordDesc",weaponType:"sword",damage:8+Math.floor(this.level*1.2),accuracy:10,criticalChance:5,range:1},{char:"/",color:"#8b4513",nameKey:"battleAxe",descKey:"battleAxeDesc",weaponType:"axe",damage:12+Math.floor(this.level*1.5),accuracy:5,criticalChance:8,range:1},{char:"}",color:"#654321",nameKey:"hunterBow",descKey:"hunterBowDesc",weaponType:"bow",damage:6+Math.floor(this.level*1),accuracy:15,criticalChance:10,range:3},{char:"\\",color:"#4b0082",nameKey:"magicStaff",descKey:"magicStaffDesc",weaponType:"staff",damage:5+Math.floor(this.level*.8),accuracy:12,criticalChance:3,range:2},{char:"-",color:"#a9a9a9",nameKey:"steelDagger",descKey:"steelDaggerDesc",weaponType:"dagger",damage:4+Math.floor(this.level*.7),accuracy:20,criticalChance:15,range:1}],i=b(s);let o;return this.level>=3&&Math.random()<.3&&(o={type:b(["fire","ice","poison","stun","vampire"]),chance:15+Math.floor(this.level*2),value:Math.floor(this.level*1.5)}),{id:w(),position:{x:e,y:t},char:i.char,color:i.color,type:"item",blocking:!1,visible:!0,name:n(i.nameKey),nameKey:i.nameKey,description:`${n(i.descKey)} (攻撃力: ${i.damage})`,descriptionKey:i.descKey,descriptionParams:{damage:i.damage},stackable:!1,quantity:1,itemType:"weapon",weaponType:i.weaponType,damage:i.damage,accuracy:i.accuracy,criticalChance:i.criticalChance,range:i.range,...o&&{special:o}}}createArmor(e,t){const s=[{char:"[",color:"#8b4513",nameKey:"ironHelmet",descKey:"ironHelmetDesc",armorType:"helmet",slot:"head",defense:3+Math.floor(this.level*.8)},{char:"]",color:"#c0c0c0",nameKey:"steelChestplate",descKey:"steelChestplateDesc",armorType:"chestplate",slot:"chest",defense:5+Math.floor(this.level*1.2)},{char:"{",color:"#a0522d",nameKey:"leatherLeggings",descKey:"leatherLeggingsDesc",armorType:"leggings",slot:"legs",defense:4+Math.floor(this.level*1)},{char:"(",color:"#654321",nameKey:"combatBoots",descKey:"combatBootsDesc",armorType:"boots",slot:"feet",defense:2+Math.floor(this.level*.6)},{char:"&",color:"#8b7355",nameKey:"towerShield",descKey:"towerShieldDesc",armorType:"shield",slot:"offHand",defense:6+Math.floor(this.level*1.5)}],i=b(s),o=50+Math.floor(this.level*10);return{id:w(),position:{x:e,y:t},char:i.char,color:i.color,type:"item",blocking:!1,visible:!0,name:n(i.nameKey),nameKey:i.nameKey,description:`${n(i.descKey)} (防御力: ${i.defense})`,descriptionKey:i.descKey,descriptionParams:{defense:i.defense},stackable:!1,quantity:1,itemType:"armor",armorType:i.armorType,defense:i.defense,durability:o,maxDurability:o,slot:i.slot}}createConsumable(e,t){const i=b([{char:"!",color:"#ffff00",nameKey:"healthPotion",descKey:"healthPotionDesc"},{char:"%",color:"#ff8800",nameKey:"energyBar",descKey:"energyBarDesc"},{char:"?",color:"#8800ff",nameKey:"mysteryScroll",descKey:"mysteryScrollDesc"},{char:"+",color:"#00ffff",nameKey:"healingHerb",descKey:"healingHerbDesc"},{char:"*",color:"#ff00ff",nameKey:"energyCore",descKey:"energyCoreDesc"}]);return{id:w(),position:{x:e,y:t},char:i.char,color:i.color,type:"item",blocking:!1,visible:!0,name:n(i.nameKey),nameKey:i.nameKey,description:n(i.descKey),descriptionKey:i.descKey,stackable:!0,quantity:1,itemType:"consumable"}}static updateFieldOfView(e,t,s=8){for(let i=0;i<e.dimensions.height;i++)for(let o=0;o<e.dimensions.width;o++)e.tiles[i][o].visible=!1;for(let i=-s;i<=s;i++)for(let o=-s;o<=s;o++){const r=t.x+o,a=t.y+i;if(f({x:r,y:a},e.dimensions)&&Math.sqrt(o*o+i*i)<=s){const u=e.tiles[a][r];u.visible=!0,u.explored=!0}}}}const S={MAP_DIMENSIONS:{width:72,height:30},ROOM_DIMENSIONS:{width:8,height:6,spacing:12},getWelcomeRoomPosition(){return{x:2,y:Math.floor(this.MAP_DIMENSIONS.height/2)-Math.floor(this.ROOM_DIMENSIONS.height/2)}},getMovementTargetPosition(){const l=this.getWelcomeRoomPosition();return{x:l.x+Math.floor(this.ROOM_DIMENSIONS.width/2),y:l.y+Math.floor(this.ROOM_DIMENSIONS.height/2)}},getPlayerStartPosition(){const l=this.getWelcomeRoomPosition();return{x:l.x+2,y:l.y+2}}};class J{stepOrder=["step_movement","step_item_pickup","step_equipment","step_combat","step_character_status"];roomTypeMapping={step_movement:"movement",step_item_pickup:"movement",step_equipment:"equipment",step_combat:"combat",step_character_status:"inventory"};getSteps(){const e=this.getStepDefinitions();return this.stepOrder.map((t,s)=>{const i=e[t];if(!i)throw new Error(`Step definition not found for: ${t}`);return{...i,nextStepId:this.getNextStepId(t)}})}getNextStepId(e){const t=this.stepOrder.indexOf(e);if(!(t===-1||t===this.stepOrder.length-1))return this.stepOrder[t+1]}getStepIndex(e){return this.stepOrder.indexOf(e)}getPreviousStepId(e){return e<=0?"welcome":this.stepOrder[e-1]}getRoomTypeForStep(e){return this.roomTypeMapping[e]||e.replace("step_","")}getRoomLayoutOrder(){const e=["welcome"],t=new Set(["welcome"]);for(const s of this.stepOrder){const i=this.getRoomTypeForStep(s);t.has(i)||(e.push(i),t.add(i))}return e}getTotalSteps(){return this.stepOrder.length}getStepDefinitions(){return{step_movement:{id:"step_movement",title:"移動の練習",description:"WASDキーで移動してみてください。緑色の目標地点まで移動してください。",targetAction:"move",completionCondition:e=>{const t=S.getMovementTargetPosition(),s=e.player.position;return s.x===t.x&&s.y===t.y},isCompleted:!1,targetPosition:S.getMovementTargetPosition(),blockedActions:["attack","inventory","character_status"]},step_item_pickup:{id:"step_item_pickup",title:"アイテムの取得と使用",description:"Fキーでアイテムを取得し、Iキーでインベントリを開いて数字キーで使用してください。",targetAction:"pickup_item",completionCondition:e=>!1,isCompleted:!1,requiredItems:["health_potion"],blockedActions:["attack","character_status"]},step_equipment:{id:"step_equipment",title:"装備の着脱",description:"Tキーで装備を外してみてください。装備を外す→再装備の2回操作すると扉が開きます。",targetAction:"equipment",completionCondition:e=>!1,isCompleted:!1,blockedActions:["attack"],requiredSequence:["equip_item","view_status","unequip_item","view_status","equip_item"]},step_combat:{id:"step_combat",title:"戦闘の基本",description:"Spaceキーで攻撃モードに入り、WASDで攻撃してみてください。",targetAction:"combat",completionCondition:e=>!1,isCompleted:!1,blockedActions:["inventory"]},step_character_status:{id:"step_character_status",title:"ステータスの確認",description:"Cキーでステータス画面を確認してみてください。",targetAction:"character_status",completionCondition:e=>!1,isCompleted:!1,blockedActions:[]}}}}const A=new J;class N{dimensions;constructor(e=S.MAP_DIMENSIONS){this.dimensions=e}generate(e){const t=this.createEmptyTiles(),s=this.generateTutorialRooms();if(s.forEach(o=>this.carveRoom(t,o)),this.connectRoomsLinear(t,s),s.length>0){const o=S.getPlayerStartPosition();e.position={...o},console.log(`Player positioned at (${o.x}, ${o.y}) using TUTORIAL_CONSTANTS`)}const i=this.generateTutorialEntities(s);return i.push(e),{level:0,dimensions:this.dimensions,tiles:t,rooms:s,entities:i,player:e}}createEmptyTiles(){const e=[];for(let t=0;t<this.dimensions.height;t++){e[t]=[];for(let s=0;s<this.dimensions.width;s++)e[t][s]=this.createWallTile({x:s,y:t})}return e}createWallTile(e){return{position:{...e},type:"wall",char:"#",color:"#444444",backgroundColor:"#000000",blocking:!0,explored:!1,visible:!1}}createFloorTile(e){return{position:{...e},type:"floor",char:".",color:"#666666",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1}}createDoorTile(e,t=!1){return{position:{...e},type:"door",char:t?" ":"|",color:t?"#666666":"#ff8800",backgroundColor:"#000000",blocking:!t,explored:!1,visible:!1}}generateTutorialRooms(){const e=[],{width:t,height:s,spacing:i}=S.ROOM_DIMENSIONS;return A.getRoomLayoutOrder().forEach((r,a)=>{let c,u;if(a===0){const h=S.getWelcomeRoomPosition();c=h.x,u=h.y,console.log(`Welcome room positioned at (${c}, ${u}) using TUTORIAL_CONSTANTS`)}else{const h=S.getWelcomeRoomPosition();c=h.x+a*i,u=h.y,console.log(`Room ${a} positioned at (${c}, ${u}) relative to welcome room`)}const g={position:{x:c,y:u},dimensions:{width:t,height:s},tiles:[],connected:!1,tutorialStep:r};e.push(g)}),e}carveRoom(e,t){for(let s=t.position.y;s<t.position.y+t.dimensions.height;s++)for(let i=t.position.x;i<t.position.x+t.dimensions.width;i++)f({x:i,y:s},this.dimensions)&&(e[s][i]=this.createFloorTile({x:i,y:s}))}connectRoomsLinear(e,t){for(let s=0;s<t.length-1;s++){const i=t[s],o=t[s+1],r=i.position.x+i.dimensions.width,a=o.position.x,c=i.position.y+Math.floor(i.dimensions.height/2);for(let h=r;h<a;h++)f({x:h,y:c},this.dimensions)&&(e[c][h]=this.createFloorTile({x:h,y:c}));const u=o.position.x-1,g=c;f({x:u,y:g},this.dimensions)&&(e[g][u]=this.createDoorTile({x:u,y:g},!1)),i.connected=!0}t.length>0&&(t[t.length-1].connected=!0)}generateTutorialEntities(e){const t=[];return e.forEach((s,i)=>{if(s.tutorialStep)switch(s.tutorialStep){case"movement":t.push(this.createTutorialItem(s,"health-potion"));break;case"combat":t.push(this.createTutorialEnemy(s));break;case"inventory":t.push(this.createTutorialItem(s,"health-potion"));break;case"equipment":t.push(this.createTutorialItem(s,"weapon"));break}}),t}createTutorialEnemy(e){const t=e.position.x+Math.floor(e.dimensions.width/2),s=e.position.y+Math.floor(e.dimensions.height/2);return{id:w(),position:{x:t,y:s},char:"g",color:"#ff4444",type:"enemy",blocking:!0,visible:!0,health:10,maxHealth:10,damage:2,aiType:"passive"}}createTutorialItem(e,t){const s=e.position.x+Math.floor(e.dimensions.width/2),i=e.position.y+Math.floor(e.dimensions.height/2),o={id:w(),position:{x:s,y:i},type:"item",blocking:!1,visible:!0,stackable:!0,quantity:1,itemType:"consumable"};switch(t){case"health-potion":return{...o,char:"!",color:"#ff0000",name:"チュートリアル回復薬",description:"HP回復の練習用",stackable:!0,quantity:1,itemType:"consumable"};case"weapon":return{...o,char:"/",color:"#ffff00",name:"トレーニング剣",description:"装備練習用の木剣",stackable:!1,quantity:1,itemType:"weapon",damage:3};default:return{...o,char:"?",color:"#ffffff",name:"チュートリアルアイテム",description:"練習用アイテム"}}}getRoomByStep(e,t){return e.find(s=>s.tutorialStep===t)}openDoorToNextRoom(e,t,s){const i=s.position.x-1,o=t.position.y+Math.floor(t.dimensions.height/2);f({x:i,y:o},this.dimensions)&&(e[o][i]=this.createDoorTile({x:i,y:o},!0))}}class Z{data;generator;tutorialGenerator;constructor(){this.data={floors:new Map,currentFloor:1,maxFloor:1},this.generator=new k({width:80,height:50},1),this.tutorialGenerator=new N}getDungeonData(){return{floors:new Map(this.data.floors),currentFloor:this.data.currentFloor,maxFloor:this.data.maxFloor}}getCurrentDungeon(){return this.data.floors.get(this.data.currentFloor)}generateTutorialDungeon(e){const t=this.tutorialGenerator.generate(e);return this.data.floors.set(0,t),this.data.currentFloor=0,t}generateInitialFloor(e){this.generator=new k({width:80,height:50},1);const t=this.generator.generate(e);if(t.rooms.length>0){const s=t.rooms[t.rooms.length-1];t.stairsDown={x:s.position.x+Math.floor(s.dimensions.width/2),y:s.position.y+Math.floor(s.dimensions.height/2)};const i=t.stairsDown;t.tiles[i.y]&&t.tiles[i.y][i.x]&&(t.tiles[i.y][i.x]={position:{...i},type:"stairs",char:">",color:"#ffff00",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1})}return this.data.floors.set(1,t),this.data.currentFloor=1,this.data.maxFloor=1,t}moveToFloor(e,t){if(!this.data.floors.has(e)){this.generator=new k({width:80,height:50},e);const o=this.generator.generate(t);if(e>1&&o.rooms.length>0){const r=o.rooms[0];o.stairsUp={x:r.position.x+Math.floor(r.dimensions.width/2),y:r.position.y+Math.floor(r.dimensions.height/2)};const a=o.stairsUp;o.tiles[a.y]&&o.tiles[a.y][a.x]&&(o.tiles[a.y][a.x]={position:{...a},type:"stairs",char:"<",color:"#ffff00",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1})}if(e<10&&o.rooms.length>0){const r=o.rooms[o.rooms.length-1];o.stairsDown={x:r.position.x+Math.floor(r.dimensions.width/2),y:r.position.y+Math.floor(r.dimensions.height/2)};const a=o.stairsDown;o.tiles[a.y]&&o.tiles[a.y][a.x]&&(o.tiles[a.y][a.x]={position:{...a},type:"stairs",char:">",color:"#ffff00",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1})}this.data.floors.set(e,o),e>this.data.maxFloor&&(this.data.maxFloor=e)}const s=this.data.floors.get(e),i=this.data.currentFloor;if(this.data.currentFloor=e,e>i&&s.stairsUp?t.position={...s.stairsUp}:e<i&&s.stairsDown&&(t.position={...s.stairsDown}),t.position){const o=s.tiles[t.position.y]?.[t.position.x];(!o||o.blocking)&&(t.position=this.findNearestValidPosition(s,t.position))}return s}findNearestValidPosition(e,t){for(let s=1;s<=5;s++)for(let i=-s;i<=s;i++)for(let o=-s;o<=s;o++){if(Math.abs(i)!==s&&Math.abs(o)!==s)continue;const r={x:t.x+i,y:t.y+o};if(r.x<0||r.x>=e.dimensions.width||r.y<0||r.y>=e.dimensions.height)continue;const a=e.tiles[r.y]?.[r.x];if(a&&!a.blocking)return r}return t}hasStairsAt(e){const t=this.getCurrentDungeon();return t?t.stairsUp&&t.stairsUp.x===e.x&&t.stairsUp.y===e.y?"up":t.stairsDown&&t.stairsDown.x===e.x&&t.stairsDown.y===e.y?"down":null:null}getCurrentFloor(){return this.data.currentFloor}getMaxFloor(){return this.data.maxFloor}saveDungeonState(e){this.data.floors.set(this.data.currentFloor,{...e})}}class v{constructor(e,t,s,i,o,r,a,c,u){this.gameState=e,this.playerController=t,this.addMessage=s,this.processTurn=i,this.updateTutorialProgress=o,this.equipItem=r,this.getCurrentEquipmentDisplay=a,this.addMessages=c,this.notifyEquipmentToggle=u}static ITEM_EFFECTS={HEALTH_POTION:30,HEALING_HERB:15,ENERGY_BAR:20,ENERGY_CORE:50,MYSTERY_SCROLL_HEALTH:20,MYSTERY_SCROLL_ENERGY:30,MYSTERY_SCROLL_SCORE:50};showInventory(){if(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")return;const e=this.playerController.getPlayer().inventory,t=[];t.push(n("inventoryHeader")),e.length===0?t.push(n("inventoryEmpty")):e.forEach((s,i)=>{const o=m(s),r=G(s);if(t.push(`[${i+1}] ${s.char} ${o} x${s.quantity}`),t.push(`     ${r}`),s.itemType==="weapon"){const a=s,c=n("attackPowerEffect").replace("{{damage}}",String(a.damage)).replace("{{accuracy}}",String(a.accuracy));t.push(`      ${n("effectLabel")}: ${c}`)}else if(s.itemType==="armor"){const a=s,c=n("defenseEffect").replace("{{defense}}",String(a.defense));t.push(`      ${n("effectLabel")}: ${c}`)}}),this.getCurrentEquipmentDisplay&&(t.push(""),t.push(n("currentEquipmentHeader")),this.getCurrentEquipmentDisplay().forEach(i=>{t.push(i)})),t.push(""),t.push(n("usageInstructionsHeader")),t.push(n("itemUsageInstructions")),t.push(n("itemUsageExample")),this.addMessages?this.addMessages(t):t.forEach(s=>this.addMessage(s)),this.gameState.status==="tutorial"&&this.updateTutorialProgress("inventory")}useItem(e){return console.log(`=== InventoryManager.useItem CALLED with index: ${e} ===`),this.useItemInternal(e,!0)}useItemInternal(e,t){if(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")return!1;const s=this.playerController.getPlayer().inventory;if(e<0||e>=s.length)return this.addMessage(p("noItemInSlot",{slot:(e+1).toString()})),!1;const i=s[e],o=this.applyItemEffect(i);return o&&(this.playerController.removeItem(i.id,1),t&&this.processTurn()),o}applyItemEffect(e){if(console.log("=== applyItemEffect START ==="),console.log("Item:",e),console.log("Item type:",e?.itemType),console.log("equipItem callback exists:",!!this.equipItem),!e)return console.log("Item is null/undefined"),this.addMessage(p("invalidItem")),!1;if(!e.char)return console.log("Item missing char property"),this.addMessage(p("itemCannotBeUsed",{item:m(e)})),!1;if(e.itemType==="weapon"||e.itemType==="armor")if(console.log("=== EQUIPMENT ITEM DETECTED ==="),console.log("Item type:",e.itemType),this.equipItem){console.log("Calling equipItem callback...");const t=this.equipItem(e);return console.log("Equipment result:",t),t&&this.gameState.status==="tutorial"&&(this.updateTutorialProgress("equipment"),this.notifyEquipmentToggle&&(console.log("Notifying equipment toggle for equip action"),this.notifyEquipmentToggle())),console.log("=== applyItemEffect END (Equipment) ==="),t}else return console.log("No equipItem callback available"),this.addMessage(p("itemCannotBeUsed",{item:m(e)})),!1;switch(e.char){case"!":return this.playerController.heal(v.ITEM_EFFECTS.HEALTH_POTION),this.gameState.player.health=this.playerController.getPlayer().health,this.gameState.currentDungeon.player.health=this.gameState.player.health,this.addMessage(`${m(e)}${n("useItem")} ${n("healthRestored").replace("{{amount}}",v.ITEM_EFFECTS.HEALTH_POTION.toString())}`),this.gameState.status==="tutorial"&&this.updateTutorialProgress("equipment"),!0;case"+":return this.playerController.heal(v.ITEM_EFFECTS.HEALING_HERB),this.gameState.player.health=this.playerController.getPlayer().health,this.gameState.currentDungeon.player.health=this.gameState.player.health,this.addMessage(`${m(e)}${n("useItem")} ${n("healthRestored").replace("{{amount}}",v.ITEM_EFFECTS.HEALING_HERB.toString())}`),!0;case"%":return this.playerController.restoreEnergy(v.ITEM_EFFECTS.ENERGY_BAR),this.gameState.player.energy=this.playerController.getPlayer().energy,this.gameState.currentDungeon.player.energy=this.gameState.player.energy,this.addMessage(`${m(e)}${n("useItem")} ${n("energyRestored").replace("{{amount}}",v.ITEM_EFFECTS.ENERGY_BAR.toString())}`),!0;case"*":return this.playerController.restoreEnergy(v.ITEM_EFFECTS.ENERGY_CORE),this.gameState.player.energy=this.playerController.getPlayer().energy,this.gameState.currentDungeon.player.energy=this.gameState.player.energy,this.addMessage(`${m(e)}${n("useItem")} ${n("energyRestored").replace("{{amount}}",v.ITEM_EFFECTS.ENERGY_CORE.toString())}`),!0;case"?":const t=[()=>(this.playerController.heal(v.ITEM_EFFECTS.MYSTERY_SCROLL_HEALTH),this.gameState.player.health=this.playerController.getPlayer().health,this.gameState.currentDungeon.player.health=this.gameState.player.health,n("mysteryScrollHealth")),()=>(this.playerController.restoreEnergy(v.ITEM_EFFECTS.MYSTERY_SCROLL_ENERGY),this.gameState.player.energy=this.playerController.getPlayer().energy,this.gameState.currentDungeon.player.energy=this.gameState.player.energy,n("mysteryScrollEnergy")),()=>(this.gameState.score+=v.ITEM_EFFECTS.MYSTERY_SCROLL_SCORE,n("mysteryScrollScore")),()=>{const o=this.gameState.currentDungeon;for(let r=0;r<o.dimensions.height;r++)for(let a=0;a<o.dimensions.width;a++)Math.random()<.3&&(o.tiles[r][a].explored=!0);return n("mysteryScrollMap")}],s=t[Math.floor(Math.random()*t.length)],i=s();return this.addMessage(`${m(e)}${n("useItem")} ${i}`),!0;default:return this.addMessage(p("itemCannotBeUsed",{item:m(e)})),!1}}addMessagesIndividually(e){e.forEach(t=>this.addMessage(t))}}class ee{constructor(e,t,s,i,o){this.gameState=e,this.playerController=t,this.useItemCallback=s,this.removeEquipmentCallback=i,this.addMessage=o}toggleInventoryOverlay(){if(console.log("=== OverlayManager.toggleInventoryOverlay START ==="),console.log("Game status:",this.gameState.status),console.log("Current overlay:",this.gameState.overlay),this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"){console.log("Invalid game status, returning");return}this.gameState.overlay.type==="inventory"&&this.gameState.overlay.isVisible?(console.log("Hiding inventory overlay"),this.hideOverlay()):(console.log("Showing inventory overlay"),this.showInventoryOverlay()),console.log("Final overlay state:",this.gameState.overlay),console.log("=== OverlayManager.toggleInventoryOverlay END ===")}toggleStatusOverlay(){this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"||(console.log("=== STATUS OVERLAY TOGGLE ==="),console.log("Current game status:",this.gameState.status),console.log("Current overlay:",this.gameState.overlay),this.gameState.overlay.type==="character"&&this.gameState.overlay.isVisible?this.hideOverlay():this.showStatusOverlay())}toggleTakeoffOverlay(){this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"||(this.gameState.overlay.type==="takeoff"&&this.gameState.overlay.isVisible?this.hideOverlay():this.showTakeoffOverlay())}toggleEquipmentOverlay(){this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"||(this.gameState.overlay.type==="equipment"&&this.gameState.overlay.isVisible?this.hideOverlay():this.showEquipmentOverlay())}showInventoryOverlay(){this.gameState.overlay={type:"inventory",isVisible:!0,selectedIndex:0}}showStatusOverlay(){this.gameState.overlay={type:"character",isVisible:!0,selectedIndex:0}}showTakeoffOverlay(){const e=this.playerController.getPlayer(),t=[];if(e.equipment.mainHand&&t.push({slot:"weapon",item:e.equipment.mainHand}),e.equipment.head&&t.push({slot:"armor",item:e.equipment.head}),e.equipment.chest&&t.push({slot:"armor",item:e.equipment.chest}),e.equipment.legs&&t.push({slot:"armor",item:e.equipment.legs}),e.equipment.feet&&t.push({slot:"armor",item:e.equipment.feet}),e.equipment.offHand&&t.push({slot:"armor",item:e.equipment.offHand}),console.log("=== TAKEOFF OVERLAY CHECK ==="),console.log("Player equipment:",e.equipment),console.log("Equipped items found:",t.length),t.length===0){this.addMessage("外せる装備がありません。");return}this.gameState.overlay={type:"takeoff",isVisible:!0,selectedIndex:0}}showEquipmentOverlay(){this.gameState.overlay={type:"equipment",isVisible:!0,selectedIndex:0}}hideOverlay(){this.gameState.overlay={type:"none",isVisible:!1,selectedIndex:0}}handleNavigation(e){if(this.gameState.overlay.isVisible)switch(this.gameState.overlay.type){case"inventory":this.handleInventoryNavigation(e);break;case"character":break;case"takeoff":this.handleTakeoffNavigation(e);break}}handleInventoryNavigation(e){const t=this.playerController.getPlayer().inventory;if(t.length===0)return;const s=this.gameState.overlay.selectedIndex??0;let i=s;switch(e){case"north":i=Math.max(0,s-1);break;case"south":i=Math.min(t.length-1,s+1);break}this.gameState.overlay.selectedIndex=i}handleTakeoffNavigation(e){const t=this.playerController.getPlayer(),s=[];if(t.equipment.mainHand&&s.push({slot:"weapon",item:t.equipment.mainHand}),t.equipment.head&&s.push({slot:"armor",item:t.equipment.head,slotName:"head"}),t.equipment.chest&&s.push({slot:"armor",item:t.equipment.chest,slotName:"chest"}),t.equipment.legs&&s.push({slot:"armor",item:t.equipment.legs,slotName:"legs"}),t.equipment.feet&&s.push({slot:"armor",item:t.equipment.feet,slotName:"feet"}),t.equipment.offHand&&s.push({slot:"armor",item:t.equipment.offHand,slotName:"offHand"}),s.length===0)return;const i=this.gameState.overlay.selectedIndex||0;let o=i;switch(e){case"north":o=Math.max(0,i-1);break;case"south":o=Math.min(s.length-1,i+1);break}this.gameState.overlay.selectedIndex=o}handleInteraction(){if(console.log("=== OverlayManager.handleInteraction START ==="),console.log("Overlay visible:",this.gameState.overlay.isVisible),console.log("Overlay type:",this.gameState.overlay.type),!this.gameState.overlay.isVisible){console.log("Overlay not visible, returning");return}switch(this.gameState.overlay.type){case"inventory":console.log("Processing inventory interaction"),this.handleInventoryInteraction();break;case"character":console.log("Character overlay - no interaction needed");break;case"takeoff":console.log("Processing takeoff interaction"),this.handleTakeoffInteraction();break}console.log("=== OverlayManager.handleInteraction END ===")}handleInventoryInteraction(){console.log("=== OverlayManager.handleInventoryInteraction START ===");const e=this.playerController.getPlayer().inventory,t=this.gameState.overlay.selectedIndex??0;console.log("Inventory length:",e.length),console.log("Selected index:",t),console.log("Selected item:",e[t]),t<e.length?(console.log("Calling useItemCallback with index:",t),this.useItemCallback(t),this.hideOverlay()):console.log("Invalid index, no action taken"),console.log("=== OverlayManager.handleInventoryInteraction END ===")}handleTakeoffInteraction(){const e=this.playerController.getPlayer(),t=this.gameState.overlay.selectedIndex??0,s=[];if(e.equipment.mainHand&&s.push({slot:"weapon",item:e.equipment.mainHand}),e.equipment.head&&s.push({slot:"armor",item:e.equipment.head,slotName:"head"}),e.equipment.chest&&s.push({slot:"armor",item:e.equipment.chest,slotName:"chest"}),e.equipment.legs&&s.push({slot:"armor",item:e.equipment.legs,slotName:"legs"}),e.equipment.feet&&s.push({slot:"armor",item:e.equipment.feet,slotName:"feet"}),e.equipment.offHand&&s.push({slot:"armor",item:e.equipment.offHand,slotName:"offHand"}),console.log("=== TAKEOFF INTERACTION ==="),console.log("Selected index:",t),console.log("Available equipment:",s),t<s.length){const i=s[t];i.slot==="armor"&&i.slotName?(console.log(`Removing armor from slot: ${i.slotName}`),this.removeEquipmentCallback("armor")):(console.log(`Removing ${i.slot}`),this.removeEquipmentCallback(i.slot)),this.hideOverlay()}}useItemFromOverlay(e){const t=this.playerController.getPlayer().inventory;e>=t.length||(this.useItemCallback(e),e>=t.length-1&&(this.gameState.overlay.selectedIndex=Math.max(0,t.length-2)))}handlePauseOrClose(){return this.gameState.overlay.isVisible?(console.log("Closing overlay:",this.gameState.overlay),this.hideOverlay(),console.log("Overlay closed, returning early"),!0):!1}getOverlayState(){return this.gameState.overlay}isVisible(){return this.gameState.overlay.isVisible}isType(e){return this.gameState.overlay.type===e&&this.gameState.overlay.isVisible}}class te{dimensions;constructor(e){this.dimensions=e}createDoorTile(e,t=!1){return{position:{...e},type:"door",char:t?" ":"|",color:t?"#666666":"#ff8800",backgroundColor:"#000000",blocking:!t,explored:!1,visible:!1}}placeDoorsBetweenRooms(e,t){for(let s=0;s<t.length-1;s++){const i=t[s],o=t[s+1],r=this.calculateDoorPosition(i,o);r&&f(r,this.dimensions)&&(e[r.y][r.x]=this.createDoorTile(r,!1))}}calculateDoorPosition(e,t){const s=t.position.x-1,i=e.position.y+Math.floor(e.dimensions.height/2);return{x:s,y:i}}openDoorForStep(e,t,s){console.log("TutorialDoorManager.openDoorForStep() called"),console.log("Completed step:",s);const i=this.getRoomIndexByStep(t,s);if(console.log("Current room index:",i),i===-1||i>=t.length-1){console.log("No door to open (last room or invalid room)");return}const o=t[i],r=t[i+1],a=this.calculateDoorPosition(o,r);if(console.log("Door position:",a),console.log("Current room:",o),console.log("Next room:",r),a&&f(a,this.dimensions)){console.log("Opening door at position:",a);const c=e[a.y][a.x];console.log("Before tile:",c),e[a.y][a.x]=this.createDoorTile(a,!0);const u=e[a.y][a.x];console.log("After tile:",u)}else console.log("Door position is invalid or out of bounds")}getRoomIndexByStep(e,t){const s=e.findIndex(i=>i.tutorialStep===t);return console.log(`Looking for room with step: ${t}, found index: ${s}`),console.log("Available rooms:",e.map(i=>({step:i.tutorialStep,pos:i.position}))),s}isPlayerAtDoor(e,t){return e[t.y]?.[t.x]?.type==="door"}isPlayerTryingClosedDoor(e,t){const s=e[t.y]?.[t.x];return s?.type==="door"&&s.blocking===!0}isDoorOpen(e,t){const s=e[t.y]?.[t.x];return s?.type==="door"&&s.blocking===!1}forceDoorOpen(e,t){f(t,this.dimensions)&&e[t.y][t.x].type==="door"&&(e[t.y][t.x]=this.createDoorTile(t,!0))}getNextDoorPosition(e,t){const s=this.getRoomIndexByStep(e,t);if(s===-1||s>=e.length-1)return null;const i=e[s],o=e[s+1];return this.calculateDoorPosition(i,o)}openAllDoorsToRoom(e,t,s){const i=this.getRoomIndexByStep(t,s);if(i!==-1)for(let o=0;o<i;o++){const r=t[o],a=t[o+1],c=this.calculateDoorPosition(r,a);c&&f(c,this.dimensions)&&(e[c.y][c.x]=this.createDoorTile(c,!0))}}openAllDoors(e,t){for(let s=0;s<t.length-1;s++){const i=t[s],o=t[s+1],r=this.calculateDoorPosition(i,o);r&&f(r,this.dimensions)&&(e[r.y][r.x]=this.createDoorTile(r,!0))}}getDoorMessage(e,t,s){if(!this.isPlayerAtDoor(e,t))return null;if(this.isPlayerTryingClosedDoor(e,t))switch(s){case"welcome":return"移動の練習を完了してから次の部屋に進みましょう";case"movement":return"戦闘の練習を完了してから次の部屋に進みましょう";case"combat":return"インベントリの練習を完了してから次の部屋に進みましょう";case"inventory":return"アイテム使用の練習を完了してから次の部屋に進みましょう";default:return"このステップを完了してから次に進みましょう"}return null}removeDoor(e,t){!f(t,this.dimensions)||e[t.y][t.x].type!=="door"||(e[t.y][t.x]={position:{...t},type:"floor",char:".",color:"#666666",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1},console.log(`Door at (${t.x}, ${t.y}) converted to floor tile with blocking: false`))}removeDoorForStep(e,t,s){console.log("TutorialDoorManager.removeDoorForStep() called"),console.log("Completed step:",s);const i=this.getRoomIndexByStep(t,s);if(console.log("Current room index:",i),i===-1||i>=t.length-1){console.log("No door to remove (last room or invalid room)");return}const o=t[i],r=t[i+1],a=this.calculateDoorPosition(o,r);console.log("Removing door at position:",a),a&&f(a,this.dimensions)?(this.removeDoor(e,a),console.log("Door removed successfully")):console.log("Door position is invalid or out of bounds")}}class se{constructor(e,t,s){this.gameState=e,this.addMessage=t,this.updatePlayerPosition=s,this.tutorialDungeonGenerator=new N,this.doorManager=new te({width:72,height:30})}tutorialDungeonGenerator;doorManager;originalDungeon=null;startTutorial(){this.originalDungeon={...this.gameState.currentDungeon};const e=this.gameState.currentDungeon;this.doorManager.placeDoorsBetweenRooms(e.tiles,e.rooms),this.gameState.status="tutorial",this.gameState.tutorial.isActive=!0,this.gameState.tutorial.currentStep="welcome",this.gameState.tutorial.stepProgress=0,this.gameState.tutorial.showHint=!0,this.gameState.tutorial.hintText=n("tutorialWelcome"),this.addMessage(n("tutorialStarted")),this.addMessage("チュートリアル専用マップを生成しました。"),this.addMessage("専用の練習エリアに移動しました。WASDキーで移動してみましょう！")}updateProgress(e){this.gameState.tutorial,console.log("TutorialManager.updateProgress() called but deferred to InteractiveTutorialManager")}advanceStep(e){this.gameState.tutorial.currentStep=e,this.gameState.tutorial.stepProgress=0,this.gameState.tutorial.hintText=this.getHintText(e),this.addMessage(this.getStepMessage(e)),e==="complete"&&this.completeTutorial()}getHintText(e){switch(e){case"welcome":return n("tutorialWelcome");case"movement":return n("tutorialMovement");case"combat":return n("tutorialCombat");case"inventory":return n("tutorialInventory");case"equipment":return n("tutorialEquipment");case"complete":return n("tutorialCompleted");default:return""}}getStepMessage(e){switch(e){case"movement":return n("tutorialProgressMovement");case"combat":return"移動完了！次は戦闘の練習です。";case"inventory":return n("tutorialProgressCombatComplete");case"equipment":return n("tutorialProgressInventory");case"complete":return n("tutorialProgressEquipment");default:return""}}completeTutorial(){this.gameState.tutorial.isActive=!1,this.gameState.tutorial.showHint=!1,this.originalDungeon&&(this.gameState.currentDungeon=this.originalDungeon,this.originalDungeon=null),this.gameState.status="welcome",this.addMessage(p("tutorialComplete")),this.addMessage("チュートリアル完了！タイトルに戻ります。")}skipTutorial(){this.completeTutorial()}completeTutorialAndReturnToTitle(){this.gameState.tutorial.isActive=!1,this.gameState.tutorial.showHint=!1,this.originalDungeon=null,this.gameState.status="welcome",this.addMessage(p("tutorialComplete")),this.addMessage("チュートリアル完了！タイトル画面に戻ります。")}toggleHint(){this.gameState.tutorial.showHint=!this.gameState.tutorial.showHint}getTutorialState(){return this.gameState.tutorial}isActive(){return this.gameState.tutorial.isActive}getCurrentStep(){return this.gameState.tutorial.currentStep}shouldRestrictAction(e){return this.isActive(),!1}getContextualHint(){return this.isActive()?this.gameState.tutorial.hintText:null}openNextDoor(){const e=this.gameState.tutorial.currentStep,t=this.gameState.currentDungeon.rooms,s=this.gameState.currentDungeon.tiles;console.log("TutorialManager.openNextDoor() called"),console.log("Current step:",e),console.log("Rooms length:",t.length),this.doorManager.removeDoorForStep(s,t,e),this.addMessage("次の部屋への扉が開きました！")}openDoorForStep(e){const t=this.gameState.currentDungeon.rooms,s=this.gameState.currentDungeon.tiles;console.log("TutorialManager.openDoorForStep() called"),console.log("Step:",e),console.log("Rooms length:",t.length),this.doorManager.removeDoorForStep(s,t,e),this.addMessage("次の部屋への扉が開きました！")}checkDoorInteraction(e){const t=this.gameState.currentDungeon.tiles,s=this.gameState.tutorial.currentStep;return this.doorManager.getDoorMessage(t,e,s)}checkPlayerRoom(){const e=this.gameState.player.position,t=this.gameState.currentDungeon.rooms,s=this.findPlayerRoom(e,t);s&&s.tutorialStep&&this.handleRoomEntry(s.tutorialStep)}findPlayerRoom(e,t){return t.find(s=>e.x>=s.position.x&&e.x<s.position.x+s.dimensions.width&&e.y>=s.position.y&&e.y<s.position.y+s.dimensions.height)||null}handleRoomEntry(e){if(e!==this.gameState.tutorial.currentStep){const t={welcome:"チュートリアル開始！移動の練習をしましょう。",movement:"移動の部屋に入りました。WASDキーで移動してみてください。",combat:"戦闘の部屋に入りました。Spaceキーで攻撃モードを切り替えてみてください。",inventory:"インベントリの部屋に入りました。Iキーでインベントリを開いてみてください。",equipment:"装備の部屋に入りました。数字キーでアイテムを使用してみてください。",complete:"チュートリアル完了です！"};t[e]&&this.addMessage(t[e])}}openAllDoors(){const e=this.gameState.currentDungeon.rooms,t=this.gameState.currentDungeon.tiles;this.doorManager.openAllDoors(t,e),this.addMessage("デバッグ：全ての扉を開きました")}}class ie{steps;currentStepIndex=0;itemUsedFlag=!1;combatCompletedFlag=!1;statusViewedFlag=!1;equipmentToggleCount=0;tutorialManager=null;equipmentSequence=["equip_item","view_status","unequip_item","view_status","equip_item"];equipmentSequenceIndex=0;equipmentFlowCompleted=!1;constructor(){this.steps=this.initializeStepsFromConfig()}setTutorialManager(e){this.tutorialManager=e}initializeStepsFromConfig(){return A.getSteps().map(t=>{const s={...t};switch(t.id){case"step_movement":s.completionCondition=i=>{const o=S.getMovementTargetPosition(),r=i.player.position;return console.log(`Player position: (${r.x}, ${r.y}), Target: (${o.x}, ${o.y})`),r.x===o.x&&r.y===o.y};break;case"step_item_pickup":s.completionCondition=i=>this.itemUsedFlag;break;case"step_equipment":s.completionCondition=i=>this.equipmentToggleCount>=2;break;case"step_combat":s.completionCondition=i=>this.combatCompletedFlag;break;case"step_character_status":s.completionCondition=i=>this.statusViewedFlag;break}return s})}getCurrentStep(){return this.currentStepIndex>=this.steps.length?null:this.steps[this.currentStepIndex]}completeCurrentStep(){const e=this.getCurrentStep();e&&(e.isCompleted=!0)}moveToNextStep(){if(this.currentStepIndex<this.steps.length){if(this.tutorialManager){const e=this.getCurrentStep();if(e){console.log(`InteractiveTutorialManager: ${e.id} step completed, opening door`);const t=A.getPreviousStepId(this.currentStepIndex);t&&this.tutorialManager.openDoorForStep(t);const s=e.nextStepId;if(s){const i=A.getRoomTypeForStep(s);this.tutorialManager.advanceStep(i)}else this.tutorialManager.advanceStep("complete")}}this.currentStepIndex++}}checkStepCompletion(e){const t=this.getCurrentStep();return t?t.completionCondition(e):!1}isActionAllowed(e){const t=this.getCurrentStep();return t?!t.blockedActions?.includes(e):!0}getCurrentStepInfo(){const e=this.getCurrentStep();return e?{title:e.title,description:e.description,isCompleted:e.isCompleted,targetPosition:e.targetPosition||void 0}:{title:"チュートリアル完了",description:"すべてのチュートリアルが完了しました！",isCompleted:!0}}getProgress(){const e=this.currentStepIndex+1,t=A.getTotalSteps(),s=Math.round(e/t*100);return{currentStep:e,totalSteps:t,percentage:s}}isAllStepsCompleted(){return this.currentStepIndex>=this.steps.length}getCompletedSteps(){return this.steps.filter(e=>e.isCompleted)}isStepCompleted(e){return this.steps.find(s=>s.id===e)?.isCompleted??!1}updateTutorial(e){this.isAllStepsCompleted()||this.checkStepCompletion(e)&&(this.completeCurrentStep(),this.moveToNextStep())}markItemUsed(){this.itemUsedFlag=!0}markCombatCompleted(){this.combatCompletedFlag=!0}markEquipmentToggled(){this.equipmentToggleCount++,this.getCurrentStep()?.id==="step_equipment"&&(console.log("=== EQUIPMENT TUTORIAL FLOW ==="),console.log("Equipment toggle count:",this.equipmentToggleCount),console.log("Current sequence index:",this.equipmentSequenceIndex),console.log("Expected action:",this.equipmentSequence[this.equipmentSequenceIndex]),(this.equipmentSequence[this.equipmentSequenceIndex]==="equip_item"||this.equipmentSequence[this.equipmentSequenceIndex]==="unequip_item")&&this.advanceEquipmentSequence())}markStatusViewed(){this.statusViewedFlag=!0,this.getCurrentStep()?.id==="step_equipment"&&(console.log("=== STATUS VIEW IN EQUIPMENT TUTORIAL ==="),console.log("Current sequence index:",this.equipmentSequenceIndex),console.log("Expected action:",this.equipmentSequence[this.equipmentSequenceIndex]),this.equipmentSequence[this.equipmentSequenceIndex]==="view_status"&&this.advanceEquipmentSequence())}advanceEquipmentSequence(){this.equipmentSequenceIndex++,console.log(`Equipment sequence advanced to step ${this.equipmentSequenceIndex}/${this.equipmentSequence.length}`),this.equipmentSequenceIndex>=this.equipmentSequence.length?(this.equipmentFlowCompleted=!0,console.log("Equipment tutorial flow completed!")):console.log(`Next required action: ${this.equipmentSequence[this.equipmentSequenceIndex]}`)}getEquipmentTutorialMessage(){if(this.getCurrentStep()?.id!=="step_equipment")return"";if(this.equipmentSequenceIndex>=this.equipmentSequence.length)return"装備チュートリアル完了！次の部屋に進んでください。";const e=this.equipmentSequence[this.equipmentSequenceIndex];return{equip_item:"インベントリ（Iキー）からアイテムを装備してください",view_status:"ステータス画面（Cキー）で装備状況を確認してください",unequip_item:"装備脱着画面（Tキー）で装備を外してください"}[e]||`次のアクション: ${e}`}isDoorOpenForNextRoom(){const e=this.getCurrentStep();return e?!!(e.id==="step_item_pickup"&&this.itemUsedFlag||e.id==="step_equipment"&&this.equipmentToggleCount>=2):!1}getTutorialItemPickupMessage(e){const t=this.getCurrentStep();if(!t||t.id!=="step_item_pickup")return"";switch(e){case"health_potion":return"ポーションを取得しました！Iキーでインベントリを開いて確認してみてください。";default:return`${e}を取得しました！次はIキーでインベントリを確認しましょう。`}}reset(){this.currentStepIndex=0,this.itemUsedFlag=!1,this.combatCompletedFlag=!1,this.statusViewedFlag=!1,this.equipmentSequenceIndex=0,this.equipmentFlowCompleted=!1,this.equipmentToggleCount=0,this.steps.forEach(e=>{e.isCompleted=!1})}}class oe{stepOrder=["step_movement","step_item_pickup","step_equipment","step_combat","step_character_status"];totalSteps=this.stepOrder.length;roomTypeMapping={step_movement:"movement",step_item_pickup:"movement",step_equipment:"equipment",step_combat:"combat",step_character_status:"inventory"};stepDefinitions=[{id:"step_movement",title:"移動の練習",description:"WASDキーまたは矢印キーで移動してください。目標地点に到達すると次のステップに進みます。",targetAction:"movement",targetPosition:S.getMovementTargetPosition(),blockedActions:["attack","inventory"],completionCondition:()=>!1,isCompleted:!1,nextStepId:"step_item_pickup"},{id:"step_item_pickup",title:"アイテムの取得と装備",description:"Fキーでアイテムを取得し、Iキーでインベントリを開き、1キーで装備してください。",targetAction:"item_use",blockedActions:["attack"],completionCondition:()=>!1,isCompleted:!1,nextStepId:"step_equipment"},{id:"step_equipment",title:"装備の着脱",description:"Tキーで装備を外してみてください。装備を外す→再装備の2回操作すると扉が開きます。",targetAction:"equipment",blockedActions:["attack"],completionCondition:()=>!1,isCompleted:!1,nextStepId:"step_combat"},{id:"step_combat",title:"戦闘の練習",description:"SPACEキーで攻撃モードに切り替え、敵を倒してください。戦闘中もIキーでアイテム、Cキーでステータスを確認できます。",targetAction:"combat",blockedActions:[],completionCondition:()=>!1,isCompleted:!1,nextStepId:"step_character_status"},{id:"step_character_status",title:"ステータス確認",description:"Cキーでキャラクターのステータスを確認してください。",targetAction:"character_status",blockedActions:[],completionCondition:()=>!1,isCompleted:!1}];getSteps(){return this.stepDefinitions}getStep(e){return this.stepDefinitions.find(t=>t.id===e)||null}getStepIndex(e){return this.stepOrder.indexOf(e)}getNextStepId(e){const t=this.getStepIndex(e);if(!(t===-1||t>=this.stepOrder.length-1))return this.stepOrder[t+1]}getPreviousStepId(e){const t=this.getStepIndex(e);if(!(t<=0))return this.stepOrder[t-1]}getRoomTypeForStep(e){return this.roomTypeMapping[e]||"movement"}}const re=new oe;class ae{constructor(e=re){this.configuration=e,this.steps=this.initializeSteps()}steps;currentStepIndex=0;isActivated=!1;isCompletedFlag=!1;completedStepIds=new Set;itemUsedFlag=!1;combatCompletedFlag=!1;statusViewedFlag=!1;equipmentToggleCount=0;addMessageCallback;updatePlayerPositionCallback;processTurnCallback;setGameStatusCallback=void 0;openDoorCallback=void 0;openPlayerSurroundingDoorsCallback=void 0;openDoorAtIndexCallback=void 0;events={onStepStart:()=>{},onStepComplete:()=>{},onTutorialComplete:()=>{},onActionBlocked:()=>{}};start(){this.isActivated=!0,this.currentStepIndex=0,this.completedStepIds.clear(),this.resetFlags(),this.setGameStatusCallback?.("tutorial"),this.events.onStepStart(this.getCurrentStepId()),this.addMessageCallback?.("チュートリアルを開始します。")}complete(){this.isActivated=!1,this.isCompletedFlag=!0,this.events.onTutorialComplete(),this.addMessageCallback?.("チュートリアルが完了しました。")}skip(){this.isActivated=!1,this.addMessageCallback?.("チュートリアルをスキップしました。")}reset(){this.currentStepIndex=0,this.completedStepIds.clear(),this.resetFlags(),this.isActivated=!1,this.isCompletedFlag=!1}moveToNextStep(){if(this.currentStepIndex>=this.steps.length-1)return this.complete(),!1;const e=this.getCurrentStep();e&&(e.isCompleted=!0,this.completedStepIds.add(e.id),this.events.onStepComplete(e.id)),this.currentStepIndex++;const t=this.getCurrentStep();return t?(this.events.onStepStart(t.id),!0):!1}moveToPreviousStep(){if(this.currentStepIndex<=0)return!1;this.currentStepIndex--;const e=this.getCurrentStep();return e?(this.events.onStepStart(e.id),!0):!1}jumpToStep(e){const t=this.configuration.getStepIndex(e);return t===-1?!1:(this.currentStepIndex=t,this.events.onStepStart(e),!0)}checkStepCompletion(e){const t=this.getCurrentStep();return t?t.completionCondition(e):!1}isActionAllowed(e){const t=this.getCurrentStep();return!t||!t.blockedActions?!0:!t.blockedActions.includes(e)}updateProgress(e){if(console.log("UnifiedTutorialSystem.updateProgress called:",{isActivated:this.isActivated,currentStepIndex:this.currentStepIndex,stepsLength:this.steps.length}),!this.isActivated){console.log("Tutorial not activated, returning early");return}const t=this.getCurrentStep(),s=this.checkStepCompletion(e);if(console.log("UnifiedTutorialSystem.updateProgress:",{currentStepId:t?.id,playerPos:e.player.position,targetPos:t?.targetPosition,isCompleted:s}),s){console.log("Step completed! Moving to next step...");const i=this.getCurrentStepId();switch(i){case"step_movement":this.addMessageCallback?.("移動チュートリアル完了！扉が開きました。");break;case"step_item_pickup":this.addMessageCallback?.("アイテム使用完了！扉が開きました。");break;case"step_equipment":this.addMessageCallback?.("装備着脱完了！扉が開きました。次の部屋へ進めます。");break;case"step_combat":this.addMessageCallback?.("戦闘チュートリアル完了！扉が開きました。");break}this.moveToNextStep();const o=this.getCurrentStep();console.log("Moved to next step:",{newStepId:o?.id,newStepIndex:this.currentStepIndex}),this.handleDoorOpening(i)}}markActionCompleted(e){this.processTurnCallback?.()}markItemUsed(){console.log("UnifiedTutorialSystem.markItemUsed called"),this.itemUsedFlag=!0,console.log(`Item used flag set to: ${this.itemUsedFlag}`),this.markActionCompleted("item_use")}markEquipmentToggled(){this.equipmentToggleCount++,console.log(`UnifiedTutorialSystem.markEquipmentToggled: count now ${this.equipmentToggleCount}`),this.markActionCompleted("equipment_toggle")}markCombatCompleted(){this.combatCompletedFlag=!0,this.markActionCompleted("combat")}markStatusViewed(){this.statusViewedFlag=!0,this.markActionCompleted("status_view")}handleDoorOpening(e){console.log("=== UnifiedTutorialSystem: DOOR OPENING DEBUG ==="),console.log(`Opening door for step: ${e}`),console.log(`Equipment toggle count: ${this.equipmentToggleCount}`);const t=this.configuration.getStepIndex(e);if(console.log(`Step ${e} has index: ${t}`),e==="step_equipment")if(console.log(`Equipment step completed with ${this.equipmentToggleCount} toggles`),this.equipmentToggleCount>=2)console.log("Equipment step meets door opening criteria (2+ toggles)");else{console.log("Equipment step does NOT meet door opening criteria yet");return}if(this.openPlayerSurroundingDoorsCallback&&e==="step_movement"&&(console.log("Opening doors around player for movement step"),this.openPlayerSurroundingDoorsCallback()),this.openDoorAtIndexCallback)console.log(`Opening door at index: ${t} for step: ${e}`),this.openDoorAtIndexCallback(t);else{const s=this.convertToLegacyStep(e);console.log(`Converting ${e} to legacy step: ${s}`),this.openDoorCallback&&s&&this.openDoorCallback(s)}console.log("=== DOOR OPENING DEBUG END ===")}convertToLegacyStep(e){return{step_movement:"movement",step_item_pickup:"inventory",step_equipment:"equipment",step_combat:"combat",step_character_status:"complete"}[e]||null}getCoordinateInfo(){return{playerStartPosition:S.getPlayerStartPosition(),movementTargetPosition:S.getMovementTargetPosition(),welcomeRoomPosition:S.getWelcomeRoomPosition(),roomDimensions:{width:S.ROOM_DIMENSIONS.width,height:S.ROOM_DIMENSIONS.height}}}setCallbacks(e){this.addMessageCallback=e.addMessage,this.updatePlayerPositionCallback=e.updatePlayerPosition,this.processTurnCallback=e.processTurn,this.setGameStatusCallback=e.setGameStatus,this.openDoorCallback=e.openDoor,this.openPlayerSurroundingDoorsCallback=e.openPlayerSurroundingDoors,this.openDoorAtIndexCallback=e.openDoorAtIndex}get state(){return{currentStepId:this.getCurrentStepId(),currentStepIndex:this.currentStepIndex,totalSteps:this.steps.length,isActive:this.isActivated,isCompleted:this.isCompletedFlag,progress:Math.round(this.currentStepIndex/this.steps.length*100),currentStep:this.getCurrentStep()??void 0}}get currentStep(){return this.getCurrentStep()}isStepCompleted(e){return this.completedStepIds.has(e)}getCompletedSteps(){return Array.from(this.completedStepIds)}getProgress(){return{current:this.currentStepIndex+1,total:this.steps.length,percentage:Math.round((this.currentStepIndex+1)/this.steps.length*100)}}getState(){return this.state}getCurrentStep(){return this.currentStepIndex>=this.steps.length||this.currentStepIndex<0?null:this.steps[this.currentStepIndex]}getStepInfo(){const e=this.getCurrentStep();if(!e)return{title:"",description:""};const t={title:e.title,description:e.description};return e.targetPosition&&(t.targetPosition=e.targetPosition),t}getCurrentStepId(){const e=this.getCurrentStep();return e?e.id:""}initializeSteps(){return this.configuration.getSteps().map(t=>{const s={...t};switch(t.id){case"step_movement":s.completionCondition=i=>{const o=S.getMovementTargetPosition(),r=i.player.position,a=r.x===o.x&&r.y===o.y;return console.log("step_movement completion check:",{playerPos:r,targetPos:o,isEqual:a}),a},s.targetPosition=S.getMovementTargetPosition(),console.log("step_movement targetPosition set to:",s.targetPosition);break;case"step_item_pickup":s.completionCondition=()=>(console.log(`step_item_pickup completion check: itemUsedFlag=${this.itemUsedFlag}`),this.itemUsedFlag);break;case"step_equipment":s.completionCondition=()=>{const i=this.equipmentToggleCount>=2;return console.log(`step_equipment completion check: toggleCount=${this.equipmentToggleCount}, isCompleted=${i}`),i};break;case"step_combat":s.completionCondition=()=>this.combatCompletedFlag;break;case"step_character_status":s.completionCondition=()=>this.statusViewedFlag;break}return s})}resetFlags(){this.itemUsedFlag=!1,this.combatCompletedFlag=!1,this.statusViewedFlag=!1,this.equipmentToggleCount=0}}class ne{constructor(e,t,s,i){this.gameState=e,this.addMessage=t,this.startGameCallback=s,this.startTutorialCallback=i}showMenu(){this.addMessage(n("menuNotImplemented"))}handleLanguageSwitch(){const t=I.getCurrentLanguage()==="ja"?"en":"ja";I.setLanguage(t),this.updateUITexts(),this.addMessage(n("languageSwitched"))}updateUITexts(){}showSettings(){this.addMessage(n("settingsUnderDevelopment"))}showPrologue(){this.gameState.welcome.showPrologue=!0}skipPrologue(){this.gameState.welcome.showPrologue=!1,this.gameState.welcome.selectedOption||(this.gameState.welcome.selectedOption="start")}handleWelcomeInteract(){if(this.gameState.status!=="welcome")return;if(this.gameState.welcome.showPrologue){this.skipPrologue();return}const e=this.gameState.welcome.selectedOption;if(e)switch(e){case"start":this.startGameCallback();break;case"tutorial":this.startTutorialCallback();break;case"settings":this.showSettings();break}}navigateWelcomeMenu(e){if(this.gameState.status!=="welcome"||this.gameState.welcome.showPrologue)return;const t=["start","tutorial","settings"],s=t.indexOf(this.gameState.welcome.selectedOption||"start");let i=s;e==="up"?i=Math.max(0,s-1):i=Math.min(t.length-1,s+1),this.gameState.welcome.selectedOption=t[i]}getCurrentLanguage(){return I.getCurrentLanguage()}setLanguage(e){I.setLanguage(e),this.updateUITexts()}showGameOver(e){this.addMessage(p("gameOver")),this.addMessage(p("finalScore",{score:e.toString()}))}showVictory(e){this.addMessage(p("victory")),this.addMessage(p("finalScore",{score:e.toString()}))}isUIElementVisible(e){switch(e){case"prologue":return this.gameState.welcome.showPrologue;case"menu":return this.gameState.status==="menu";case"settings":return!1;default:return!1}}}class le{keyMapping;pressedKeys;actionCallbacks;element;keyRepeatTimer;REPEAT_DELAY=300;REPEAT_RATE=100;constructor(e){this.element=e,this.pressedKeys=new Set,this.actionCallbacks=new Map,this.keyRepeatTimer=new Map,this.keyMapping={KeyW:"move_north",ArrowUp:"move_north",KeyS:"move_south",ArrowDown:"move_south",KeyA:"move_west",ArrowLeft:"move_west",KeyD:"move_east",ArrowRight:"move_east",KeyF:"interact",Enter:"interact",Space:"attack",KeyX:"attack",KeyI:"inventory",KeyE:"equipment",KeyC:"character",Comma:"pickup",KeyG:"pickup",KeyQ:"quaff",KeyR:"read",KeyT:"takeoff",Digit1:"use_item_1",Digit2:"use_item_2",Digit3:"use_item_3",Digit4:"use_item_4",Digit5:"use_item_5",Digit6:"use_item_6",Digit7:"use_item_7",Digit8:"use_item_8",Digit9:"use_item_9",Escape:"pause",KeyM:"menu",KeyL:"language_switch"},this.setupEventListeners()}setupEventListeners(){this.element.tabIndex<0&&(this.element.tabIndex=0),this.element.focus();const e=s=>{s.preventDefault();const i=s.code;if(!this.pressedKeys.has(i)){this.pressedKeys.add(i),this.handleKeyPress(i);const o=this.keyMapping[i];this.isMovementAction(o)&&this.setupKeyRepeat(i)}},t=s=>{s.preventDefault();const i=s.code;this.pressedKeys.delete(i),this.clearKeyRepeat(i)};this.element.addEventListener("keydown",e),this.element.addEventListener("keyup",t),this.element.addEventListener("blur",()=>{this.element.focus()}),this.element.addEventListener("click",()=>{this.element.focus()})}handleKeyPress(e){const t=this.keyMapping[e];if(t&&this.actionCallbacks.has(t)){const s=this.actionCallbacks.get(t);s&&s()}}onAction(e,t){this.actionCallbacks.set(e,t)}offAction(e){this.actionCallbacks.delete(e)}setKeyMapping(e){Object.assign(this.keyMapping,e)}getKeyMapping(){return{...this.keyMapping}}isKeyPressed(e){return this.pressedKeys.has(e)}isMovementKeyPressed(){return["KeyW","KeyS","KeyA","KeyD","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].some(t=>this.pressedKeys.has(t))}getPressedKeys(){return Array.from(this.pressedKeys)}isMovementAction(e){return e==="move_north"||e==="move_south"||e==="move_east"||e==="move_west"}setupKeyRepeat(e){this.clearKeyRepeat(e);const t=setTimeout(()=>{const s=setInterval(()=>{this.pressedKeys.has(e)?this.handleKeyPress(e):this.clearKeyRepeat(e)},this.REPEAT_RATE);this.keyRepeatTimer.set(e,s)},this.REPEAT_DELAY);this.keyRepeatTimer.set(e,t)}clearKeyRepeat(e){const t=this.keyRepeatTimer.get(e);t!==void 0&&(clearTimeout(t),clearInterval(t),this.keyRepeatTimer.delete(e))}clearPressedKeys(){this.pressedKeys.clear(),this.keyRepeatTimer.forEach(e=>{clearTimeout(e),clearInterval(e)}),this.keyRepeatTimer.clear()}disable(){this.clearPressedKeys()}focus(){this.element.focus()}getActionForKey(e){return this.keyMapping[e]}getKeyForAction(e){for(const[t,s]of Object.entries(this.keyMapping))if(s===e)return t}keyToDisplayString(e){return{KeyW:"W",KeyA:"A",KeyS:"S",KeyD:"D",KeyE:"E",KeyC:"C",KeyF:"F",KeyG:"G",KeyI:"I",KeyL:"L",KeyM:"M",KeyQ:"Q",KeyR:"R",KeyT:"T",KeyX:"X",Comma:",",Enter:"Enter",Digit1:"1",Digit2:"2",Digit3:"3",Digit4:"4",Digit5:"5",Digit6:"6",Digit7:"7",Digit8:"8",Digit9:"9",ArrowUp:"↑",ArrowDown:"↓",ArrowLeft:"←",ArrowRight:"→",Space:"Space",Escape:"Esc"}[e]||e}}class ce{constructor(e,t,s,i,o,r,a,c,u,g,h,d,y){this.gameState=t,this.handleDirectionalInputCallback=s,this.toggleAttackModeCallback=i,this.handleInteractCallback=o,this.toggleInventoryOverlayCallback=r,this.toggleStatusOverlayCallback=a,this.toggleTakeoffOverlayCallback=c,this.handleItemActionCallback=u,this.togglePauseCallback=g,this.showMenuCallback=h,this.handleLanguageSwitchCallback=d,this.handleEquipmentToggleCallback=y,this.inputHandler=new le(e),this.setupInputHandlers()}inputHandler;setupInputHandlers(){this.inputHandler.onAction("move_north",()=>this.handleDirectionalInputCallback("north")),this.inputHandler.onAction("move_south",()=>this.handleDirectionalInputCallback("south")),this.inputHandler.onAction("move_east",()=>this.handleDirectionalInputCallback("east")),this.inputHandler.onAction("move_west",()=>this.handleDirectionalInputCallback("west")),this.inputHandler.onAction("attack",()=>this.toggleAttackModeCallback()),this.inputHandler.onAction("interact",()=>this.handleInteractCallback()),this.inputHandler.onAction("inventory",()=>this.toggleInventoryOverlayCallback()),this.inputHandler.onAction("character",()=>this.toggleStatusOverlayCallback()),this.inputHandler.onAction("takeoff",()=>this.toggleTakeoffOverlayCallback()),this.inputHandler.onAction("equipment",()=>this.handleEquipmentToggleCallback());for(let e=1;e<=9;e++)this.inputHandler.onAction(`use_item_${e}`,()=>this.handleItemActionCallback(e-1));this.inputHandler.onAction("pause",()=>this.togglePauseCallback()),this.inputHandler.onAction("menu",()=>this.showMenuCallback()),this.inputHandler.onAction("language_switch",()=>this.handleLanguageSwitchCallback())}getInputHandler(){return this.inputHandler}disable(){this.inputHandler.disable()}clearPressedKeys(){this.inputHandler.clearPressedKeys()}focus(){this.inputHandler.focus()}setKeyMapping(e){this.inputHandler.setKeyMapping(e)}getKeyMapping(){return this.inputHandler.getKeyMapping()}isKeyPressed(e){return this.inputHandler.isKeyPressed(e)}isMovementKeyPressed(){return this.inputHandler.isMovementKeyPressed()}getPressedKeys(){return this.inputHandler.getPressedKeys()}getKeyForAction(e){return this.inputHandler.getKeyForAction(e)}getActionForKey(e){return this.inputHandler.getActionForKey(e)}keyToDisplayString(e){return this.inputHandler.keyToDisplayString(e)}}class ue{constructor(e,t){this.playerController=e,this.dungeonManager=t}createInitialGameState(){const e=this.playerController.getPlayer(),t=this.dungeonManager.generateInitialFloor(e);return this.playerController.setPosition(t.player.position),{status:"welcome",player:e,currentDungeon:t,dungeonData:this.dungeonManager.getDungeonData(),turn:0,score:0,messages:[],levelCleared:!1,tutorial:{isActive:!1,currentStep:"welcome",stepProgress:0,showHint:!1,hintText:""},welcome:{showPrologue:!0,selectedOption:"start"},overlay:{type:"none",isVisible:!1,selectedIndex:0}}}updateGameState(e,t){Object.assign(e,t)}updatePlayerState(e,t){Object.assign(e.player,t)}updateDungeonState(e,t){e.currentDungeon=t,e.dungeonData=this.dungeonManager.getDungeonData()}updateTutorialState(e,t){Object.assign(e.tutorial,t)}updateWelcomeState(e,t){Object.assign(e.welcome,t)}updateOverlayState(e,t){Object.assign(e.overlay,t)}incrementTurn(e){e.turn++}addMessage(e,t){e.messages.push(t),e.messages.length>100&&(e.messages=e.messages.slice(-100))}clearMessages(e){e.messages=[]}getGameStats(e){return{turnCount:e.turn,score:e.score}}calculateScore(e){const t=e.player;let s=0;return s+=t.level*100,s+=Math.max(0,1e3-e.turn),Math.max(0,s)}validateGameState(e){try{return!(!e.player||!e.currentDungeon||e.player.health<=0&&e.status!=="paused"||!e.currentDungeon.tiles||!e.currentDungeon.entities)}catch(t){return console.error("Game state validation error:",t),!1}}cloneGameState(e){return JSON.parse(JSON.stringify(e))}createSaveData(e){return{version:"1.0.0",timestamp:Date.now(),gameState:this.cloneGameState(e),playerStats:this.getGameStats(e),score:this.calculateScore(e)}}restoreFromSaveData(e){try{if(!e||!e.gameState)return null;const t=e.gameState;return this.validateGameState(t)?t:null}catch(t){return console.error("Failed to restore game state:",t),null}}resetGameState(){return this.createInitialGameState()}}class he{constructor(e,t,s,i,o,r,a){this.gameState=e,this.playerController=t,this.addMessage=s,this.getEnemyAtCallback=i,this.processTurnCallback=o,this.updateTutorialProgressCallback=r,this.onCombatCompletedCallback=a}attackMode=!1;toggleAttackMode(){this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"||(this.attackMode=!this.attackMode,this.attackMode?this.addMessage(p("attackModeOn")):this.addMessage(p("movementMode")),this.updateTutorialProgressCallback&&this.gameState.status==="tutorial"&&this.updateTutorialProgressCallback("combat"))}isAttackMode(){return this.attackMode}disableAttackMode(){this.attackMode=!1}handleAttack(e){this.playerController.getPosition();const t=this.playerController.move(e),s=this.getEnemyAtCallback(t);s?(this.handleCombat(s),this.processTurnCallback()):this.addMessage(p("noEnemyInThatDirection")),this.updateTutorialProgressCallback&&this.gameState.status==="tutorial"&&this.updateTutorialProgressCallback("combat"),this.attackMode=!1,this.addMessage(p("movementMode"))}handleCombat(e){if(!this.playerController.rollAttackHit()){this.addMessage(p("attackMissed",{enemy:E(e)}));return}const{damage:t,isCritical:s}=this.playerController.rollDamage();"health"in e&&"maxHealth"in e?this.applyDamageToEnemy(e,t,s):this.handleLegacyEnemyCombat(e,t,s)}applyDamageToEnemy(e,t,s){"health"in e&&typeof e.health=="number"&&(e.health-=t);const i=s?"criticalHit":"normalHit";this.addMessage(p(i,{enemy:E(e),damage:t.toString(),health:"health"in e&&typeof e.health=="number"?Math.max(0,e.health).toString():"0",maxHealth:"maxHealth"in e&&typeof e.maxHealth=="number"?e.maxHealth.toString():"100"})),"health"in e&&typeof e.health=="number"&&e.health<=0&&this.handleEnemyDefeat(e)}handleLegacyEnemyCombat(e,t,s){const i=s?"criticalHit":"normalHit";this.addMessage(p(i,{enemy:E(e),damage:t.toString(),health:"0",maxHealth:"100"})),this.handleEnemyDefeat(e)}handleEnemyDefeat(e){const t=this.gameState.currentDungeon.entities.findIndex(s=>s.id===e.id);if(t!==-1){this.gameState.currentDungeon.entities.splice(t,1),this.addMessage(p("enemyDefeated",{enemy:E(e)}));const s=this.calculateExperienceReward(e),i=this.playerController.addExperience(s);this.gameState.score+=10,this.addMessage(p("experienceGained",{exp:s.toString()})),this.gameState.player=this.playerController.getPlayer(),this.gameState.currentDungeon.player=this.gameState.player,i&&this.addMessage(p("levelUp",{level:this.gameState.player.level.toString()})),this.onCombatCompletedCallback&&this.onCombatCompletedCallback()}}calculateExperienceReward(e){const s={G:25,R:20,S:22,O:40,T:45,W:50,D:100,L:90,M:85}[e.char]||20,i="maxHealth"in e?Math.floor(e.maxHealth/10):0;return s+i}getCombatStats(){const e=this.playerController.getPlayer();return{attackMode:this.attackMode,playerLevel:e.level,playerHealth:e.health,playerMaxHealth:e.maxHealth}}canEngageCombat(){return this.playerController.getPlayer().health>0&&(this.gameState.status==="playing"||this.gameState.status==="tutorial")}getPlayerDamageCapability(){const e=this.playerController.getPlayer(),t=e.equipment.mainHand,s=t?t.damage:5,i=t?t.accuracy:70;return{minDamage:Math.max(1,s-2),maxDamage:s+e.level,accuracy:i,criticalChance:10+Math.floor(e.level/2)}}evaluateEnemyThreat(e){const t=this.playerController.getPlayer().level;return["D","L","M"].includes(e.char)?t<5?"extreme":"high":["O","T","W"].includes(e.char)?t<3?"high":"medium":t<2?"medium":"low"}}class ge{constructor(e,t,s){this.gameState=e,this.playerController=t,this.addMessage=s}equipItemFromInventory(e){if(console.log("=== equipItemFromInventory START ==="),console.log("Item to equip:",e),console.log("Item type:",e?.itemType),e.itemType==="weapon"){console.log("Processing weapon equipment...");const t=this.equipWeapon(e);return console.log("Weapon equipment result:",t),t}else if(e.itemType==="armor"){console.log("Processing armor equipment...");const t=this.equipArmor(e);return console.log("Armor equipment result:",t),t}return console.log("Item type not recognized as equipment"),console.log("=== equipItemFromInventory END ==="),!1}equipWeapon(e){return this.playerController.equipWeapon(e)?(this.addMessage(p("weaponEquipped",{weapon:m(e)})),this.syncPlayerData(),!0):(this.addMessage(p("cannotEquipWeapon")),!1)}equipArmor(e){return this.playerController.equipArmor(e)?(this.addMessage(p("armorEquipped",{armor:m(e)})),this.syncPlayerData(),!0):(this.addMessage(p("cannotEquipArmor")),!1)}removeEquipment(e){e==="weapon"?this.removeWeapon():e==="armor"&&this.removeArmor(),this.syncPlayerData()}removeWeapon(){console.log("=== REMOVE WEAPON START ===");const e=this.playerController.getPlayer();console.log("Player equipment before unequip:",e.equipment);const t=this.playerController.unequipWeapon();if(console.log("Weapon returned from unequipWeapon():",t),t){console.log("=== REMOVING WEAPON ==="),console.log("Weapon to be returned to inventory:",t),console.log("Player equipment after unequip:",e.equipment),console.log("MainHand slot cleared:",!e.equipment.mainHand);const s=this.playerController.addItem(t);console.log("Add item success:",s),s||console.error("Failed to add weapon back to inventory - inventory might be full"),this.addMessage(p("weaponUnequipped",{weapon:m(t)})),this.syncPlayerData(),console.log("Player data synced after weapon removal")}else console.log("No weapon to remove");console.log("=== REMOVE WEAPON END ===")}removeArmor(){console.log("=== REMOVE ARMOR START ===");const e=this.playerController.getPlayer();if(console.log("Player equipment before armor unequip:",e.equipment),console.log("Head armor exists:",!!e.equipment.head),e.equipment.head){const t=this.playerController.unequipArmor("head");if(console.log("Armor returned from unequipArmor():",t),t){console.log("=== REMOVING ARMOR ==="),console.log("Armor to be returned to inventory:",t),console.log("Player equipment after armor unequip:",e.equipment),console.log("Head slot cleared:",!e.equipment.head);const s=this.playerController.addItem(t);console.log("Add item success:",s),s||console.error("Failed to add armor back to inventory - inventory might be full"),this.addMessage(p("armorUnequipped",{armor:m(t)})),this.syncPlayerData(),console.log("Player data synced after armor removal")}}else console.log("No head armor to remove");console.log("=== REMOVE ARMOR END ===")}getCurrentEquipmentDisplay(){const t=this.playerController.getPlayer().equipment,s=[];if(t.mainHand){const a=t.mainHand,c=m(a);s.push(`${n("rightHand")}: ${a.char} ${c}`);const u=n("attackPowerEffect").replace("{{damage}}",String(a.damage)).replace("{{accuracy}}",String(a.accuracy));s.push(`      ${n("effectLabel")}: ${u}`)}else s.push(`${n("rightHand")}: ${n("noEquipment")}`);[{slot:"head",name:n("head")},{slot:"chest",name:n("chest")},{slot:"legs",name:n("legs")},{slot:"feet",name:n("feet")},{slot:"offHand",name:n("leftHand")}].forEach(a=>{const c=t[a.slot];if(c){const u=m(c);s.push(`${a.name}: ${c.char} ${u}`);const g=n("defenseEffect").replace("{{defense}}",String(c.defense));s.push(`      ${n("effectLabel")}: ${g}`)}else s.push(`${a.name}: ${n("noEquipment")}`)});const o=this.playerController.getTotalDefense(),r=n("totalDefense").replace("{{total}}",String(o));return s.push(r),s}canEquipItem(e){return!e||!e.itemType?!1:e.itemType==="weapon"?this.canEquipWeapon(e):e.itemType==="armor"?this.canEquipArmor(e):!1}canEquipWeapon(e){return e&&typeof e.damage=="number"&&typeof e.accuracy=="number"&&e.damage>0&&e.accuracy>0}canEquipArmor(e){return e&&typeof e.defense=="number"&&e.defense>0&&["head","chest","legs","feet","offHand"].includes(e.armorType)}getEquipmentStats(){const t=this.playerController.getPlayer().equipment,s=!!t.mainHand,i=t.mainHand?t.mainHand.damage:0,o=t.mainHand?t.mainHand.accuracy:0,r=this.playerController.getTotalDefense();let a=0;return t.head&&a++,t.chest&&a++,t.legs&&a++,t.feet&&a++,t.offHand&&a++,{weaponEquipped:s,weaponDamage:i,weaponAccuracy:o,totalDefense:r,armorPieces:a}}getEquipmentEffects(){const t=this.playerController.getPlayer().equipment;let s=0,i=0;const o=[];return t.mainHand&&(s+=t.mainHand.damage,t.mainHand.accuracy>90&&o.push("高精度")),[t.head,t.chest,t.legs,t.feet,t.offHand].filter(r=>r).forEach(r=>{r&&(i+=r.defense,r.defense>=10&&o.push("重装甲"))}),{attackBonus:s,defenseBonus:i,specialEffects:o}}syncPlayerData(){this.gameState.player=this.playerController.getPlayer(),this.gameState.currentDungeon.player=this.gameState.player}canUpgradeEquipment(e,t){return!e||!t?!0:e.itemType==="weapon"&&t.itemType==="weapon"?e.damage>t.damage:e.itemType==="armor"&&t.itemType==="armor"?e.defense>t.defense:!1}getEquipmentRecommendation(e){if(!this.canEquipItem(e))return null;const t=this.playerController.getPlayer();if(e.itemType==="weapon"){const s=t.equipment.mainHand;if(s){if(this.canUpgradeEquipment(e,s))return"武器をアップグレードすることを推奨します"}else return"武器を装備することを推奨します"}else if(e.itemType==="armor"){const s=t.equipment[e.armorType];if(s){if(this.canUpgradeEquipment(e,s))return"防具をアップグレードすることを推奨します"}else return"防具を装備することを推奨します"}return null}}class pe{constructor(e,t,s,i,o){this.gameState=e,this.playerController=t,this.addMessage=s,this.processTurnCallback=i,this.updateTutorialProgressCallback=o}handlePlayerMove(e){if(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")return;this.playerController.getPosition();const t=this.playerController.move(e);this.isValidMove(t)?this.executeMove(t):this.addMessage(p("cannotMoveThere"))}executeMove(e){this.playerController.confirmMove(e),this.gameState.player.position=e,console.log("MovementManager.executeMove:",{newPosition:e,gameStatus:this.gameState.status}),k.updateFieldOfView(this.gameState.currentDungeon,e),this.gameState.status==="tutorial"&&(console.log("Calling updateTutorialProgressCallback..."),this.updateTutorialProgressCallback("movement")),this.processTurnCallback()}isValidMove(e){const t=this.gameState.currentDungeon;return!f(e,t.dimensions)||t.tiles[e.y][e.x].blocking?!1:!t.entities.find(o=>o.position.x===e.x&&o.position.y===e.y&&o.blocking&&o.type!=="player"&&o.type!=="enemy")}getEnemyAt(e){return this.gameState.currentDungeon.entities.find(t=>t.position.x===e.x&&t.position.y===e.y&&t.type==="enemy")}getItemAt(e){return this.gameState.currentDungeon.entities.find(t=>t.position.x===e.x&&t.position.y===e.y&&t.type==="item")}getEntityAt(e,t){return this.gameState.currentDungeon.entities.find(s=>s.position.x===e.x&&s.position.y===e.y&&(t?s.type===t:!0))}getPlayerPosition(){return this.playerController.getPosition()}calculateNextPosition(e){return this.playerController.move(e)}evaluateMovementRisk(e){const t=this.gameState.currentDungeon,s=this.getNearbyEnemies(e,1);if(s.length>=3)return"danger";if(s.length>=1)return"caution";const i=t.tiles[e.y]?.[e.x];return i&&!i.explored?"caution":"safe"}getNearbyEnemies(e,t=1){const s=[];for(let i=-t;i<=t;i++)for(let o=-t;o<=t;o++){if(o===0&&i===0)continue;const r={x:e.x+o,y:e.y+i},a=this.getEnemyAt(r);a&&s.push(a)}return s}suggestMovement(e){const t=this.getPlayerPosition(),s=[],i=e.x-t.x,o=e.y-t.y;return i>0?s.push("east"):i<0&&s.push("west"),o>0?s.push("south"):o<0&&s.push("north"),s}getValidDirections(){return this.getPlayerPosition(),["north","south","east","west"].filter(t=>{const s=this.calculateNextPosition(t);return this.isValidMove(s)})}getMovementStats(){const e=this.getPlayerPosition(),t=this.getValidDirections(),s=this.getNearbyEnemies(e),i=this.getNearbyItems(e),o=this.evaluateMovementRisk(e);return{currentPosition:e,validDirections:t,nearbyEnemies:s.length,nearbyItems:i.length,movementRisk:o}}getNearbyItems(e,t=1){const s=[];for(let i=-t;i<=t;i++)for(let o=-t;o<=t;o++){const r={x:e.x+o,y:e.y+i},a=this.getItemAt(r);a&&s.push(a)}return s}preventWallCollision(e){const t=this.calculateNextPosition(e),s=this.gameState.currentDungeon;return f(t,s.dimensions)?!s.tiles[t.y][t.x].blocking:!1}forceMove(e){this.playerController.setPosition(e),this.gameState.player.position=e,k.updateFieldOfView(this.gameState.currentDungeon,e)}}class de{constructor(e,t,s,i,o,r,a,c,u){this.gameState=e,this.playerController=t,this.dungeonManager=s,this.addMessage=i,this.processTurnCallback=o,this.getCombatAttackModeCallback=r,this.setCombatAttackModeCallback=a,this.updateTutorialProgressCallback=c,this.interactiveTutorialManager=u}handleInteract(){if(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")return;const e=this.gameState.player.position,t=this.dungeonManager.hasStairsAt(e);if(t){this.handleStairsInteraction(t);return}this.handleItemPickup(e)}handleStairsInteraction(e){const t=this.dungeonManager.getCurrentFloor();let s;if(e==="down")s=t+1,this.addMessage(p("descendingToFloor",{floor:s.toString()}));else{if(s=t-1,s<1){this.addMessage(p("cannotGoUp"));return}this.addMessage(p("returningToFloor",{floor:s.toString()}))}this.moveToFloor(s)}moveToFloor(e){const t=this.getCombatAttackModeCallback();this.dungeonManager.saveDungeonState(this.gameState.currentDungeon);const s=this.playerController.getPlayer(),i=this.dungeonManager.moveToFloor(e,s);this.updateGameStateForNewFloor(i,s.position),t&&this.setCombatAttackModeCallback(),k.updateFieldOfView(i,s.position),this.addMessage(p("arrivedAtFloor",{floor:e.toString()}))}updateGameStateForNewFloor(e,t){this.gameState.currentDungeon=e,this.gameState.dungeonData=this.dungeonManager.getDungeonData(),this.gameState.player.position=t,this.gameState.currentDungeon.player=this.gameState.player,this.gameState.levelCleared=!1,this.playerController.setPosition(t)}handleItemPickup(e){const s=this.gameState.currentDungeon.entities.find(i=>i.position.x===e.x&&i.position.y===e.y&&i.type==="item");s?this.pickupItem(s):this.addMessage(p("cannotInteract"))}pickupItem(e){if(this.playerController.addItem(e)){if(this.gameState.status==="tutorial"&&this.interactiveTutorialManager){const t=this.interactiveTutorialManager.getTutorialItemPickupMessage(e.itemType||e.name||"unknown");t?this.addMessage(t):this.addMessage(p("pickedUpItemWithName",{char:e.char,item:m(e)}))}else this.addMessage(p("pickedUpItemWithName",{char:e.char,item:m(e)}));this.removeItemFromDungeon(e),this.gameState.status==="tutorial"&&this.updateTutorialProgressCallback&&this.updateTutorialProgressCallback("pickup"),this.processTurnCallback()}else this.addMessage(p("inventoryFull"))}removeItemFromDungeon(e){const t=this.gameState.currentDungeon,s=t.entities.findIndex(i=>i.id===e.id);s!==-1&&t.entities.splice(s,1)}getStairsAtPosition(e){return this.dungeonManager.hasStairsAt(e)}getItemAtPosition(e){return this.gameState.currentDungeon.entities.find(i=>i.position.x===e.x&&i.position.y===e.y&&i.type==="item")||null}getCurrentFloorInfo(){const e=this.dungeonManager.getCurrentFloor(),t=this.gameState.currentDungeon;let s=!1,i=!1,o=0,r=0;return t.entities.forEach(a=>{a.type==="item"&&o++,a.type==="enemy"&&r++}),s=e>1,i=!0,{currentFloor:e,hasUpStairs:s,hasDownStairs:i,itemsOnFloor:o,enemiesOnFloor:r}}checkFloorCompletion(){return this.gameState.currentDungeon.entities.filter(s=>s.type==="enemy").length===0}completeFloor(){this.checkFloorCompletion()&&(this.gameState.levelCleared=!0,this.addMessage(p("levelCleared")),this.gameState.score+=50,this.addMessage(p("floorBonus")))}emergencyExit(){this.moveToFloor(1),this.addMessage(p("emergencyExit"))}getFloorStats(){const e=this.dungeonManager.getCurrentFloor(),t=this.dungeonManager.getDungeonData();return{floorsVisited:Object.keys(t.floors).length,currentFloor:e,totalItems:0,totalEnemies:0,floorsCleared:0}}shouldPickupItem(e){return this.playerController.getPlayer().inventory.length>=10?{shouldPickup:!1,reason:"インベントリが満杯です"}:e.itemType==="consumable"?{shouldPickup:!0,reason:"消耗品は常に有用です"}:e.itemType==="weapon"||e.itemType==="armor"?{shouldPickup:!0,reason:"装備品はアップグレードの可能性があります"}:{shouldPickup:!0,reason:"アイテムを取得することを推奨します"}}getInteractableAtPosition(e){const t=this.getStairsAtPosition(e);if(t)return{type:"stairs",details:{direction:t}};const s=this.getItemAtPosition(e);return s?{type:"item",details:{item:s}}:{type:"none",details:null}}}class M{static SAVE_KEY="terminal-descent-save";static SAVE_VERSION="1.0.0";save(e){try{const t=this.createSaveData(e),s=JSON.stringify(t);return localStorage.setItem(M.SAVE_KEY,s),{success:!0,message:"ゲームを保存しました"}}catch(t){return{success:!1,message:"セーブに失敗しました",error:t instanceof Error?t.message:"Unknown error"}}}load(){try{const e=localStorage.getItem(M.SAVE_KEY);if(!e)return null;const t=JSON.parse(e);return this.isValidSaveData(t)?t:(console.warn("Invalid save data structure detected"),null)}catch(e){return console.error("Failed to load save data:",e),null}}hasSave(){return localStorage.getItem(M.SAVE_KEY)!==null}deleteSave(){try{return localStorage.removeItem(M.SAVE_KEY),{success:!0,message:"セーブデータを削除しました"}}catch(e){return{success:!1,message:"セーブデータの削除に失敗しました",error:e instanceof Error?e.message:"Unknown error"}}}createSaveData(e){return{version:M.SAVE_VERSION,timestamp:Date.now(),player:{position:{...e.player.position},hp:e.player.health,maxHp:e.player.maxHealth,energy:e.player.energy,maxEnergy:e.player.maxEnergy,level:e.player.level,exp:e.player.experience,inventory:[...e.player.inventory],equipment:{...e.player.equipment}},dungeon:{currentFloor:e.dungeonData.currentFloor,seed:0,exploredTiles:[]},gameStats:{turnCount:e.turn,score:e.score,enemiesDefeated:0},metadata:{playTime:0,lastSaveLocation:`floor_${e.dungeonData.currentFloor}_${e.player.position.x}_${e.player.position.y}`}}}isValidSaveData(e){return e&&typeof e.version=="string"&&typeof e.timestamp=="number"&&e.player&&typeof e.player.hp=="number"&&typeof e.player.level=="number"&&e.dungeon&&typeof e.dungeon.currentFloor=="number"&&e.gameStats&&typeof e.gameStats.turnCount=="number"}}class me{canvas;ctx;config;camera;renderedTexts=[];constructor(e,t){this.canvas=e;const s=e.getContext("2d");if(!s)throw new Error("Failed to get 2D rendering context");this.ctx=s,this.config=t,this.camera={position:{x:0,y:0},viewport:t.viewport,target:{x:0,y:0}},this.setupCanvas()}trackableFillText(e,t,s){this.renderedTexts.push(e),this.ctx.fillText(e,t,s)}getRenderedTexts(){return[...this.renderedTexts]}clearRenderedTexts(){this.renderedTexts=[]}setupCanvas(){this.canvas.width=this.config.viewport.width,this.canvas.height=this.config.viewport.height,this.ctx.imageSmoothingEnabled=!1,this.ctx.font=`${this.config.fontSize}px ${this.config.fontFamily}`,this.ctx.textAlign="center",this.ctx.textBaseline="middle"}clear(){this.ctx.fillStyle=this.config.colors.background,this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)}updateCamera(e){this.camera.target=e;const t=Math.floor(this.config.viewport.width/this.config.tileSize),s=Math.floor(this.config.viewport.height/this.config.tileSize);this.camera.position={x:e.x-Math.floor(t/2),y:e.y-Math.floor(s/2)}}worldToScreen(e){return{x:(e.x-this.camera.position.x)*this.config.tileSize,y:(e.y-this.camera.position.y)*this.config.tileSize}}isVisible(e){const t=this.worldToScreen(e);return t.x>=-this.config.tileSize&&t.x<this.config.viewport.width&&t.y>=-this.config.tileSize&&t.y<this.config.viewport.height}renderCharacter(e,t,s,i){i&&(this.ctx.fillStyle=i,this.ctx.fillRect(t.x,t.y,this.config.tileSize,this.config.tileSize)),this.ctx.fillStyle=s,this.trackableFillText(e,t.x+this.config.tileSize/2,t.y+this.config.tileSize/2)}renderTile(e){if(!this.isVisible(e.position))return;const t=this.worldToScreen(e.position);if(!e.explored)return;const s=e.visible?e.color:this.config.colors.explored,i=e.visible?e.backgroundColor:void 0;this.renderCharacter(e.char,t,s,i)}renderEntity(e){if(!e.visible||!this.isVisible(e.position))return;const t=this.worldToScreen(e.position);this.renderCharacter(e.char,t,e.color,e.backgroundColor)}render(e){if(this.clear(),this.clearRenderedTexts(),this.ctx.filter="none",e.status==="welcome"){this.renderWelcomeScreen(e);return}const t=e.currentDungeon;this.updateCamera(t.player.position);for(let s=0;s<t.dimensions.height;s++)for(let i=0;i<t.dimensions.width;i++){const o=t.tiles[s][i];o&&this.renderTile(o)}e.status==="tutorial"&&this.renderTutorialHighlights(e),t.entities.filter(s=>s.type!=="player").forEach(s=>this.renderEntity(s)),this.renderEntity(t.player),this.renderUI(e),e.overlay.isVisible&&this.renderOverlay(e),this.updateTestElements(e)}renderUI(e){const t=e.player,s=10,i=20;this.ctx.save(),this.ctx.font=`14px ${this.config.fontFamily}`,this.ctx.textAlign="left",this.ctx.fillStyle=this.config.colors.text;const o=[`${n("level")}: ${t.level}`,`${n("health")}: ${t.health}/${t.maxHealth}`,`${n("energy")}: ${t.energy}/${t.maxEnergy}`,`${n("accessLevel")}: ${t.accessLevel}`,`${n("turn")}: ${e.turn}`];o.forEach((u,g)=>{this.ctx.fillText(u,s,s+g*i)}),e.status==="tutorial"&&this.renderTutorialInfo(e,s,s+o.length*i+20);const r=$(t),a=[`${n("attackPowerLabel")}: ${r.attackPower}`,`${n("defenseLabel")}: ${r.totalDefense}`,`${n("experienceLabel")}: ${t.experience}/${t.experienceToNext}`],c=this.canvas.width-200;if(a.forEach((u,g)=>{this.ctx.fillText(u,c,s+g*i)}),e.messages.length>0){const u=Math.floor(this.canvas.height*.3/i),g=e.messages.slice(-u);g.forEach((h,d)=>{const y=this.canvas.height-s-(g.length-d)*i,D=Y(h);this.ctx.fillText(D,s,y)})}this.ctx.restore()}getCameraPosition(){return{...this.camera.position}}screenToWorld(e){return{x:Math.floor(e.x/this.config.tileSize)+this.camera.position.x,y:Math.floor(e.y/this.config.tileSize)+this.camera.position.y}}renderOverlay(e){switch(this.ctx.save(),this.ctx.fillStyle="rgba(0, 0, 0, 0.7)",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),e.overlay.type){case"inventory":this.renderInventoryOverlay(e);break;case"character":this.renderStatusOverlay(e);break;case"takeoff":this.renderTakeoffOverlay(e);break;case"equipment":this.renderEquipmentOverlay(e);break;case"pauseMenu":this.renderPauseMenuOverlay(e);break}this.ctx.restore()}renderInventoryOverlay(e){const s=e.player.inventory,i=400,o=Math.min(500,s.length*30+100),r=(this.canvas.width-i)/2,a=(this.canvas.height-o)/2;this.ctx.fillStyle="#1a1a1a",this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.fillRect(r,a,i,o),this.ctx.strokeRect(r,a,i,o),this.ctx.font="16px Courier New, monospace",this.ctx.textAlign="left",this.ctx.fillStyle="#00ff00",this.trackableFillText(n("inventoryHeader"),r+20,a+30),this.ctx.font="12px Courier New, monospace",this.ctx.fillStyle="#888888",this.ctx.fillText(n("closeInstruction"),r+20,a+50),this.ctx.font="14px Courier New, monospace";const c=a+80;s.length===0?(this.ctx.fillStyle="#666666",this.ctx.fillText(n("emptyInventoryMessage"),r+20,c)):s.forEach((u,g)=>{const h=c+g*25;e.overlay.selectedIndex===g&&(this.ctx.fillStyle="rgba(0, 255, 0, 0.2)",this.ctx.fillRect(r+10,h-15,i-20,20)),this.ctx.fillStyle="#ffff00",this.ctx.fillText(`${g+1}.`,r+20,h),this.ctx.fillStyle=u.color,this.ctx.fillText(u.char,r+50,h),this.ctx.fillStyle="#00ff00",this.ctx.fillText(`${u.name} x${u.quantity}`,r+70,h),this.ctx.font="10px Courier New, monospace",this.ctx.fillStyle="#888888",this.ctx.fillText(u.description,r+70,h+12),this.ctx.font="14px Courier New, monospace"})}renderStatusOverlay(e){const t=e.player,s=400,i=500,o=(this.canvas.width-s)/2,r=(this.canvas.height-i)/2;this.ctx.fillStyle="#1a1a1a",this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.fillRect(o,r,s,i),this.ctx.strokeRect(o,r,s,i),this.ctx.font="16px Courier New, monospace",this.ctx.textAlign="left",this.ctx.fillStyle="#00ff00",this.trackableFillText(n("statusHeader"),o+20,r+30),this.ctx.font="12px Courier New, monospace",this.ctx.fillStyle="#888888",this.ctx.fillText(n("statusCloseInstruction"),o+20,r+50),this.ctx.font="14px Courier New, monospace",this.ctx.fillStyle="#00ff00";const a=[{label:n("level"),value:`${t.level}`,color:"#ffff00"},{label:"HP",value:`${t.health}/${t.maxHealth}`,color:t.health<t.maxHealth*.3?"#ff4444":"#00ff00"},{label:n("energy"),value:`${t.energy}/${t.maxEnergy}`,color:t.energy<t.maxEnergy*.3?"#ffaa00":"#00ff00"},{label:"EXP",value:`${t.experience}/${t.experienceToNext}`,color:"#88ff88"},{label:n("accessLevel"),value:`${t.accessLevel}`,color:"#00ffff"},{label:n("turn"),value:`${e.turn}`,color:"#888888"},{label:"SCORE",value:`${e.score}`,color:"#ffff00"}],c=r+80;a.forEach((u,g)=>{const h=c+g*25;this.ctx.fillStyle="#00ff00",this.trackableFillText(`${u.label}:`,o+20,h),this.ctx.fillStyle=u.color,this.trackableFillText(u.value,o+150,h)}),this.ctx.font="16px Courier New, monospace",this.ctx.fillStyle="#00ff00",this.trackableFillText(n("equipmentHeader"),o+20,r+260),this.renderEquipmentDetails(t,o+20,r+285)}renderEquipmentDetails(e,t,s){this.ctx.font="12px Courier New, monospace";const i=K(e),o=[{key:"weapon",label:n("weaponSlot")},{key:"head",label:n("headSlot")},{key:"chest",label:n("chestSlot")},{key:"legs",label:n("legsSlot")},{key:"feet",label:n("feetSlot")},{key:"shield",label:n("shieldSlot")}];let r=s;o.forEach(c=>{const u=i[c.key];this.ctx.fillStyle="#00ff00",this.trackableFillText(`${c.label}:`,t,r),this.ctx.fillStyle=u!==n("noItem")?"#ffff00":"#666666",this.trackableFillText(u,t+60,r),r+=15}),r+=10,this.ctx.fillStyle="#00ff00",this.trackableFillText(n("equipmentStatsHeader"),t,r),r+=20;const a=$(e);this.ctx.fillStyle="#88ff88",this.trackableFillText(`${n("totalDefenseLabel")}: ${a.totalDefense}`,t,r),r+=15,this.ctx.fillStyle="#ff8888",this.trackableFillText(`${n("attackPowerLabel")}: ${a.attackPower}`,t,r)}renderTakeoffOverlay(e){const t=e.player,s=["mainHand","head","chest","legs","feet","offHand"],i=[];if(s.forEach(h=>{const d=t.equipment[h];d&&i.push({slot:h,item:d,displayName:m(d)})}),i.length===0)return;const o=400,r=Math.min(400,i.length*30+150),a=(this.canvas.width-o)/2,c=(this.canvas.height-r)/2;this.ctx.fillStyle="#1a1a1a",this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.fillRect(a,c,o,r),this.ctx.strokeRect(a,c,o,r),this.ctx.font="16px Courier New, monospace",this.ctx.textAlign="left",this.ctx.fillStyle="#00ff00",this.ctx.fillText(n("takeoffHeader"),a+20,c+30),this.ctx.font="12px Courier New, monospace",this.ctx.fillStyle="#888888",this.ctx.fillText(n("takeoffInstruction"),a+20,c+50),this.ctx.font="14px Courier New, monospace";const u=e.overlay.selectedIndex||0;i.forEach((h,d)=>{const y=c+80+d*25,D=d===u;D&&(this.ctx.fillStyle="#333333",this.ctx.fillRect(a+15,y-12,o-30,20)),this.ctx.fillStyle="#00ff00";const T=this.getSlotDisplayName(h.slot);this.ctx.fillText(`${T}:`,a+20,y),this.ctx.fillStyle=D?"#ffff00":"#ffffff";const q=h.item.char||"?";this.ctx.fillText(`${q} ${h.displayName}`,a+100,y)}),this.ctx.font="12px Courier New, monospace",this.ctx.fillStyle="#888888";const g=c+r-30;this.ctx.fillText(n("takeoffControls"),a+20,g)}renderEquipmentOverlay(e){const t=e.player,s=[{slot:"mainHand",label:"武器",item:t.equipment.mainHand},{slot:"head",label:"頭",item:t.equipment.head},{slot:"chest",label:"胴",item:t.equipment.chest},{slot:"legs",label:"脚",item:t.equipment.legs},{slot:"feet",label:"足",item:t.equipment.feet},{slot:"offHand",label:"盾",item:t.equipment.offHand}],i=600,o=380,r=(this.canvas.width-i)/2,a=(this.canvas.height-o)/2;this.ctx.fillStyle="#1a1a1a",this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.fillRect(r,a,i,o),this.ctx.strokeRect(r,a,i,o),this.ctx.save(),this.ctx.font="bold 20px Courier New, monospace",this.ctx.textAlign="center",this.ctx.fillStyle="#00ff00";const c="装備一覧",u=r+i/2;this.trackableFillText(c,u,a+35),this.ctx.restore(),this.ctx.font="16px Courier New, monospace";let g=a+85;s.forEach(({label:D,item:T})=>{if(this.ctx.fillStyle="#888888",this.trackableFillText(`${D}:`,r+25,g),T){this.ctx.fillStyle="#ffffff";const q=T.char||"?",L=m(T),B=`${q} ${L}`;this.trackableFillText(B,r+90,g);const H=g+18;"damage"in T?(this.ctx.fillStyle="#ff8888",this.trackableFillText(`  攻撃力: ${T.damage}`,r+110,H)):"defense"in T&&(this.ctx.fillStyle="#8888ff",this.trackableFillText(`  防御力: ${T.defense}`,r+110,H)),g+=38}else this.ctx.fillStyle="#666666",this.trackableFillText("なし",r+90,g),g+=28}),this.ctx.save(),this.ctx.font="12px Courier New, monospace",this.ctx.textAlign="center",this.ctx.fillStyle="#888888";const h="ESC: 閉じる, T: 装備を外す",d=r+i/2,y=a+o-20;this.trackableFillText(h,d,y),this.ctx.restore()}renderPauseMenuOverlay(e){this.applyGlassEffect();const t=300,s=250,i=(this.canvas.width-t)/2,o=(this.canvas.height-s)/2;this.ctx.fillStyle="#1a1a1a",this.ctx.fillRect(i,o,t,s),this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.strokeRect(i,o,t,s),this.ctx.font="bold 18px Courier New, monospace",this.ctx.fillStyle="#00ff00",this.ctx.textAlign="center",this.ctx.fillText(n("pauseMenuTitle"),i+t/2,o+40);const r=[{key:"continueGame",index:0},{key:"saveGame",index:1},{key:"loadGame",index:2},{key:"languageSwitch",index:3},{key:"returnToTitle",index:4}],a=o+80,c=30;this.ctx.font="14px Courier New, monospace",this.ctx.textAlign="left",r.forEach((g,h)=>{const d=a+h*c,y=e.overlay.selectedIndex===h;y&&(this.ctx.fillStyle="#003300",this.ctx.fillRect(i+10,d-18,t-20,22),this.ctx.fillStyle="#00ff00",this.ctx.fillText(">",i+20,d)),this.ctx.fillStyle=y?"#ffffff":"#cccccc",this.ctx.fillText(n(g.key),i+40,d)}),this.ctx.font="12px Courier New, monospace",this.ctx.fillStyle="#888888",this.ctx.textAlign="center";const u=o+s-20;this.ctx.fillText("↑↓: Select  Enter: Confirm  ESC: Close",i+t/2,u)}getSlotDisplayName(e){return{mainHand:n("weaponSlot"),head:n("headSlot"),chest:n("chestSlot"),legs:n("legsSlot"),feet:n("feetSlot"),offHand:n("shieldSlot")}[e]||e}resize(e){this.config.viewport=e,this.canvas.width=e.width,this.canvas.height=e.height,this.setupCanvas()}renderWelcomeScreen(e){const t=this.canvas.width/2,s=this.canvas.height/2;if(e.welcome.showPrologue){this.renderPrologue();return}this.ctx.fillStyle=this.config.colors.text,this.ctx.font=`${this.config.fontSize*2}px ${this.config.fontFamily}`,this.ctx.textAlign="center",this.ctx.fillText(n("welcomeTitle"),t,s-120),this.ctx.font=`${this.config.fontSize}px ${this.config.fontFamily}`,this.ctx.fillText(n("welcomeSubtitle"),t,s-50);const i=R("menuOptions");[{key:"start",text:i[0]},{key:"tutorial",text:i[1]},{key:"settings",text:i[2]}].forEach((r,a)=>{const c=s+a*30,u=e.welcome.selectedOption===r.key;if(this.ctx.fillStyle=u?this.config.colors.player:this.config.colors.text,u){const g=this.ctx.measureText(r.text).width,h=20;this.ctx.fillText(">",t-g/2-h,c),this.ctx.fillText("<",t+g/2+h,c)}this.ctx.fillText(r.text,t,c)}),this.ctx.fillStyle=this.config.colors.explored,this.ctx.fillText(n("menuInstructions"),t,s+120),e.welcome.selectedOption||(e.welcome.selectedOption="start"),this.updateTestElements(e)}renderPrologue(){const e=this.canvas.width/2,t=this.canvas.height/2;this.ctx.fillStyle=this.config.colors.text,this.ctx.font=`${this.config.fontSize}px ${this.config.fontFamily}`,this.ctx.textAlign="center",R("prologueLines").forEach((i,o)=>{this.ctx.fillText(i,e,t-100+o*25)})}renderTutorialHighlights(e){const t=e.interactiveTutorial;t&&t.isActive&&t.currentStep.targetPosition&&this.renderTargetHighlight(t.currentStep.targetPosition)}renderTutorialInfo(e,t,s){const i=e.interactiveTutorial;if(!i||!i.isActive)return;const o=20,r=[`チュートリアル: ${i.currentStep.title}`,i.currentStep.description,`ステップ: ${i.progress.currentStep}/${i.progress.totalSteps}`];this.ctx.fillStyle="#ffff00",this.ctx.font=`16px ${this.config.fontFamily}`,r.forEach((a,c)=>{this.ctx.fillText(a,t,s+c*o)})}renderTargetHighlight(e){const t=this.worldToScreen(e);this.ctx.fillStyle="rgba(0, 255, 0, 0.3)",this.ctx.fillRect(t.x,t.y,this.config.tileSize,this.config.tileSize),this.ctx.strokeStyle="#00ff00",this.ctx.lineWidth=2,this.ctx.strokeRect(t.x,t.y,this.config.tileSize,this.config.tileSize)}updateTestElements(e){try{const t=document.getElementById("test-game-status");t&&(t.textContent=e.status,t.setAttribute("data-game-status",e.status));const s=document.getElementById("test-tutorial-status");if(s){const c=e.tutorial.isActive?`active-${e.tutorial.currentStep}`:"inactive";s.textContent=c,s.setAttribute("data-tutorial-status",c)}const i=document.getElementById("test-start-button"),o=document.getElementById("test-tutorial-button"),r=document.getElementById("test-settings-button");i&&o&&r&&([i,o,r].forEach(c=>{c.removeAttribute("data-selected")}),e.welcome.selectedOption==="start"?i.setAttribute("data-selected","true"):e.welcome.selectedOption==="tutorial"?o.setAttribute("data-selected","true"):e.welcome.selectedOption==="settings"&&r.setAttribute("data-selected","true"));const a=document.getElementById("test-equipment-section");if(a){const c=e.overlay.type==="character"&&e.overlay.isVisible;if(a.setAttribute("data-visible",c.toString()),e.player?.equipment){const u=JSON.stringify({mainHand:e.player.equipment.mainHand?.nameKey||"none",head:e.player.equipment.head?.nameKey||"none",chest:e.player.equipment.chest?.nameKey||"none",legs:e.player.equipment.legs?.nameKey||"none",feet:e.player.equipment.feet?.nameKey||"none",offHand:e.player.equipment.offHand?.nameKey||"none"});a.setAttribute("data-equipment",u)}}}catch{console.debug("Test elements not found, skipping update")}}applyGlassEffect(){this.ctx.filter="blur(6px) brightness(0.6)";const e=this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height);this.ctx.putImageData(e,0,0),this.ctx.filter="none"}}class fe{listeners=new Map;logger;isDestroyed=!1;eventQueue=[];isProcessing=!1;maxQueueSize=1e3;constructor(e){this.logger=e,this.debugLog("TutorialEventBus initialized")}subscribe(e,t,s={}){if(this.isDestroyed){this.warnLog(`Cannot subscribe to ${e}: EventBus is destroyed`);return}const{once:i=!1,priority:o=0}=s;this.listeners.has(e)||this.listeners.set(e,[]);const r=this.listeners.get(e),a={handler:t,once:i,priority:o},c=r.findIndex(u=>u.priority<o);c===-1?r.push(a):r.splice(c,0,a),this.debugLog(`Subscribed to ${e}`,{handlerCount:r.length,once:i,priority:o})}unsubscribe(e,t){if(this.isDestroyed)return;const s=this.listeners.get(e);if(!s)return;const i=s.length,o=s.filter(r=>r.handler!==t);this.listeners.set(e,o),o.length!==i&&this.debugLog(`Unsubscribed from ${e}`,{remainingHandlers:o.length}),o.length===0&&this.listeners.delete(e)}publish(e){if(this.isDestroyed){this.warnLog(`Cannot publish ${e.type}: EventBus is destroyed`);return}if(this.eventQueue.length>=this.maxQueueSize){this.errorLog(`Event queue overflow, dropping event: ${e.type}`);return}this.eventQueue.push(e),this.isProcessing||this.processEventQueue()}once(e,t){this.subscribe(e,t,{once:!0})}getListeners(e){const t=this.listeners.get(e);return t?t.map(s=>s.handler):[]}clear(){const e=Array.from(this.listeners.values()).reduce((t,s)=>t+s.length,0);this.listeners.clear(),this.eventQueue.length=0,this.debugLog("Cleared all listeners",{totalListeners:e})}destroy(){this.isDestroyed||(this.isDestroyed=!0,this.clear(),this.logger=void 0,this.debugLog("TutorialEventBus destroyed"))}getStats(){const e=Array.from(this.listeners.keys()),t=Array.from(this.listeners.values()).reduce((s,i)=>s+i.length,0);return{eventTypes:e.length,totalHandlers:t,queueSize:this.eventQueue.length,isProcessing:this.isProcessing,isDestroyed:this.isDestroyed,maxQueueSize:this.maxQueueSize,eventTypeDetails:e.map(s=>({type:s,handlerCount:this.listeners.get(s)?.length||0}))}}async processEventQueue(){if(!(this.isProcessing||this.isDestroyed)){this.isProcessing=!0;try{for(;this.eventQueue.length>0&&!this.isDestroyed;){const e=this.eventQueue.shift();await this.processEvent(e)}}catch(e){this.errorLog("Error processing event queue",e)}finally{this.isProcessing=!1}}}async processEvent(e){const t=this.listeners.get(e.type);if(!t||t.length===0){this.debugLog(`No listeners for event: ${e.type}`);return}this.debugLog(`Processing event: ${e.type}`,{listenerCount:t.length,eventData:e});const s=[];for(const i of t)try{await this.executeHandler(i.handler,e),i.once&&s.push(i)}catch(o){this.errorLog(`Error in event handler for ${e.type}`,o)}if(s.length>0){const i=t.filter(o=>!s.includes(o));this.listeners.set(e.type,i),i.length===0&&this.listeners.delete(e.type)}}async executeHandler(e,t){const s=e(t);s&&typeof s.then=="function"&&await s}debugLog(e,t){this.logger&&this.logger.debug(`[EventBus] ${e}`,t)}warnLog(e,t){this.logger&&this.logger.warn(`[EventBus] ${e}`,t)}errorLog(e,t){this.logger&&this.logger.error(`[EventBus] ${e}`,t)}}function ye(l){return new fe(l)}function x(l,e,t,s){return{type:l,timestamp:Date.now(),source:e,data:t,stepId:s}}class _ extends Error{constructor(e,t){super(e),this.stateId=t,this.name="StateManagerError"}}class P{enter(e){e.logger.info(`Entering state: ${this.id}`);const t=x("step.started","StateManager",{stepId:this.id,stepName:this.name,stepIndex:this.getStepIndex(e),previousStepId:this.getPreviousStepId(e)},this.id);e.eventBus.publish(t)}canTransitionTo(e){return!0}exit(e){e.logger.info(`Exiting state: ${this.id}`);const s=e.services.resolve("state-manager")?.getStepState(this.id),i=s?Date.now()-(s.startTime||0):0,o=x("step.completed","StateManager",{stepId:this.id,stepName:this.name,stepIndex:this.getStepIndex(e),timeSpent:i,actionsPerformed:s?.actionsPerformed||0},this.id);e.eventBus.publish(o)}getStepIndex(e){return e.services.resolve("state-manager")?.getStepIndex(this.id)||0}getPreviousStepId(e){const t=e.services.resolve("state-manager"),s=this.getStepIndex(e);return s>0?t?.getStepIdByIndex(s-1):void 0}}class Se{type="state-manager";id="tutorial-state-manager";name="Tutorial State Manager";isInitialized=!0;currentState=null;states=new Map;stepStates=new Map;stateHistory=[];stepDefinitions=[];logger;constructor(e){this.logger=e,this.logger.debug("TutorialStateManager initialized")}setStepDefinitions(e){this.stepDefinitions=e,this.initializeStepStates(),this.logger.info(`Loaded ${e.length} step definitions`)}initializeStepStates(){this.stepStates.clear();for(const e of this.stepDefinitions){const t={step:e,status:"pending",actionsPerformed:0,hintsShown:0,errors:[]};this.stepStates.set(e.id,t)}}registerState(e){if(this.states.has(e.id))throw new _(`State ${e.id} is already registered`);this.states.set(e.id,e),this.logger.debug(`Registered state: ${e.id}`)}registerStates(e){for(const t of e)this.registerState(t)}transitionTo(e,t){if(!e){this.logger.error("Cannot transition to undefined stateId");return}const s=this.states.get(e);if(!s)throw new _(`State ${e} not found`,e);this.currentState&&(this.updateStepState(this.currentState.id,{status:"completed",endTime:Date.now()}),this.currentState.exit(t)),this.stateHistory.push(e),this.currentState=s,this.updateStepState(e,{status:"in_progress",startTime:Date.now()}),this.currentState.enter(t),this.logger.info(`Transitioned to state: ${e}`)}getCurrentState(){return this.currentState}getTutorialState(e){return this.states.get(e)}initialize(e){this.logger.debug("TutorialStateManager initialize() called")}getState(){return{totalStates:this.states.size,currentState:this.currentState?.id||null,availableStates:Array.from(this.states.keys()),stepStates:Object.fromEntries(Array.from(this.stepStates.entries()).map(([e,t])=>[e,{stepId:t.step.id,status:t.status,startTime:t.startTime,endTime:t.endTime,actionsPerformed:t.actionsPerformed,hintsShown:t.hintsShown}]))}}getRegisteredStateIds(){return Array.from(this.states.keys())}updateStepState(e,t){const s=this.stepStates.get(e);if(!s){this.logger.warn(`Step state not found: ${e}`);return}Object.assign(s,t),this.stepStates.set(e,s)}getStepState(e){return this.stepStates.get(e)}getAllStepStates(){return new Map(this.stepStates)}getStepIndex(e){return this.stepDefinitions.findIndex(t=>t.id===e)}getStepIdByIndex(e){return this.stepDefinitions[e]?.id}getNextStepId(e){const t=this.getStepIndex(e);return this.getStepIdByIndex(t+1)}getPreviousStepId(e){const t=this.getStepIndex(e);return this.getStepIdByIndex(t-1)}recordAction(e,t){const s=this.stepStates.get(e);if(s){const i={...s,actionsPerformed:s.actionsPerformed+1};this.stepStates.set(e,i),this.logger.debug(`Recorded action ${t} for step ${e}`)}}recordHint(e){const t=this.stepStates.get(e);if(t){const s={...t,hintsShown:t.hintsShown+1};this.stepStates.set(e,s),this.logger.debug(`Recorded hint for step ${e}`)}}recordError(e,t){const s=this.stepStates.get(e);s&&(s.errors.push(t),this.stepStates.set(e,s),this.logger.warn(`Recorded error for step ${e}: ${t}`))}getStateHistory(){return[...this.stateHistory]}getStats(){const e=Array.from(this.stepStates.values()).filter(o=>o.status==="completed").length,t=Array.from(this.stepStates.values()).reduce((o,r)=>o+r.actionsPerformed,0),s=Array.from(this.stepStates.values()).reduce((o,r)=>o+r.hintsShown,0),i=Array.from(this.stepStates.values()).reduce((o,r)=>o+r.errors.length,0);return{totalSteps:this.stepDefinitions.length,completedSteps:e,currentStepId:this.currentState?.id,totalActions:t,totalHints:s,totalErrors:i,stateHistory:this.stateHistory.length,registeredStates:this.states.size}}update(e){if(!this.currentState)return;const t=this.currentState.update?.(e);t&&t!==this.currentState&&(t.id?this.transitionTo(t.id,e):this.logger.error("Next state has undefined id:",t))}cleanup(){this.currentState&&this.logger.info(`Cleaning up current state: ${this.currentState.id}`),this.currentState=null,this.states.clear(),this.stepStates.clear(),this.stateHistory.length=0,this.stepDefinitions.length=0,this.logger.debug("TutorialStateManager cleaned up")}isReady(){return this.isInitialized&&this.stepDefinitions.length>0}markInitialized(){this.logger.info("TutorialStateManager marked as initialized")}}class ve{type="progress-tracker";id="tutorial-progress-tracker";name="Tutorial Progress Tracker";isInitialized=!0;progressData;logger;isAutoSaveEnabled=!0;autoSaveInterval=5e3;autoSaveTimer;constructor(e){this.logger=e,this.progressData=this.initializeProgressData(),this.logger.debug("TutorialProgressTracker initialized",{sessionId:this.progressData.sessionId})}initializeProgressData(){return{sessionId:this.generateSessionId(),startTime:Date.now(),lastUpdateTime:Date.now(),completedSteps:new Set,skippedSteps:new Set,stepProgress:new Map,globalMetrics:{totalTimeSpent:0,totalActionsPerformed:0,totalErrorsEncountered:0,totalHintsUsed:0,totalResets:0}}}generateSessionId(){return`tutorial_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}markCompleted(e,t="normal"){this.progressData.completedSteps.add(e),this.progressData.skippedSteps.delete(e);const s=this.getOrCreateStepData(e);s.status="completed",s.completionTime=Date.now(),s.completionMethod=t,s.firstAttemptTime&&(s.timeSpent=Date.now()-s.firstAttemptTime),this.updateLastModified(),this.logger.info(`Step marked completed: ${e}`,{completionMethod:t}),this.isAutoSaveEnabled&&this.scheduleAutoSave()}markSkipped(e){this.progressData.skippedSteps.add(e),this.progressData.completedSteps.delete(e);const t=this.getOrCreateStepData(e);t.status="skipped",t.completionMethod="skip",t.completionTime=Date.now(),this.updateLastModified(),this.logger.info(`Step marked skipped: ${e}`),this.isAutoSaveEnabled&&this.scheduleAutoSave()}isCompleted(e){return this.progressData.completedSteps.has(e)}isSkipped(e){return this.progressData.skippedSteps.has(e)}setCurrentStep(e){this.progressData.currentStepId=e;const t=this.getOrCreateStepData(e);t.status==="pending"&&(t.status="in_progress",t.firstAttemptTime=Date.now()),t.lastAttemptTime=Date.now(),t.attempts++,this.updateLastModified(),this.logger.debug(`Current step set to: ${e}`)}recordAction(e,t){const s=this.getOrCreateStepData(e);s.actionsPerformed++,this.progressData.globalMetrics.totalActionsPerformed++,this.updateLastModified(),this.logger.debug(`Action recorded: ${t} for step ${e}`)}recordHint(e){const t=this.getOrCreateStepData(e);t.hintsUsed++,this.progressData.globalMetrics.totalHintsUsed++,this.updateLastModified(),this.logger.debug(`Hint recorded for step: ${e}`)}recordError(e,t,s){const i=this.getOrCreateStepData(e);i.errorsEncountered++,i.errorHistory.push({timestamp:Date.now(),error:t,context:s}),this.progressData.globalMetrics.totalErrorsEncountered++,this.updateLastModified(),this.logger.warn(`Error recorded for step ${e}: ${t}`,s)}getCompletionRate(){const e=this.getTotalStepsCount();if(e===0)return 0;const t=this.progressData.completedSteps.size;return Math.round(t/e*100)}getTotalStepsCount(){return this.progressData.stepProgress.size}getCompletedStepsCount(){return this.progressData.completedSteps.size}getMetrics(){const t=Date.now()-this.progressData.startTime,s=new Map;for(const[i,o]of this.progressData.stepProgress){const r={stepId:i,attempts:o.attempts,timeSpent:o.timeSpent,actionsPerformed:o.actionsPerformed,hintsUsed:o.hintsUsed,errorsEncountered:o.errorsEncountered,completionMethod:o.completionMethod};s.set(i,r)}return{sessionId:this.progressData.sessionId,startTime:this.progressData.startTime,currentStepIndex:this.getCurrentStepIndex(),totalSteps:this.getTotalStepsCount(),completedSteps:this.getCompletedStepsCount(),skippedSteps:this.progressData.skippedSteps.size,totalTimeSpent:t,totalActionsPerformed:this.progressData.globalMetrics.totalActionsPerformed,totalErrorsEncountered:this.progressData.globalMetrics.totalErrorsEncountered,stepMetrics:s}}getCurrentStepIndex(){return this.progressData.currentStepId?Array.from(this.progressData.stepProgress.keys()).indexOf(this.progressData.currentStepId):0}getStepMetrics(e){const t=this.progressData.stepProgress.get(e);if(t)return{stepId:e,attempts:t.attempts,timeSpent:t.timeSpent,actionsPerformed:t.actionsPerformed,hintsUsed:t.hintsUsed,errorsEncountered:t.errorsEncountered,completionMethod:t.completionMethod}}getCompletedSteps(){return Array.from(this.progressData.completedSteps)}getSkippedSteps(){return Array.from(this.progressData.skippedSteps)}reset(){this.progressData.globalMetrics.totalResets++;const e=this.initializeProgressData();e.globalMetrics.totalResets=this.progressData.globalMetrics.totalResets,this.progressData=e,this.logger.info("Progress reset",{sessionId:this.progressData.sessionId}),this.isAutoSaveEnabled&&this.scheduleAutoSave()}getOrCreateStepData(e){let t=this.progressData.stepProgress.get(e);return t||(t={stepId:e,status:"pending",attempts:0,timeSpent:0,actionsPerformed:0,hintsUsed:0,errorsEncountered:0,completionMethod:"normal",errorHistory:[]},this.progressData.stepProgress.set(e,t)),t}updateLastModified(){this.progressData.lastUpdateTime=Date.now()}scheduleAutoSave(){this.autoSaveTimer&&clearTimeout(this.autoSaveTimer),this.autoSaveTimer=setTimeout(()=>{this.save()},this.autoSaveInterval)}save(){try{const e=this.serializeProgressData();localStorage.setItem("tutorial_progress",e),this.logger.debug("Progress data saved")}catch(e){this.logger.error("Failed to save progress data",e)}}load(){try{const e=localStorage.getItem("tutorial_progress");if(e)return this.progressData=this.deserializeProgressData(e),this.logger.info("Progress data loaded",{sessionId:this.progressData.sessionId}),!0}catch(e){this.logger.error("Failed to load progress data",e)}return!1}serializeProgressData(){const e={...this.progressData,completedSteps:Array.from(this.progressData.completedSteps),skippedSteps:Array.from(this.progressData.skippedSteps),stepProgress:Array.from(this.progressData.stepProgress.entries())};return JSON.stringify(e)}deserializeProgressData(e){const t=JSON.parse(e);return{...t,completedSteps:new Set(t.completedSteps),skippedSteps:new Set(t.skippedSteps),stepProgress:new Map(t.stepProgress)}}getStatsSummary(){const e=this.getMetrics();return{sessionId:e.sessionId,completionRate:this.getCompletionRate(),totalTimeSpent:e.totalTimeSpent,averageTimePerStep:e.totalSteps>0?e.totalTimeSpent/e.totalSteps:0,totalActions:e.totalActionsPerformed,averageActionsPerStep:e.totalSteps>0?e.totalActionsPerformed/e.totalSteps:0,errorRate:e.totalActionsPerformed>0?e.totalErrorsEncountered/e.totalActionsPerformed:0,hintsUsageRate:e.totalSteps>0?this.progressData.globalMetrics.totalHintsUsed/e.totalSteps:0}}update(e){this.progressData.globalMetrics.totalTimeSpent=Date.now()-this.progressData.startTime,this.updateLastModified()}cleanup(){this.autoSaveTimer&&(clearTimeout(this.autoSaveTimer),this.autoSaveTimer=void 0),this.isAutoSaveEnabled&&this.save(),this.logger.debug("TutorialProgressTracker cleaned up")}initialize(e){this.logger.debug("TutorialProgressTracker initialize() called")}getState(){return{sessionId:this.progressData.sessionId,startTime:this.progressData.startTime,completedSteps:this.progressData.completedSteps.size,skippedSteps:this.progressData.skippedSteps.size,currentStepIndex:this.getCurrentStepIndex(),totalTimeSpent:this.progressData.globalMetrics.totalTimeSpent,totalActionsPerformed:this.progressData.globalMetrics.totalActionsPerformed,totalErrorsEncountered:this.progressData.globalMetrics.totalErrorsEncountered,totalHintsUsed:this.progressData.globalMetrics.totalHintsUsed,isAutoSaveEnabled:this.isAutoSaveEnabled,hasAutoSaveTimer:!!this.autoSaveTimer}}setAutoSave(e){this.isAutoSaveEnabled=e,this.logger.debug(`Auto-save ${e?"enabled":"disabled"}`)}}class xe{type="door-controller";id="tutorial-door-controller";name="Tutorial Door Controller";isInitialized=!0;doors=new Map;logger;gameStateRef;defaultDoorConfigs=[{position:{x:13,y:15},stepIndex:0,stepId:"movement",description:"移動→アイテム"},{position:{x:25,y:15},stepIndex:1,stepId:"item-pickup",description:"アイテム→装備"},{position:{x:37,y:15},stepIndex:2,stepId:"equipment",description:"装備→戦闘"},{position:{x:49,y:15},stepIndex:3,stepId:"combat",description:"戦闘→ステータス"}];constructor(e,t){this.logger=e,this.gameStateRef=t,this.initializeDefaultDoors(),this.logger.debug("TutorialDoorController initialized")}initialize(e){this.logger.debug("TutorialDoorController initialize() called")}getState(){return{totalDoors:this.doors.size,openDoorsCount:this.getOpenDoorsCount(),closedDoorsCount:this.getClosedDoorsCount(),doors:Array.from(this.doors.entries()).map(([e,t])=>({key:e,position:t.position,isOpen:t.isOpen,stepId:t.stepId,stepIndex:t.stepIndex}))}}initializeDefaultDoors(){for(const e of this.defaultDoorConfigs){const t=this.getDoorKey(e.position),s={position:e.position,isOpen:!1,stepId:e.stepId,stepIndex:e.stepIndex,requiredCondition:e.requiredCondition};this.doors.set(t,s)}this.logger.info(`Initialized ${this.doors.size} doors`)}addDoor(e){const t=this.getDoorKey(e.position);if(this.doors.has(t)){this.logger.warn(`Door already exists at position (${e.position.x}, ${e.position.y})`);return}const s={position:e.position,isOpen:!1,stepId:e.stepId,stepIndex:e.stepIndex,requiredCondition:e.requiredCondition};this.doors.set(t,s),this.logger.debug(`Added door at (${e.position.x}, ${e.position.y})`)}removeDoor(e){const t=this.getDoorKey(e),s=this.doors.delete(t);return s&&this.logger.debug(`Removed door at (${e.x}, ${e.y})`),s}openDoorByStepIndex(e,t){const s=this.findDoorByStepIndex(e);return s?this.openDoor(s.position,t,`step-${e}`):(this.logger.warn(`No door found for step index ${e}`),!1)}openDoorByStepId(e,t){const s=this.findDoorByStepId(e);return s?this.openDoor(s.position,t,e):(this.logger.warn(`No door found for step ID ${e}`),!1)}openDoor(e,t,s){const i=this.getDoorKey(e),o=this.doors.get(i);if(!o)return this.logger.warn(`Door not found at position (${e.x}, ${e.y})`),!1;if(o.isOpen)return this.logger.debug(`Door at (${e.x}, ${e.y}) is already open`),!0;if(!this.updateGameTile(e))return this.logger.error(`Failed to update game tile at (${e.x}, ${e.y})`),!1;o.isOpen=!0,o.openedAt=Date.now(),this.doors.set(i,o);const r=x("door.opened","DoorController",{position:e,stepId:o.stepId||"unknown",method:s||"automatic"},o.stepId);return t.eventBus.publish(r),this.logger.info(`Door opened at (${e.x}, ${e.y})`,{stepId:o.stepId,stepIndex:o.stepIndex,reason:s}),!0}openPlayerSurroundingDoors(e){if(!this.gameStateRef?.player?.position){this.logger.warn("Player position not available for surrounding door opening");return}const t=this.gameStateRef.player.position,s=this.gameStateRef.currentDungeon?.tiles;if(!s){this.logger.warn("Game tiles not available");return}this.logger.debug("Opening player surrounding doors",{playerPosition:t});const i=[];for(let o=1;o<=10;o++){const r={x:t.x+o,y:t.y};s[r.y]&&s[r.y][r.x]&&s[r.y][r.x].blocking&&i.push(r)}if(i.length>0){const o=i[0];this.openDoor(o,e,"player-surrounding")}else this.logger.debug("No blocked paths found in front of player")}getDoorState(e){const t=this.getDoorKey(e);return this.doors.get(t)}getAllDoorStates(){return Array.from(this.doors.values())}getOpenDoorsCount(){return Array.from(this.doors.values()).filter(e=>e.isOpen).length}getClosedDoorsCount(){return Array.from(this.doors.values()).filter(e=>!e.isOpen).length}closeAllDoors(e){let t=0;for(const[s,i]of this.doors.entries())i.isOpen&&(i.isOpen=!1,i.openedAt=void 0,this.updateGameTile(i.position,!0),t++);this.logger.info(`Closed ${t} doors`)}resetDoors(e){this.closeAllDoors(e),this.logger.info("All doors reset to closed state")}findDoorByStepIndex(e){return Array.from(this.doors.values()).find(t=>t.stepIndex===e)}findDoorByStepId(e){return Array.from(this.doors.values()).find(t=>t.stepId===e)}getDoorKey(e){return`${e.x},${e.y}`}updateGameTile(e,t=!1){if(!this.gameStateRef?.currentDungeon?.tiles)return this.logger.warn("Game tiles not available for update"),!1;const s=this.gameStateRef.currentDungeon.tiles;return!s[e.y]||!s[e.y][e.x]?(this.logger.warn(`Invalid tile position (${e.x}, ${e.y})`),!1):(t?s[e.y][e.x]={position:e,type:"wall",char:"+",color:"#8B4513",backgroundColor:"#000000",blocking:!0,explored:!1,visible:!1}:s[e.y][e.x]={position:e,type:"floor",char:".",color:"#666666",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1},!0)}getStats(){const e=Array.from(this.doors.values()),t=e.filter(i=>i.isOpen),s=e.filter(i=>!i.isOpen);return{totalDoors:e.length,openDoors:t.length,closedDoors:s.length,doorsByStep:this.groupDoorsByStep(),recentlyOpened:this.getRecentlyOpenedDoors(5e3)}}groupDoorsByStep(){const e=new Map;for(const t of this.doors.values())if(t.stepId){const s=e.get(t.stepId)||0;e.set(t.stepId,s+1)}return Object.fromEntries(e)}getRecentlyOpenedDoors(e){const t=Date.now()-e;return Array.from(this.doors.values()).filter(s=>s.isOpen&&s.openedAt&&s.openedAt>t)}update(e){}cleanup(){this.doors.clear(),this.gameStateRef=null,this.logger.debug("TutorialDoorController cleaned up")}setGameStateRef(e){this.gameStateRef=e,this.logger.debug("Game state reference updated")}}class Te{type="message-presenter";id="tutorial-message-presenter";name="Tutorial Message Presenter";isInitialized=!0;messages=new Map;displayQueue=[];currentMessage=null;shownHints=new Set;logger;addMessageCallback;isProcessing=!1;defaultDisplayDuration=5e3;defaultHintDelay=1e4;stepMessages=new Map([["movement",{instruction:"WASDキーまたは矢印キーでプレイヤーを移動させてください。",hint:"移動のコツ: 一歩ずつ確実に進みましょう。",success:"移動完了！次のエリアへ進めます。",error:"その方向には移動できません。別の方向を試してください。"}],["item-pickup",{instruction:"アイテムの上で Spaceキー を押してアイテムを拾ってください。",hint:"アイテムは黄色で表示されています。近づいてSpaceキーを押しましょう。",success:"アイテムを取得しました！インベントリに追加されました。",error:"アイテムが見つかりません。アイテムの上に立ってからSpaceキーを押してください。"}],["equipment",{instruction:"Eキーで装備画面を開き、拾ったアイテムを装備してください。",hint:"装備すると攻撃力や防御力が上がります。",success:"装備完了！ステータスが向上しました。",error:"装備に失敗しました。インベントリにアイテムがあるか確認してください。"}],["combat",{instruction:"敵に近づいて攻撃してください。",hint:"敵の隣に移動すると自動で攻撃が発動します。",success:"戦闘勝利！経験値を獲得しました。",error:"戦闘で苦戦しています。装備を確認するか、アイテムを使用してください。"}],["status",{instruction:"Cキーでステータス画面を開き、成長を確認してください。",hint:"レベルアップや装備効果でステータスが変化します。",success:"チュートリアル完了！お疲れ様でした。",error:"ステータス画面が開けません。Cキーを押してください。"}]]);constructor(e,t){this.logger=e,this.addMessageCallback=t,this.logger.debug("TutorialMessagePresenter initialized")}setMessageCallback(e){this.addMessageCallback=e,this.logger.debug("Message callback updated")}showStepInstruction(e,t,s){const i=this.stepMessages.get(e);if(!i||!i.instruction){this.logger.warn(`No instruction message found for step: ${e}`);return}this.showMessage(i.instruction,t,{type:"instruction",priority:"high",stepId:e,clearPrevious:!0,...s})}showHint(e,t,s){const i=`${e}-hint`;if(s?.showOnce&&this.shownHints.has(i)){this.logger.debug(`Hint already shown for step: ${e}`);return}const o=this.stepMessages.get(e);if(!o||!o.hint){this.logger.warn(`No hint message found for step: ${e}`);return}const r=()=>{this.showMessage(o.hint,t,{type:"hint",priority:"normal",stepId:e,metadata:s?.metadata}),this.shownHints.add(i);const a=x("hint.shown","MessagePresenter",{stepId:e,content:o.hint,triggerReason:"request"},e);t.eventBus.publish(a)};s?.delay&&s.delay>0?setTimeout(r,s.delay):r()}showSuccess(e,t,s){const i=this.stepMessages.get(e),o=s||i?.success||"ステップ完了！";this.showMessage(o,t,{type:"success",priority:"high",stepId:e,duration:3e3})}showError(e,t,s){let o=this.stepMessages.get(e)?.error||"エラーが発生しました。";s&&(o+=` (${s})`),this.showMessage(o,t,{type:"error",priority:"critical",stepId:e,duration:7e3})}showMessage(e,t,s={}){const i=this.generateMessageId(),o={id:i,type:s.type||"info",priority:s.priority||"normal",content:e,stepId:s.stepId,timestamp:Date.now(),displayDuration:s.duration||this.defaultDisplayDuration,isLocalized:!1,metadata:s.metadata};s.clearPrevious&&this.clearCurrentMessage(),this.messages.set(i,o),this.addToDisplayQueue(o);const r=x("message.shown","MessagePresenter",{messageId:i,content:o.content,priority:o.priority,duration:o.displayDuration||3e3},o.stepId);t.eventBus.publish(r),this.logger.debug(`Message queued: ${o.type}`,{messageId:i,stepId:o.stepId,priority:o.priority}),this.processDisplayQueue()}addCustomStepMessage(e,t,s){this.stepMessages.has(e)||this.stepMessages.set(e,{});const i=this.stepMessages.get(e);i[t]=s,this.logger.debug(`Added custom message for step ${e}: ${t}`)}updateStepMessages(e,t){this.stepMessages.set(e,{...t}),this.logger.debug(`Updated messages for step: ${e}`)}clearCurrentMessage(){this.currentMessage&&(this.logger.debug(`Clearing current message: ${this.currentMessage.id}`),this.currentMessage=null)}clearAllMessages(){this.messages.clear(),this.displayQueue.length=0,this.currentMessage=null,this.logger.debug("All messages cleared")}resetHints(){this.shownHints.clear(),this.logger.debug("Hint history reset")}getMessageHistory(e){const t=Array.from(this.messages.values());return e?t.filter(s=>s.stepId===e):t.sort((s,i)=>s.timestamp-i.timestamp)}getHintShowCount(e){const t=`${e}-hint`;return this.shownHints.has(t)?1:0}getStats(){const e=Array.from(this.messages.values()),t=new Map,s=new Map;for(const i of e){const o=t.get(i.type)||0;if(t.set(i.type,o+1),i.stepId){const r=s.get(i.stepId)||0;s.set(i.stepId,r+1)}}return{totalMessages:e.length,queueSize:this.displayQueue.length,hintsShown:this.shownHints.size,messagesByType:Object.fromEntries(t),messagesByStep:Object.fromEntries(s),currentMessage:this.currentMessage?.id,isProcessing:this.isProcessing}}generateMessageId(){return`msg_${Date.now()}_${Math.random().toString(36).substr(2,6)}`}addToDisplayQueue(e){const t={critical:4,high:3,normal:2,low:1},s=t[e.priority],i=this.displayQueue.findIndex(o=>t[o.priority]<s);i===-1?this.displayQueue.push(e):this.displayQueue.splice(i,0,e)}async processDisplayQueue(){if(!(this.isProcessing||this.displayQueue.length===0)){this.isProcessing=!0;try{for(;this.displayQueue.length>0;){const e=this.displayQueue.shift();await this.displayMessage(e)}}catch(e){this.logger.error("Error processing display queue",e)}finally{this.isProcessing=!1}}}async displayMessage(e){this.currentMessage=e,this.addMessageCallback&&this.addMessageCallback({text:e.content,type:e.type,priority:e.priority}),this.logger.debug(`Displaying message: ${e.id}`,{type:e.type,content:e.content}),e.displayDuration&&e.displayDuration>0&&await new Promise(t=>setTimeout(t,e.displayDuration))}update(e){}initialize(e){this.logger.debug("TutorialMessagePresenter initialize() called")}getState(){return{messagesCount:this.messages.size,queueLength:this.displayQueue.length,currentMessage:this.currentMessage?{id:this.currentMessage.id,type:this.currentMessage.type,priority:this.currentMessage.priority,stepId:this.currentMessage.stepId}:null,shownHintsCount:this.shownHints.size,isProcessing:this.isProcessing,hasCallback:!!this.addMessageCallback}}cleanup(){this.clearAllMessages(),this.resetHints(),this.addMessageCallback=void 0,this.logger.debug("TutorialMessagePresenter cleaned up")}}class Ce{type="action-validator";id="tutorial-action-validator";name="Tutorial Action Validator";isInitialized=!0;stepConstraints=new Map;actionHistory=[];blockedActionCounts=new Map;logger;universallyAllowedActions=["quit","save"];defaultStepConstraints={movement:{allowedActions:["move","wait"],blockedActions:["pickup","equip","attack","use_item","open_inventory","open_equipment"],requiredActionsForCompletion:["move"]},"item-pickup":{allowedActions:["move","pickup","wait"],blockedActions:["equip","attack","use_item","open_equipment"],requiredActionsForCompletion:["pickup"]},equipment:{allowedActions:["move","equip","open_inventory","open_equipment","wait"],blockedActions:["attack","use_item"],requiredActionsForCompletion:["equip","open_equipment"]},combat:{allowedActions:["move","attack","use_item","open_inventory","wait"],blockedActions:["equip","unequip"],requiredActionsForCompletion:["attack"]},status:{allowedActions:["move","open_status","open_inventory","open_equipment","wait"],blockedActions:["attack"],requiredActionsForCompletion:["open_status"]}};constructor(e){this.logger=e,this.initializeDefaultConstraints(),this.logger.debug("TutorialActionValidator initialized")}initializeDefaultConstraints(){for(const[e,t]of Object.entries(this.defaultStepConstraints))this.setStepConstraints(e,{stepId:e,allowedActions:t.allowedActions||[],blockedActions:t.blockedActions||[],conditionalActions:new Map,requiredActionsForCompletion:t.requiredActionsForCompletion||[],customValidators:new Map});this.logger.info(`Initialized constraints for ${this.stepConstraints.size} steps`)}setStepConstraints(e,t){this.stepConstraints.set(e,t),this.logger.debug(`Set constraints for step: ${e}`,{allowedActions:t.allowedActions.length,blockedActions:t.blockedActions.length})}validateAction(e,t,s){const i=this.getCurrentStepId(t);if(!i)return{isAllowed:!0};const o=this.stepConstraints.get(i);if(!o)return this.logger.warn(`No constraints found for step: ${i}`),{isAllowed:!0};const r={type:e,stepId:i,metadata:s};this.actionHistory.push(r);const a=this.performValidation(e,o,t,s);if(a.isAllowed){const c=x("action.validated","ActionValidator",{actionType:e,isValid:!0,stepId:i,validationPassed:!0},i);t.eventBus.publish(c)}else{const c=`${i}-${e}`,u=this.blockedActionCounts.get(c)||0;this.blockedActionCounts.set(c,u+1);const g=x("action.blocked","ActionValidator",{actionType:e,stepId:i,reason:a.reason||"Action not allowed",suggestedAction:a.suggestion,currentStepId:i},i);t.eventBus.publish(g)}return this.logger.debug(`Action validation: ${e}`,{stepId:i,allowed:a.isAllowed,reason:a.reason}),a}validateMovement(e,t,s,i){const o=this.validateAction("move",i,{from:e,to:t,direction:s});return o.isAllowed&&this.getCurrentStepId(i)==="movement"?this.validateMovementInMovementStep(e,t,i):o}validatePickup(e,t,s){const i=this.validateAction("pickup",s,{itemId:e,position:t});return i.isAllowed&&this.getCurrentStepId(s)==="item-pickup"?this.validatePickupInItemStep(e,t,s):i}validateEquipment(e,t,s){const i=this.validateAction("equip",s,{itemId:e,slotType:t});return i.isAllowed&&this.getCurrentStepId(s)==="equipment"?this.validateEquipmentInEquipmentStep(e,t,s):i}validateCombat(e,t){const s=this.validateAction("attack",t,{targetPosition:e});return s.isAllowed&&this.getCurrentStepId(t)==="combat"?this.validateCombatInCombatStep(e,t):s}addConditionalAction(e,t,s){const i=this.stepConstraints.get(e);i&&(i.conditionalActions.set(t,s),this.logger.debug(`Added conditional action: ${t} for step ${e}`))}addCustomValidator(e,t,s){const i=this.stepConstraints.get(e);i&&(i.customValidators.set(t,s),this.logger.debug(`Added custom validator: ${t} for step ${e}`))}getRequiredActionProgress(e){const t=this.stepConstraints.get(e);if(!t)return{completed:[],remaining:[]};const s=this.actionHistory.filter(a=>a.stepId===e),i=new Set(s.map(a=>a.type)),o=t.requiredActionsForCompletion.filter(a=>i.has(a)),r=t.requiredActionsForCompletion.filter(a=>!i.has(a));return{completed:o,remaining:r}}getActionHistory(e){return e?this.actionHistory.filter(t=>t.stepId===e):[...this.actionHistory]}getBlockedActionStats(){return Object.fromEntries(this.blockedActionCounts)}getStats(){const e=this.actionHistory.length,t=new Map,s=new Map;for(const o of this.actionHistory){const r=t.get(o.type)||0;if(t.set(o.type,r+1),o.stepId){const a=s.get(o.stepId)||0;s.set(o.stepId,a+1)}}const i=Array.from(this.blockedActionCounts.values()).reduce((o,r)=>o+r,0);return{totalActions:e,totalBlocked:i,actionsByType:Object.fromEntries(t),actionsByStep:Object.fromEntries(s),configuredSteps:this.stepConstraints.size,blockedActionDetails:this.getBlockedActionStats()}}performValidation(e,t,s,i){if(this.universallyAllowedActions.includes(e))return{isAllowed:!0};if(t.blockedActions.includes(e))return{isAllowed:!1,reason:`この段階では${e}は実行できません`,suggestion:`現在のステップで許可されているアクション: ${t.allowedActions.join(", ")}`};if(!t.allowedActions.includes(e))return{isAllowed:!1,reason:`${e}は現在のステップでは許可されていません`,suggestion:`利用可能なアクション: ${t.allowedActions.join(", ")}`,alternativeActions:t.allowedActions};const o=t.conditionalActions.get(e);if(o&&!o(s))return{isAllowed:!1,reason:`${e}の実行条件が満たされていません`,suggestion:"ステップの指示に従って操作してください"};const r=t.customValidators.get(e);return r?r(s,i):{isAllowed:!0}}getCurrentStepId(e){return e.services.resolve("state-manager")?.getCurrentState()?.id}validateMovementInMovementStep(e,t,s){return Math.abs(t.x-e.x)+Math.abs(t.y-e.y)>1?{isAllowed:!1,reason:"一度に一歩ずつ移動してください",suggestion:"隣接するマスに移動してください"}:{isAllowed:!0}}validatePickupInItemStep(e,t,s){return{isAllowed:!0}}validateEquipmentInEquipmentStep(e,t,s){return{isAllowed:!0}}validateCombatInCombatStep(e,t){return{isAllowed:!0}}resetHistory(){this.actionHistory.length=0,this.blockedActionCounts.clear(),this.logger.debug("Action history reset")}update(e){}initialize(e){this.initializeDefaultConstraints(),this.logger.debug("TutorialActionValidator initialize() called")}getState(){return{stepConstraintsCount:this.stepConstraints.size,actionHistoryCount:this.actionHistory.length,blockedActionCounts:Object.fromEntries(this.blockedActionCounts),currentStepConstraints:Array.from(this.stepConstraints.entries()).map(([e,t])=>({stepId:e,allowedActions:t.allowedActions,blockedActions:t.blockedActions,requiredActions:t.requiredActionsForCompletion})),recentActions:this.actionHistory.slice(-10)}}cleanup(){this.stepConstraints.clear(),this.resetHistory(),this.logger.debug("TutorialActionValidator cleaned up")}}class be{type="orchestrator";id="tutorial-orchestrator";name="Tutorial Orchestrator";isInitialized=!0;systemState="uninitialized";config;context;components=new Map;logger;updateTimer=void 0;gameStateRef;stateManager;progressTracker;doorController;messagePresenter;actionValidator;constructor(e,t,s,i={}){this.logger=s,this.config={enableAutoProgress:!0,enableHints:!0,hintDelay:1e4,enableErrorRecovery:!0,debugMode:!1,...i},this.context={eventBus:e,services:t,logger:s,gameState:null,metrics:{sessionId:`session-${Date.now()}`,startTime:Date.now(),currentStepIndex:0,totalSteps:0,completedSteps:0,skippedSteps:0,totalTimeSpent:0,totalActionsPerformed:0,totalErrorsEncountered:0,stepMetrics:new Map}},this.logger.info("TutorialOrchestrator initialized",this.config)}async initialize(e){if(this.systemState!=="uninitialized"){this.logger.warn("System already initialized");return}this.systemState="initializing",this.gameStateRef=e,e&&(this.context.gameState=e);try{await this.initializeComponents(),this.setupEventListeners(),this.registerServices(),this.systemState="running";const t=x("system.started","Orchestrator",{totalSteps:0,startTime:Date.now(),configuration:this.config,componentCount:this.components.size});this.context.eventBus.publish(t),this.logger.info("Tutorial system initialized successfully")}catch(t){this.systemState="error",this.logger.error("Failed to initialize tutorial system",t);const s=x("system.error","Orchestrator",{error:t instanceof Error?t.message:"Unknown error",systemState:this.systemState,recoverable:!1,phase:"initialization"});throw this.context.eventBus.publish(s),t}}async initializeComponents(){this.stateManager=new Se(this.logger),this.registerComponent(this.stateManager),this.progressTracker=new ve(this.logger),this.registerComponent(this.progressTracker),this.doorController=new xe(this.logger,this.gameStateRef),this.registerComponent(this.doorController),this.messagePresenter=new Te(this.logger),this.registerComponent(this.messagePresenter),this.actionValidator=new Ce(this.logger),this.registerComponent(this.actionValidator),this.logger.info(`Initialized ${this.components.size} components`)}registerComponent(e){this.components.set(e.id,e),this.logger.debug(`Registered component: ${e.id}`)}setupEventListeners(){this.context.eventBus.subscribe("step.started",e=>{e.type==="step.started"&&"stepId"in e.data&&this.onStepStarted(e.data.stepId)}),this.context.eventBus.subscribe("step.completed",e=>{e.type==="step.completed"&&"stepId"in e.data&&this.onStepCompleted(e.data.stepId)}),this.context.eventBus.subscribe("action.validated",e=>{e.type==="action.validated"&&"actionType"in e.data&&"stepId"in e.data&&this.onActionValidated(e.data.actionType,e.data.stepId)}),this.context.eventBus.subscribe("action.blocked",e=>{e.type==="action.blocked"&&"actionType"in e.data&&"stepId"in e.data&&"reason"in e.data&&this.onActionBlocked(e.data.actionType,e.data.stepId,e.data.reason)}),this.context.eventBus.subscribe("door.opened",e=>{e.type==="door.opened"&&"position"in e.data&&"stepId"in e.data&&this.onDoorOpened(e.data.position,e.data.stepId)}),this.logger.debug("Event listeners set up")}registerServices(){this.context.services.register("state-manager",this.stateManager),this.context.services.register("progress-tracker",this.progressTracker),this.context.services.register("door-controller",this.doorController),this.context.services.register("message-presenter",this.messagePresenter),this.context.services.register("action-validator",this.actionValidator),this.context.services.register("orchestrator",this),this.logger.debug("Services registered")}async startTutorial(e){if(this.systemState!=="running")throw new Error(`Cannot start tutorial in state: ${this.systemState}`);try{if(this.stateManager.setStepDefinitions(e),e.length>0){const t=e[0].id;this.stateManager.transitionTo(t,this.context),this.messagePresenter.showStepInstruction(t,this.context)}this.startAutoUpdate(),this.logger.info("Tutorial started",{steps:e.length})}catch(t){throw this.logger.error("Failed to start tutorial",t),t}}validateAction(e,t){return this.actionValidator?this.actionValidator.validateAction(e,this.context,t):{isAllowed:!0}}advanceToNextStep(){if(!this.stateManager)return!1;const e=this.stateManager.getCurrentState();if(!e)return!1;const t=this.stateManager.getNextStepId(e.id);if(!t)return this.completeTutorial(),!1;try{return this.stateManager.transitionTo(t,this.context),this.messagePresenter.showStepInstruction(t,this.context),!0}catch(s){return this.logger.error("Failed to advance to next step",s),!1}}completeTutorial(){this.systemState="completed";const e=x("system.completed","Orchestrator",{totalTime:this.progressTracker.getMetrics().totalTimeSpent,totalSteps:this.progressTracker.getMetrics().totalSteps,completedSteps:this.progressTracker.getCompletedStepsCount()});this.context.eventBus.publish(e),this.stopAutoUpdate(),this.logger.info("Tutorial completed")}onStepStarted(e){this.logger.debug(`Step started: ${e}`),this.progressTracker.setCurrentStep(e),this.config.enableHints&&this.config.hintDelay&&setTimeout(()=>{this.messagePresenter.showHint(e,this.context,{delay:0,showOnce:!0})},this.config.hintDelay)}onStepCompleted(e){this.logger.debug(`Step completed: ${e}`),this.progressTracker.markCompleted(e),this.messagePresenter.showSuccess(e,this.context),this.config.enableAutoProgress&&setTimeout(()=>{this.advanceToNextStep()},2e3)}onActionValidated(e,t){this.logger.debug(`Action validated: ${e} in step ${t}`),this.progressTracker.recordAction(t,e),this.stateManager.recordAction(t,e)}onActionBlocked(e,t,s){this.logger.debug(`Action blocked: ${e} in step ${t}`),this.messagePresenter.showError(t,this.context,s),this.progressTracker.recordError(t,`Action blocked: ${e}`,{reason:s})}onDoorOpened(e,t){this.logger.debug(`Door opened at (${e.x}, ${e.y})`),t&&this.progressTracker.recordAction(t,"door_opened")}startAutoUpdate(){this.updateTimer||(this.updateTimer=setInterval(()=>{this.updateComponents()},100),this.logger.debug("Auto-update started"))}stopAutoUpdate(){this.updateTimer&&(clearInterval(this.updateTimer),this.updateTimer=void 0,this.logger.debug("Auto-update stopped"))}updateComponents(){for(const e of this.components.values())try{e.update(this.context)}catch(t){this.logger.error(`Error updating component ${e.id}`,t)}}getStats(){const e=new Map;for(const[t,s]of this.components.entries())"getStats"in s&&typeof s.getStats=="function"&&e.set(t,s.getStats());return{systemState:this.systemState,componentCount:this.components.size,config:this.config,componentStats:Object.fromEntries(e),currentStep:this.stateManager?.getCurrentState()?.id,completionRate:this.progressTracker?.getCompletionRate()||0}}pause(){this.systemState==="running"&&(this.systemState="paused",this.stopAutoUpdate(),this.logger.info("Tutorial system paused"))}resume(){this.systemState==="paused"&&(this.systemState="running",this.startAutoUpdate(),this.logger.info("Tutorial system resumed"))}update(e){}getState(){return{systemState:this.systemState,componentCount:this.components.size,activeComponents:Array.from(this.components.keys()),configuration:this.config,isAutoUpdateEnabled:!!this.updateTimer}}cleanup(){this.stopAutoUpdate();for(const e of this.components.values())try{e.cleanup()}catch(t){this.logger.error(`Error cleaning up component ${e.id}`,t)}this.components.clear(),this.systemState="uninitialized",this.logger.info("Tutorial system cleaned up")}forceUpdate(){this.systemState==="running"&&this.updateComponents()}}class Me extends P{id="movement";name="移動チュートリアル";description="WASDキーまたは矢印キーでプレイヤーを移動させる";initialPosition;targetReached=!1;enter(e){super.enter(e);const t=e.services.resolveGameState();t?.player?.position&&(this.initialPosition={...t.player.position}),e.logger.info("Movement tutorial started")}update(e){const t=e.services.resolveGameState();if(!t?.player?.position||!this.initialPosition)return null;const s=t.player.position;if((s.x!==this.initialPosition.x||s.y!==this.initialPosition.y)&&!this.targetReached){this.targetReached=!0;const o=e.services.resolveDoorController();o&&o.openPlayerSurroundingDoors(e);const r=e.services.resolveStateManager();return r?r.getState("item-pickup"):null}return null}isCompleted(e){return this.targetReached}}class Ie extends P{id="item-pickup";name="アイテム拾得チュートリアル";description="Spaceキーでアイテムを拾う";itemPickedUp=!1;enter(e){super.enter(e);const t=e.services.resolveActionValidator();t&&t.addConditionalAction("item-pickup","equip",()=>this.itemPickedUp),e.logger.info("Item pickup tutorial started")}update(e){const t=e.services.resolveProgressTracker();if(t&&t.getActionHistory("item-pickup").some(o=>o.type==="pickup")&&!this.itemPickedUp){this.itemPickedUp=!0;const o=e.services.resolveDoorController();return o&&o.openDoorByStepId("item-pickup",e),e.services.resolveStateManager()?.getState("equipment")||null}return null}isCompleted(e){return this.itemPickedUp}}class we extends P{id="equipment";name="装備チュートリアル";description="Eキーで装備画面を開き、アイテムを装備する";equipmentOpened=!1;itemEquipped=!1;enter(e){super.enter(e),e.logger.info("Equipment tutorial started")}update(e){const t=e.services.resolveProgressTracker();if(!t)return null;const s=t.getActionHistory("equipment");if(this.equipmentOpened||s.some(o=>o.type==="open_equipment")&&(this.equipmentOpened=!0),this.itemEquipped||s.some(o=>o.type==="equip")&&(this.itemEquipped=!0),this.equipmentOpened&&this.itemEquipped){const i=e.services.resolveDoorController();return i&&i.openDoorByStepId("equipment",e),e.services.resolveStateManager()?.getState("combat")||null}return null}isCompleted(e){return this.equipmentOpened&&this.itemEquipped}}class ke extends P{id="combat";name="戦闘チュートリアル";description="敵に近づいて攻撃する";enemyDefeated=!1;enter(e){super.enter(e),e.logger.info("Combat tutorial started")}update(e){const t=e.services.resolveProgressTracker();if(t&&t.getActionHistory("combat").some(o=>o.type==="attack")&&!this.enemyDefeated){this.enemyDefeated=!0;const o=e.services.resolveDoorController();return o&&o.openDoorByStepId("combat",e),e.services.resolveStateManager()?.getState("status")||null}return null}isCompleted(e){return this.enemyDefeated}}class De extends P{id="status";name="ステータス確認チュートリアル";description="Cキーでステータス画面を開いて成長を確認する";statusOpened=!1;enter(e){super.enter(e),e.logger.info("Status tutorial started")}update(e){const t=e.services.resolveProgressTracker();return t&&t.getActionHistory("status").some(o=>o.type==="open_status")&&!this.statusOpened&&(this.statusOpened=!0),null}isCompleted(e){return this.statusOpened}exit(e){super.exit(e);const t=e.services.resolveMessagePresenter();t&&t.showSuccess("status",e,"チュートリアル完了！お疲れ様でした。"),e.logger.info("Tutorial completed successfully")}}class Ee{static states=new Map([["movement",()=>new Me],["item-pickup",()=>new Ie],["equipment",()=>new we],["combat",()=>new ke],["status",()=>new De]]);static createState(e){const t=this.states.get(e);return t?t():null}static createAllStates(){return Array.from(this.states.values()).map(e=>e())}static getAvailableStepIds(){return Array.from(this.states.keys())}static registerState(e,t){this.states.set(e,t)}}const Ae=[{id:"movement",name:"移動",description:"プレイヤーを移動させよう",order:0,required:!0},{id:"item-pickup",name:"アイテム拾得",description:"アイテムを拾ってみよう",order:1,required:!0},{id:"equipment",name:"装備",description:"アイテムを装備しよう",order:2,required:!0},{id:"combat",name:"戦闘",description:"敵と戦ってみよう",order:3,required:!0},{id:"status",name:"ステータス確認",description:"成長を確認しよう",order:4,required:!0}];class Pe{gameState=void 0;doorController=void 0;progressTracker=void 0;stateManager=void 0;actionValidator=void 0;messagePresenter=void 0;resolveGameState(){return this.gameState}resolveDoorController(){return this.doorController}resolveProgressTracker(){return this.progressTracker}resolveStateManager(){return this.stateManager}resolveActionValidator(){return this.actionValidator}resolveMessagePresenter(){return this.messagePresenter}registerGameState(e){this.gameState=e}registerDoorController(e){this.doorController=e}registerProgressTracker(e){this.progressTracker=e}registerStateManager(e){this.stateManager=e}registerActionValidator(e){this.actionValidator=e}registerMessagePresenter(e){this.messagePresenter=e}has(e){switch(e){case"game-state":return!!this.gameState;case"door-controller":return!!this.doorController;case"progress-tracker":return!!this.progressTracker;case"state-manager":return!!this.stateManager;case"action-validator":return!!this.actionValidator;case"message-presenter":return!!this.messagePresenter;default:return!1}}list(){const e=[];return this.gameState&&e.push("game-state"),this.doorController&&e.push("door-controller"),this.progressTracker&&e.push("progress-tracker"),this.stateManager&&e.push("state-manager"),this.actionValidator&&e.push("action-validator"),this.messagePresenter&&e.push("message-presenter"),e}clear(){this.gameState=void 0,this.doorController=void 0,this.progressTracker=void 0,this.stateManager=void 0,this.actionValidator=void 0,this.messagePresenter=void 0}register(e,t){switch(e){case"game-state":this.registerGameState(t);break;case"door-controller":this.registerDoorController(t);break;case"progress-tracker":this.registerProgressTracker(t);break;case"state-manager":this.registerStateManager(t);break;case"action-validator":this.registerActionValidator(t);break;case"message-presenter":this.registerMessagePresenter(t);break}}resolve(e){switch(e){case"game-state":return this.resolveGameState();case"door-controller":return this.resolveDoorController();case"progress-tracker":return this.resolveProgressTracker();case"state-manager":return this.resolveStateManager();case"action-validator":return this.resolveActionValidator();case"message-presenter":return this.resolveMessagePresenter();default:return}}}class qe{level="info";debug(e,t){this.level==="debug"&&console.debug(`[Tutorial:DEBUG] ${e}`,t||"")}info(e,t){console.info(`[Tutorial:INFO] ${e}`,t||"")}warn(e,t){console.warn(`[Tutorial:WARN] ${e}`,t||"")}error(e,t){console.error(`[Tutorial:ERROR] ${e}`,t||"")}setLevel(e){this.level=e}getLevel(){return this.level}clear(){}}class He{orchestrator;eventBus;services;logger;config;gameInterface;isInitialized=!1;constructor(e={}){this.config={enableLegacySupport:!0,enableDebugMode:!1,enableAutoProgress:!0,enableHints:!0,hintDelay:1e4,...e},this.services=new Pe,this.logger=new qe,this.config.enableDebugMode&&this.logger.setLevel("debug"),this.logger.info("GameTutorialBridge created",this.config)}async initialize(e){if(this.isInitialized){this.logger.warn("Tutorial system already initialized");return}this.gameInterface=e;try{this.eventBus=ye(this.logger),this.services.register("game-state",e.gameState),this.orchestrator=new be(this.eventBus,this.services,this.logger,{enableAutoProgress:this.config.enableAutoProgress||!1,enableHints:this.config.enableHints||!1,hintDelay:this.config.hintDelay||1e4,enableErrorRecovery:!0,debugMode:this.config.enableDebugMode||!1}),await this.orchestrator.initialize(e.gameState),this.registerStepStates(),this.setupLegacyCallbacks(),this.isInitialized=!0,this.logger.info("Tutorial system initialized successfully")}catch(t){throw this.logger.error("Failed to initialize tutorial system",t),t}}registerStepStates(){if(!this.orchestrator)return;const e=this.services.resolve("state-manager");if(e){const t=Ee.createAllStates();e.registerStates(t),this.logger.info(`Registered ${t.length} step states`)}}setupLegacyCallbacks(){if(!this.gameInterface||!this.config.enableLegacySupport)return;const e=this.services.resolve("message-presenter");e&&this.gameInterface.addMessage&&e.setMessageCallback(this.gameInterface.addMessage.bind(this.gameInterface)),this.logger.debug("Legacy callbacks set up")}async startTutorial(){if(!this.isInitialized||!this.orchestrator)throw new Error("Tutorial system not initialized");try{await this.orchestrator.startTutorial(Ae),this.logger.info("Tutorial started")}catch(e){throw this.logger.error("Failed to start tutorial",e),e}}validatePlayerAction(e,t){return this.orchestrator?this.orchestrator.validateAction(e,t):{isAllowed:!0}}notifyPlayerMoved(e,t){if(!this.eventBus)return;const s={type:"player.moved",timestamp:Date.now(),source:"Game",data:{from:e,to:t,direction:this.calculateDirection(e,t),isBlocked:!1}};this.eventBus.publish(s)}notifyItemPickedUp(e,t){if(!this.eventBus)return;const s={type:"item.picked_up",timestamp:Date.now(),source:"Game",data:{itemId:e,itemName:"Unknown Item",itemType:"unknown",position:t,success:!0}};this.eventBus.publish(s)}notifyEquipmentChanged(e,t,s){if(!this.eventBus)return;const i={type:s?"item.equipped":"item.unequipped",timestamp:Date.now(),source:"Game",data:{itemId:e,slotType:t,itemName:"Unknown Item",success:!0}};this.eventBus.publish(i)}notifyCombatStarted(e,t){if(!this.eventBus)return;const s={type:"combat.started",timestamp:Date.now(),source:"Game",data:{enemyId:e,enemyName:"Unknown Enemy",playerPosition:t,enemyPosition:t}};this.eventBus.publish(s)}notifyUIOpened(e){if(!this.eventBus)return;const t=`open_${e}`;this.validatePlayerAction(t);const s={type:"ui.opened",timestamp:Date.now(),source:"Game",data:{screenType:e,success:!0}};this.eventBus.publish(s)}pauseTutorial(){this.orchestrator&&(this.orchestrator.pause(),this.logger.info("Tutorial paused"))}resumeTutorial(){this.orchestrator&&(this.orchestrator.resume(),this.logger.info("Tutorial resumed"))}advanceToNextStep(){return this.orchestrator?this.orchestrator.advanceToNextStep():!1}getStats(){return this.orchestrator?this.orchestrator.getStats():null}getCurrentStep(){return this.services.resolve("state-manager")?.getCurrentState()}isCurrentStepCompleted(){const t=this.services.resolve("state-manager")?.getCurrentState();if(!t||!t.isCompleted)return!1;const s={eventBus:this.eventBus,services:this.services,logger:this.logger};return t.isCompleted(s)}notifyEquipmentToggled(){if(!this.orchestrator){this.logger.warn("Orchestrator not initialized");return}if(this.gameInterface&&this.config.enableLegacySupport&&(this.logger.info("Calling legacy markEquipmentToggled()"),console.log("GameTutorialBridge: About to call legacy markEquipmentToggled()"),this.gameInterface.markEquipmentToggled?.(),console.log("GameTutorialBridge: Legacy markEquipmentToggled() called")),this.eventBus){const e={type:"action.equipment_toggled",source:"GameInterface",stepId:this.getCurrentStep()?.id||"unknown",timestamp:Date.now(),data:{actionType:"equipment"}};this.eventBus.publish(e),this.logger.info("Equipment toggle event published",e)}}notifyStatusViewed(){if(!this.orchestrator){this.logger.warn("Orchestrator not initialized");return}if(this.gameInterface&&this.config.enableLegacySupport&&(this.logger.info("Calling legacy markStatusViewed()"),console.log("GameTutorialBridge: About to call legacy markStatusViewed()"),this.gameInterface.markStatusViewed?.(),console.log("GameTutorialBridge: Legacy markStatusViewed() called")),this.eventBus){const e={type:"action.status_viewed",source:"GameInterface",stepId:this.getCurrentStep()?.id||"unknown",timestamp:Date.now(),data:{actionType:"status"}};this.eventBus.publish(e),this.logger.info("Status view event published",e)}}notifyItemUsed(){if(!this.orchestrator){this.logger.warn("Orchestrator not initialized");return}this.gameInterface&&this.config.enableLegacySupport?(this.logger.info("Calling legacy markItemUsed()"),console.log("GameTutorialBridge: About to call legacy markItemUsed()"),this.gameInterface.markItemUsed?.(),console.log("GameTutorialBridge: Legacy markItemUsed() called"),console.log("GameTutorialBridge: About to call updateProgress()"),this.gameInterface.updateProgress?.(this.gameInterface.gameState),console.log("GameTutorialBridge: updateProgress() called")):console.log("GameTutorialBridge: Legacy interface not available",{hasGameInterface:!!this.gameInterface,enableLegacySupport:this.config.enableLegacySupport});const e=this.services.resolveProgressTracker();if(e){const t=this.getCurrentStep();t&&(e.recordAction?.(t.id,"pickup"),this.logger.debug(`Recorded pickup action for step: ${t.id}`))}if(this.eventBus){const t={type:"action.item_used",source:"GameInterface",stepId:this.getCurrentStep()?.id||"unknown",timestamp:Date.now(),data:{actionType:"pickup"}};this.eventBus.publish(t),this.logger.info("Item use event published as pickup action",t)}}getProgress(){return this.services.resolve("progress-tracker")?.getCompletionRate()||0}openDoorForStep(e){const t=this.services.resolve("door-controller");t&&t.openDoorByStepId(e,{eventBus:this.eventBus,services:this.services,logger:this.logger})}openPlayerSurroundingDoors(){const e=this.services.resolve("door-controller");e&&e.openPlayerSurroundingDoors({eventBus:this.eventBus,services:this.services,logger:this.logger})}openDoorAtStepIndex(e){const t=this.services.resolve("door-controller");t&&t.openDoorByStepIndex(e,{eventBus:this.eventBus,services:this.services,logger:this.logger})}calculateDirection(e,t){const s=t.x-e.x,i=t.y-e.y;return s>0?"east":s<0?"west":i>0?"south":(i<0,"north")}cleanup(){this.orchestrator&&this.orchestrator.cleanup(),this.eventBus&&this.eventBus.destroy(),this.services.clear(),this.isInitialized=!1,this.logger.info("Tutorial system cleaned up")}isReady(){return this.isInitialized}getState(){return!this.isInitialized||!this.orchestrator?null:{isReady:this.isInitialized,orchestratorState:this.orchestrator.getState(),currentStep:this.getCurrentStep(),progress:this.getProgress(),stats:this.getStats()}}getOrchestratorState(){return this.orchestrator?.getState()||null}updateOrchestrator(){if(!(!this.orchestrator||!this.isInitialized))try{this.orchestrator.forceUpdate()}catch(e){this.logger.error("Failed to update orchestrator",e)}}}class Oe{gameState;playerController;dungeonGenerator;dungeonManager;inventoryManager;overlayManager;tutorialManager;interactiveTutorialManager;unifiedTutorialSystem;gameTutorialBridge;uiManager;inputManager;gameStateManager;combatManager;equipmentManager;movementManager;floorManager;saveManager;renderer;lastUpdateTime;animationFrameId;constructor(e){this.playerController=new X({x:0,y:0}),this.dungeonGenerator=new k({width:80,height:50},1),this.dungeonManager=new Z,this.gameStateManager=new ue(this.playerController,this.dungeonManager),this.inventoryManager=null;const t={tileSize:16,fontSize:14,fontFamily:"Courier New, monospace",viewport:{width:e.width,height:e.height},colors:{background:"#000000",text:"#00ff00",player:"#00ff00",enemy:"#ff4444",wall:"#444444",floor:"#666666",explored:"#333333",visible:"#ffffff"}};this.renderer=new me(e,t),this.gameState=this.gameStateManager.createInitialGameState(),this.inventoryManager=new v(this.gameState,this.playerController,s=>this.addMessage(s),()=>this.processTurn(),s=>this.handleTutorialProgress(s),s=>this.equipmentManager.equipItemFromInventory(s),()=>this.equipmentManager.getCurrentEquipmentDisplay(),s=>this.addMessages(s),()=>this.notifyEquipmentToggle()),this.overlayManager=new ee(this.gameState,this.playerController,s=>this.useItem(s),s=>{this.equipmentManager.removeEquipment(s),this.gameState.status==="tutorial"&&this.notifyEquipmentToggle()},s=>this.addMessage(s)),this.tutorialManager=new se(this.gameState,s=>this.addMessage(s),s=>this.playerController.setPosition(s)),this.interactiveTutorialManager=new ie,this.interactiveTutorialManager.setTutorialManager(this.tutorialManager),this.unifiedTutorialSystem=new ae,this.unifiedTutorialSystem.setCallbacks({addMessage:s=>this.addMessage(s),updatePlayerPosition:s=>this.playerController.setPosition(s),processTurn:()=>this.processTurn(),setGameStatus:s=>this.gameState.status=s,openDoor:s=>this.tutorialManager.openDoorForStep(s),openPlayerSurroundingDoors:()=>this.openPlayerSurroundingDoors(),openDoorAtIndex:s=>this.openDoorAtStepIndex(s)}),this.uiManager=new ne(this.gameState,s=>this.addMessage(s),()=>this.startGame(),async()=>await this.startTutorial()),this.initializeGameTutorialBridge(),this.combatManager=new he(this.gameState,this.playerController,s=>this.addMessage(s),s=>this.movementManager.getEnemyAt(s),()=>this.processTurn(),s=>this.handleTutorialProgress(s),()=>{this.gameState.status==="tutorial"&&(this.unifiedTutorialSystem.markCombatCompleted(),this.unifiedTutorialSystem.updateProgress(this.gameState))}),this.equipmentManager=new ge(this.gameState,this.playerController,s=>this.addMessage(s)),this.movementManager=new pe(this.gameState,this.playerController,s=>this.addMessage(s),()=>this.processTurn(),s=>this.handleTutorialProgress(s)),this.floorManager=new de(this.gameState,this.playerController,this.dungeonManager,s=>this.addMessage(s),()=>this.processTurn(),()=>this.combatManager.isAttackMode(),()=>this.combatManager.toggleAttackMode(),s=>this.handleTutorialProgress(s),this.interactiveTutorialManager),this.saveManager=new M,this.inputManager=new ce(e,this.gameState,s=>this.handleDirectionalInput(s),()=>this.handleToggleAttackMode(),()=>this.handleInteract(),()=>this.handleToggleInventory(),()=>this.handleToggleStatus(),()=>this.overlayManager.toggleTakeoffOverlay(),s=>this.handleItemAction(s),()=>this.togglePause(),()=>this.uiManager.showMenu(),()=>this.uiManager.handleLanguageSwitch(),()=>this.handleEquipmentToggle()),this.lastUpdateTime=0}handleDirectionalInput(e){if(this.gameState.status==="welcome"){this.handleWelcomeNavigation(e);return}if(this.gameState.overlay.type==="pauseMenu"&&this.gameState.overlay.isVisible){this.handlePauseMenuNavigation(e);return}if(!(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")){if(this.overlayManager.isVisible()){this.overlayManager.handleNavigation(e);return}if(this.gameState.status==="tutorial"){if(this.combatManager.isAttackMode()&&!this.interactiveTutorialManager.isActionAllowed("attack")){this.addMessage("このチュートリアルステップでは攻撃はできません。");return}if(!this.combatManager.isAttackMode()&&!this.interactiveTutorialManager.isActionAllowed("move")){this.addMessage("このチュートリアルステップでは移動はできません。");return}}this.combatManager.isAttackMode()?this.combatManager.handleAttack(e):(this.movementManager.handlePlayerMove(e),this.gameState.status==="tutorial"&&this.unifiedTutorialSystem.updateProgress(this.gameState))}}handleInteract(){if(this.gameState.status==="welcome"){this.uiManager.handleWelcomeInteract();return}if(this.gameState.overlay.type==="pauseMenu"&&this.gameState.overlay.isVisible){this.handleMenuSelect();return}if(!(this.gameState.status!=="playing"&&this.gameState.status!=="tutorial")){if(this.overlayManager.isVisible()){this.overlayManager.handleInteraction();return}if(this.gameState.status==="tutorial"&&!this.interactiveTutorialManager.isActionAllowed("pickup_item")){this.addMessage("このチュートリアルステップではアイテムの取得はできません。");return}this.floorManager.handleInteract(),this.gameState.status==="tutorial"&&this.unifiedTutorialSystem.updateProgress(this.gameState)}}handleTutorialProgress(e){this.gameState.status==="tutorial"&&(this.unifiedTutorialSystem.updateProgress(this.gameState),this.unifiedTutorialSystem.markActionCompleted(e),e==="movement"&&this.tutorialManager.updateProgress(e))}showInventory(){this.inventoryManager.showInventory()}useItem(e){console.log("=== Game.useItem CALLED ==="),console.log(`Game.useItem called with index: ${e}, tutorial status: ${this.gameState.status}`);const t=this.inventoryManager.useItem(e);console.log(`Item use success: ${t}`),t&&this.gameState.status==="tutorial"&&(console.log("Marking item as used in tutorial system"),console.log("GameTutorialBridge availability:",!!this.gameTutorialBridge),this.gameTutorialBridge?(console.log("Using new tutorial system (GameTutorialBridge)"),console.log("=== CALLING GameTutorialBridge.notifyItemUsed() ==="),this.gameTutorialBridge.notifyItemUsed(),console.log("=== GameTutorialBridge.notifyItemUsed() COMPLETED ===")):(console.log("Using legacy tutorial system (UnifiedTutorialSystem)"),this.unifiedTutorialSystem.markItemUsed(),this.unifiedTutorialSystem.updateProgress(this.gameState)))}processTurn(){this.gameState.turn++,this.processEnemies(),this.checkGameState(),this.gameState.status==="tutorial"&&this.gameTutorialBridge&&this.gameTutorialBridge.updateOrchestrator()}processEnemies(){const e=this.gameState.currentDungeon,t=this.gameState.player.position;e.entities.filter(s=>s.type==="enemy").forEach(s=>{const i=Math.abs(s.position.x-t.x)+Math.abs(s.position.y-t.y);if(i<=3)if(i===1){const o="damage"in s?s.damage:10,r=this.playerController.getTotalDefense(),a=Math.max(1,o-r);this.playerController.takeDamage(a),this.gameState.player.health=this.playerController.getPlayer().health,this.gameState.currentDungeon.player.health=this.gameState.player.health;const c=this.playerController.getPlayer().health,u=this.playerController.getPlayer().maxHealth;r>0?this.addMessage(n("enemyAttackWithDefense").replace("{{enemy}}",E(s)).replace("{{damage}}",a.toString()).replace("{{defense}}",r.toString()).replace("{{health}}",Math.max(0,c).toString()).replace("{{maxHealth}}",u.toString())):this.addMessage(n("enemyAttackNormal").replace("{{enemy}}",E(s)).replace("{{damage}}",a.toString()).replace("{{health}}",Math.max(0,c).toString()).replace("{{maxHealth}}",u.toString())),this.playerController.isDead()&&(this.gameState.status="gameOver",this.addMessage(`${n("youDied")} ${n("gameOver")}`))}else{const o=Math.sign(t.x-s.position.x),r=Math.sign(t.y-s.position.y),a={x:s.position.x+o,y:s.position.y+r};this.isValidEnemyMove(a)&&(s.position=a)}})}isValidEnemyMove(e){const t=this.gameState.currentDungeon;return!f(e,t.dimensions)||t.tiles[e.y][e.x].blocking?!1:!t.entities.find(o=>o.position.x===e.x&&o.position.y===e.y&&o.blocking&&o.type!=="player")}checkGameState(){if(this.playerController.isDead()){this.gameState.status="gameOver",this.addMessage(n("gameOver"));return}if(this.gameState.currentDungeon.entities.filter(t=>t.type==="enemy").length===0&&!this.gameState.levelCleared){this.gameState.score+=100,this.gameState.levelCleared=!0,this.addMessage(n("levelCleared"));const t=this.gameState.dungeonData.currentFloor,s=this.gameState.dungeonData.maxFloor;t<s?(this.addExitStairs(),this.addMessage(n("stairsAppeared"))):this.addMessage(n("allFloorsCleared"))}}addExitStairs(){const e=this.gameState.currentDungeon,t=e.rooms;if(t.length===0)return;const s=t[t.length-1],i={x:s.position.x+Math.floor(s.dimensions.width/2),y:s.position.y+Math.floor(s.dimensions.height/2)};if(e.entities.find(a=>a.position.x===i.x&&a.position.y===i.y)){const a=[{x:i.x+1,y:i.y},{x:i.x-1,y:i.y},{x:i.x,y:i.y+1},{x:i.x,y:i.y-1}];for(const c of a)if(c.x>=s.position.x&&c.x<s.position.x+s.dimensions.width&&c.y>=s.position.y&&c.y<s.position.y+s.dimensions.height&&!e.entities.find(g=>g.position.x===c.x&&g.position.y===c.y)){i.x=c.x,i.y=c.y;break}}const r=e.tiles[i.y][i.x];r&&(r.type="stairs",r.char=">",r.color="#ffff00",r.backgroundColor="#000000",r.blocking=!1)}togglePause(){if(this.gameState.overlay.type==="pauseMenu"&&this.gameState.overlay.isVisible){this.gameState.overlay.isVisible=!1,this.gameState.overlay.type="none",this.gameState.status="playing";return}this.overlayManager.handlePauseOrClose()||(console.log("No overlay, proceeding with pause toggle"),this.gameState.status==="playing"&&(this.gameState.status="paused",this.gameState.overlay.type="pauseMenu",this.gameState.overlay.isVisible=!0,this.gameState.overlay.selectedIndex=0))}handleMenuSelect(){if(this.gameState.overlay.type!=="pauseMenu"||!this.gameState.overlay.isVisible)return;switch(this.gameState.overlay.selectedIndex){case 0:this.togglePause();break;case 1:this.saveGame();break;case 2:this.loadGame();break;case 3:this.uiManager.handleLanguageSwitch();break;case 4:this.returnToTitle();break}}handlePauseMenuNavigation(e){const s=this.gameState.overlay.selectedIndex??0;e==="south"?this.gameState.overlay.selectedIndex=Math.min(s+1,4):e==="north"&&(this.gameState.overlay.selectedIndex=Math.max(s-1,0))}addMessage(e){const t=typeof e=="string"?F(e):e;this.gameState.messages.push(t),this.gameState.messages.length>5&&this.gameState.messages.shift()}addMessages(e){this.gameState.messages=[],e.forEach(t=>{const s=typeof t=="string"?F(t):t;this.gameState.messages.push(s)})}gameLoop=e=>{const t=e-this.lastUpdateTime;this.update(t),this.render(),this.lastUpdateTime=e,this.animationFrameId=requestAnimationFrame(this.gameLoop)};update(e){}render(){if(this.gameState.status==="tutorial"){const e=this.unifiedTutorialSystem.getState(),t=e.currentStep;if(t&&e.isActive){const s={id:t.id,title:t.title,description:t.description};t.targetPosition&&(s.targetPosition=t.targetPosition),this.gameState.interactiveTutorial={currentStep:s,progress:{currentStep:e.currentStepIndex,totalSteps:e.totalSteps,percentage:Math.round(e.currentStepIndex/e.totalSteps*100)},isActive:!0}}}else delete this.gameState.interactiveTutorial;this.renderer.render(this.gameState)}start(){this.addMessage(n("searchingForExit")),this.lastUpdateTime=performance.now(),this.animationFrameId=requestAnimationFrame(this.gameLoop)}stop(){this.animationFrameId!==void 0&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=void 0)}reset(){this.stop(),this.playerController.reset({x:0,y:0}),this.gameState=this.gameStateManager.createInitialGameState()}getGameState(){return{...this.gameState}}getPlayerStats(){return this.playerController.getStats()}get inputHandler(){return this.inputManager.getInputHandler()}getRenderer(){return this.renderer}pause(){this.gameState.status==="playing"&&(this.gameState.status="paused",this.addMessage(n("gamePaused")))}resume(){this.gameState.status==="paused"&&(this.gameState.status="playing",this.addMessage(n("gameResumed")))}movePlayer(e){this.movementManager.handlePlayerMove(e)}togglePauseTest(){this.togglePause()}setOverlayStateTest(e,t,s=0){this.gameState.overlay={type:e,isVisible:t,selectedIndex:s}}navigateInventoryTest(e){this.overlayManager.handleNavigation(e)}handleDirectionalInputTest(e){this.handleDirectionalInput(e)}handleOverlayInteractionTest(){this.overlayManager.handleInteraction()}toggleAttack(){this.combatManager.toggleAttackMode()}isAttackMode(){return this.combatManager.isAttackMode()}showInventoryTest(){this.showInventory()}useItemTest(e){this.useItem(e)}addItemToPlayer(e){return this.playerController.addItem(e)}attackEnemy(e){this.combatManager.handleAttack(e)}forceMissAttack(e){this.playerController.getPosition(),this.playerController.move(e),this.addMessage(p("noEnemyInThatDirection")),this.combatManager.disableAttackMode(),this.addMessage(p("movementMode"))}getPlayerController(){return this.playerController}toggleTakeoffOverlayTest(){this.overlayManager.toggleTakeoffOverlay()}handleTakeoffInteractionTest(){this.overlayManager.handleInteraction()}navigateTakeoffTest(e){this.overlayManager.handleNavigation(e)}testHandleInteract(){this.handleInteract()}testCastEntityToItem(e){return e}testShowInventory(){this.showInventory()}testUseItem(e){const t=this.playerController.getPlayer().inventory;if(e<0||e>=t.length){this.addMessage(p("noItemInSlot",{slot:(e+1).toString()}));return}const s=t[e];this.inventoryManager.applyItemEffect(s)&&(this.playerController.removeItem(s.id,1),this.gameState.status==="tutorial"&&(console.log("GameTutorialBridge availability:",!!this.gameTutorialBridge),this.gameTutorialBridge?(console.log("Using new tutorial system (GameTutorialBridge)"),console.log("=== CALLING GameTutorialBridge.notifyItemUsed() ==="),this.gameTutorialBridge.notifyItemUsed(),console.log("=== GameTutorialBridge.notifyItemUsed() COMPLETED ===")):(console.log("Using legacy tutorial system (UnifiedTutorialSystem)"),this.unifiedTutorialSystem.markItemUsed(),this.unifiedTutorialSystem.updateProgress(this.gameState))))}testApplyItemEffect(e){return this.inventoryManager.applyItemEffect(e)}testTakeDamage(e){this.playerController.takeDamage(e),this.gameState.player.health=this.playerController.getPlayer().health}handleWelcomeNavigation(e){const t=["start","tutorial","settings"],s=this.gameState.welcome.selectedOption?t.indexOf(this.gameState.welcome.selectedOption):0;let i=s;e==="north"?i=Math.max(0,s-1):e==="south"&&(i=Math.min(t.length-1,s+1)),this.gameState.welcome.selectedOption=t[i]}startGame(){this.gameState.status="playing",this.addMessage(n("welcomeToFacility"))}returnToTitle(){this.gameState.status="title",this.gameState.overlay.type="none",this.gameState.overlay.isVisible=!1,this.gameState.overlay.selectedIndex=0,this.gameState.messages=[],this.interactiveTutorialManager&&this.interactiveTutorialManager.reset()}async startTutorial(){console.log("startTutorial() called - setting up tutorial...");const e=this.playerController.getPlayerDirect(),t=this.dungeonManager.generateTutorialDungeon(e);this.gameState.currentDungeon=t,this.gameState.player.position={...t.player.position},this.playerController.setPosition(t.player.position),console.log(`Player position synced to (${t.player.position.x}, ${t.player.position.y})`);const s={id:"tutorial-weapon",name:"チュートリアルソード",description:"装備の着脱練習用の剣",char:"/",color:"#ffaa00",type:"item",blocking:!1,visible:!0,stackable:!1,quantity:1,itemType:"weapon",damage:3,accuracy:80,position:{x:-1,y:-1}};if(this.playerController.addItem(s),console.log("Tutorial weapon added to player inventory"),this.gameState.status="tutorial",console.log("Game status set to tutorial"),this.tutorialManager.startTutorial(),console.log("Starting unified tutorial system..."),this.unifiedTutorialSystem.start(),this.gameTutorialBridge){console.log("Starting GameTutorialBridge tutorial system...");try{await this.gameTutorialBridge.startTutorial(),console.log("GameTutorialBridge tutorial started successfully")}catch(r){console.error("Failed to start GameTutorialBridge tutorial:",r)}}const i=this.unifiedTutorialSystem.getState();console.log("Unified tutorial system started:",{isActive:i.isActive,currentStepId:i.currentStepId,currentStepIndex:i.currentStepIndex});const o=this.unifiedTutorialSystem.getStepInfo();this.addMessage(`チュートリアル: ${o.title}`),this.addMessage(o.description),console.log("Tutorial setup complete:",{gameStatus:this.gameState.status,tutorialSystemActive:i.isActive,currentStep:o})}async startTutorialForTesting(){await this.startTutorial()}openPlayerSurroundingDoors(){const e=this.gameState.player.position,t=this.gameState.currentDungeon.tiles;console.log("openPlayerSurroundingDoors called, player at:",e);const s=[];for(let i=1;i<=10;i++){const o={x:e.x+i,y:e.y};if(t[o.y]&&t[o.y][o.x]){const r=t[o.y][o.x];console.log(`Checking tile at (${o.x}, ${o.y}): type=${r.type}, char="${r.char}", blocking=${r.blocking}`),r.blocking&&s.push(o)}}if(console.log(`Found ${s.length} blocked paths:`,s),s.length>0){const i=s[0];console.log(`Opening door at (${i.x}, ${i.y})`),t[i.y][i.x]={position:i,type:"floor",char:".",color:"#666666",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1},console.log(`Door opened at (${i.x}, ${i.y}) - movement tutorial complete`)}else console.log("No blocked paths found in front of player");console.log("Movement tutorial door opening complete")}openDoorAtStepIndex(e){console.log(`Opening door at step index: ${e}`);const t=this.gameState.currentDungeon.tiles;if(!t){console.log("No tiles available for door opening");return}const s=[{x:13,y:15},{x:25,y:15},{x:37,y:15},{x:49,y:15}];if(e<0||e>=s.length){console.log(`Invalid step index: ${e}`);return}const i=s[e];console.log(`Opening door at position (${i.x}, ${i.y}) for step index ${e}`),t[i.y][i.x]={position:i,type:"floor",char:".",color:"#666666",backgroundColor:"#000000",blocking:!1,explored:!1,visible:!1},console.log(`Door at step index ${e} opened successfully`)}skipTutorial(){this.tutorialManager.skipTutorial()}skipTutorialAndStartGame(){this.tutorialManager.skipTutorial(),this.startGame()}handleInteractTest(){this.handleInteract()}testGetPlayer(){return this.playerController.getPlayer()}testSetPlayerEnergy(e){this.playerController.getPlayerDirect().energy=e,this.gameState.player.energy=e}testSetPlayerHealth(e){this.playerController.getPlayerDirect().health=e,this.gameState.player.health=e,this.gameState.currentDungeon.player.health=e}testGetCombatManager(){return this.combatManager}testStartGame(){this.startGame()}getCurrentTutorialInfo(){return this.gameState.status!=="tutorial"?null:this.interactiveTutorialManager.getCurrentStepInfo()}getTutorialProgress(){return this.gameState.status!=="tutorial"?null:this.interactiveTutorialManager.getProgress()}isTutorialCompleted(){return this.unifiedTutorialSystem.state.isCompleted}getUnifiedTutorialSystem(){return this.unifiedTutorialSystem}async initializeGameTutorialBridge(){try{this.gameTutorialBridge=new He({enableLegacySupport:!0,enableDebugMode:!1,enableAutoProgress:!0,enableHints:!0,hintDelay:1e4});const e={gameState:this.gameState,addMessage:t=>this.addMessage(t),updatePlayerPosition:t=>{this.playerController.setPosition(t)},processTurn:()=>this.processTurn(),setGameStatus:t=>{this.gameState.status=t},markItemUsed:()=>{this.unifiedTutorialSystem.markItemUsed(),this.unifiedTutorialSystem.updateProgress(this.gameState)}};await this.gameTutorialBridge.initialize(e),console.log("GameTutorialBridge initialized successfully")}catch(e){console.error("Failed to initialize GameTutorialBridge:",e)}}getGameTutorialBridge(){return this.gameTutorialBridge}debugItemUse(){console.log("=== DEBUG ITEM USE STATE ===");const e=this.unifiedTutorialSystem,t=e.getState();console.log("Tutorial state:",{currentStepId:t.currentStepId,currentStepIndex:t.currentStepIndex,isActive:t.isActive,progress:t.progress});const s=this.gameState,i=e.checkStepCompletion(s);console.log("Step completion check:",i);const o=this.playerController.getPlayer().inventory;console.log("Player inventory:",o);const r=this.overlayManager.getOverlayState();console.log("Overlay state:",r),console.log("================================")}getInteractiveTutorialManager(){return this.interactiveTutorialManager}handleToggleAttackMode(){if(this.gameState.status==="tutorial"&&!this.unifiedTutorialSystem.isActionAllowed("attack")){this.addMessage("このチュートリアルステップでは攻撃モードに入れません。");return}this.combatManager.toggleAttackMode()}handleToggleInventory(){if(console.log("=== Game.handleToggleInventory START ==="),console.log("Game status:",this.gameState.status),console.log("Tutorial status:",this.gameState.status==="tutorial"),this.gameState.status==="tutorial"){const e=this.unifiedTutorialSystem.isActionAllowed("inventory");if(console.log("Inventory allowed in tutorial:",e),!e){console.log("Inventory blocked by tutorial system"),this.addMessage("このチュートリアルステップではインベントリを開けません。");return}}console.log("Calling overlayManager.toggleInventoryOverlay()"),this.overlayManager.toggleInventoryOverlay(),this.gameState.status==="tutorial"&&this.unifiedTutorialSystem.updateProgress(this.gameState),console.log("=== Game.handleToggleInventory END ===")}handleToggleStatus(){if(this.gameState.status==="tutorial"&&!this.unifiedTutorialSystem.isActionAllowed("character_status")){this.addMessage("このチュートリアルステップではステータスを開けません。");return}this.overlayManager.toggleStatusOverlay(),this.gameState.status==="tutorial"&&(this.unifiedTutorialSystem.markStatusViewed(),this.unifiedTutorialSystem.updateProgress(this.gameState),this.interactiveTutorialManager.markStatusViewed(),this.gameTutorialBridge&&(console.log("=== NOTIFYING GameTutorialBridge - STATUS VIEWED ==="),this.gameTutorialBridge.notifyStatusViewed()))}handleEquipmentToggle(){if(this.gameState.status==="tutorial"&&!this.unifiedTutorialSystem.isActionAllowed("equipment")){this.addMessage("このチュートリアルステップでは装備を確認できません。");return}this.overlayManager.toggleEquipmentOverlay(),this.gameState.overlay.isVisible&&this.gameState.overlay.type==="equipment"&&this.addMessage("装備一覧を表示しています。ESCで閉じます。")}notifyEquipmentToggle(){this.gameState.status==="tutorial"&&(console.log("=== notifyEquipmentToggle called ==="),this.unifiedTutorialSystem.markEquipmentToggled(),this.unifiedTutorialSystem.updateProgress(this.gameState),this.interactiveTutorialManager.markEquipmentToggled(),this.gameTutorialBridge&&this.gameTutorialBridge.notifyEquipmentToggled(),this.addMessage("装備を着脱しました！"))}handleItemAction(e){if(console.log(`Game.handleItemAction called with index: ${e}, status: ${this.gameState.status}, overlay: ${this.overlayManager.isType("inventory")}`),this.gameState.status!=="playing"&&this.gameState.status!=="tutorial"){console.log(`Item action blocked: invalid game status (${this.gameState.status})`);return}if(this.gameState.status==="tutorial"&&!this.unifiedTutorialSystem.isActionAllowed("item_use")){console.log("Item use blocked by unified tutorial system"),this.addMessage("このチュートリアルステップではアイテムを使用できません。");return}this.overlayManager.isType("inventory")?(console.log("Using item from overlay"),this.overlayManager.useItemFromOverlay(e)):(console.log("Using item directly (no overlay)"),this.useItem(e)),this.gameState.status==="tutorial"&&(console.log("Updating tutorial progress after item action"),console.log("=== MARKING ITEM USED IN TUTORIAL ==="),this.unifiedTutorialSystem.markItemUsed(),this.unifiedTutorialSystem.updateProgress(this.gameState),this.gameTutorialBridge&&(console.log("=== NOTIFYING GameTutorialBridge ==="),this.gameTutorialBridge.notifyItemUsed()),console.log("=== TUTORIAL UPDATES COMPLETED ==="))}saveGame(){const e=this.saveManager.save(this.gameState);e.success?this.addMessage(e.message):this.addMessage(`セーブエラー: ${e.error}`)}loadGame(){const e=this.saveManager.load();if(!e){this.addMessage("セーブデータが見つかりません");return}try{this.gameState.player.position=e.player.position,this.gameState.player.health=e.player.hp,this.gameState.player.maxHealth=e.player.maxHp,this.gameState.player.energy=e.player.energy,this.gameState.player.maxEnergy=e.player.maxEnergy,this.gameState.player.level=e.player.level,this.gameState.player.experience=e.player.exp,this.gameState.player.inventory=e.player.inventory,this.gameState.player.equipment=e.player.equipment,this.gameState.dungeonData.currentFloor=e.dungeon.currentFloor,this.gameState.turn=e.gameStats.turnCount,this.gameState.score=e.gameStats.score;const t=this.dungeonGenerator.generate(this.gameState.player);t.player=this.gameState.player,this.gameState.currentDungeon=t,this.playerController.setPosition(e.player.position),this.addMessage("ゲームをロードしました")}catch(t){this.addMessage("ロードエラー: データが破損しています"),console.error("Load error:",t)}}hasSaveData(){return this.saveManager.hasSave()}deleteSaveData(){const e=this.saveManager.deleteSave();this.addMessage(e.message)}getPlayerPosition(){return{...this.gameState.player.position}}getInventoryItemCount(){return this.gameState.player.inventory.length}isPaused(){return this.gameState.status==="paused"}getCurrentOverlay(){return this.gameState.overlay.isVisible?this.gameState.overlay.type:null}getTutorialObservable(){if(this.gameState.status!=="tutorial")return null;const e=this;return this.interactiveTutorialManager,{getTutorialState:()=>{const t=this.unifiedTutorialSystem.state;return{currentStepId:t.currentStepId,currentStepTitle:t.currentStep?.title||"",currentStepDescription:t.currentStep?.description||"",completedSteps:this.unifiedTutorialSystem.getCompletedSteps(),isCompleted:t.isCompleted,isCurrentStepCompleted:t.currentStep?this.unifiedTutorialSystem.isStepCompleted(t.currentStepId):!1}},isActionAllowed:t=>this.unifiedTutorialSystem.isActionAllowed(t),isPositionPassable:(t,s)=>{const i=e.gameState.currentDungeon.tiles,o={x:t,y:s},r={width:i[0]?.length||0,height:i.length};return f(o,r)?!i[s][t].blocking:!1}}}}document.addEventListener("DOMContentLoaded",()=>{(()=>{const s=document.getElementById("gameTitle"),i=document.getElementById("gameSubtitle"),o=document.getElementById("gameInfo");s&&(s.textContent=n("gameTitle")),i&&(i.textContent=n("gameSubtitle")),o&&(o.textContent=n("controls"))})();const e=document.getElementById("gameCanvas");if(!e){console.error("Could not find game canvas element");return}const t=new Oe(e);t.start(),window.game=t,window.gameState=()=>t.getGameState(),window.getUnifiedTutorialSystem=()=>t.getUnifiedTutorialSystem(),window.getGameTutorialBridge=()=>t.getGameTutorialBridge(),window.getTutorialCoordinates=()=>t.getUnifiedTutorialSystem()?.getCoordinateInfo?.(),window.debugItemUse=()=>t.debugItemUse(),window.localization=I,window.renderer={getRenderedTexts:()=>{const s=t.getRenderer();return s?s.getRenderedTexts():[]}},document.addEventListener("keydown",s=>{s.ctrlKey&&s.key==="t"&&(s.preventDefault(),t.getGameState().status==="tutorial"&&(console.log("Skipping tutorial (Ctrl+T)"),t.skipTutorial()))}),console.log("Terminal Descent initialized successfully"),console.log("Use WASD keys to move, F to interact, ESC to pause"),console.log("Ctrl+T to skip tutorial during tutorial (or ESC -> pause menu -> return to title)")});
